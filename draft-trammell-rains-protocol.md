---
title: RAINS (Another Internet Naming Service) Protocol Specification
abbrev: RAINS
docname: draft-trammell-rains-protocol
date: 
category: exp

ipr: trust200902
area: Internet Architecture Board
workgroup: Names and Identifiers Program
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: B. Trammell
    name: Brian Trammell
    organization: ETH Zurich NetSec
    street: Universitaetstrasse 6
    city: Zurich
    code: 8092
    country: Switzerland
    email: ietf@trammell.ch

normative:
    I-D.trammell-inip-pins:
    RFC2119:
    RFC2782:
    RFC3629:
    RFC7049:
    FIPS-186-3:
      author:
        -
          ins: NIST
      title: Digital Signature Standard FIPS 186-3
      date: June 2009


informative:
    RFC1035:
    RFC6605:
    RFC7231:
    RFC7696:
    RFC7871:

--- abstract

This document defines an alternate protocol for Internet name resolution,
designed as a prototype to facilitate conversation about the evolution or
replacement of the Domain Name System protocol. It attempts to answer the
question: "how would we design the DNS knowing what we do now," on the
background of the properties of an ideal naming service described in 
{{I-D.trammell-inip-pins}}.

--- middle

# Introduction

TODO: what is this

TODO: what is this not

TODO: why does it exist

# Terminology

TODO

2119ify!

- assertion

- authority

- querier

- context

# Architecture

The RAINS architecture is simple, and resembles the architecture of DNS. A
RAINS Server is an entity that provides transient and/or permanent storage for
assertions about names, and a lookup function that finds assertions for a
given query about a name, either by searching local storage or by delegating
to another RAINS server. RAINS servers can take on any or all of three roles:

- authority service, acting on behalf of an authority to ensure properly
  signed assertions are made available to the system (equivalent to an
  authoritative server in DNS);
- query service, acting on behalf of a client to answer queries with relevant
  assertions (equivalent to a recursive resolver in DNS), and to validate
  assertions on the client's behalf; and/or
- intermediary service, acting on behalf of neither but providing storage and
  lookup for assertions with certain properties for query and authority
  servers (partially replacing, but not really equivalent to, caching
  resolvers in DNS).

RAINS Servers use the RAINS Protocol defined in this document to exchange
queries and assertions. RAINS Clients use a subset variant of the RAINS Protocol
(called the RAINS Client Protocol) to interact with RAINS Servers providing
query services on their behalf.

# Information Model

Messages in the RAINS Protocol are made up of two kinds of elements: Assertion
and Query. A third type of element, Answer, binds a Query to a set of
Assertions in response to a Query.

## Assertion

An Assertion is a signed statement about a mapping from a subject name to an
object value, and consists of the following elements:

- Context: name of the context in which the assertion is valid;
  see {{context-in-assertions}} below.
- Subject: name about which the assertion is made. 
- Zone: name of the zone in which the assertion is made. The fully qualified
  name of the subject is made by appending the zone name to the subject name
  with a domain name separator ('.').
- Type: the type of information about the Subject contained in the 
  assertion. Each Assertion is about a single type of data.
- Object: the data of the indicated type associated with the Subject
- Signatures: one or more signatures generated by the authority for the
  Assertion. Signatures contain a time interval during which they are considered
  valid, and may contain a revocation token allowing them to be revoked before
  the end of the time interval. See {{signatures-in-assertions}} below.

The Types supported for each assertion are:

- Delegation: the authority associated with the zone identified by the name
  (roughly equivalent to the DNSSEC DS RRTYPE). The Object contains a public
  key by which the authority can be identified. 
- Redirection: The name(s) of one or more a RAINS servers providing authority
  service for the authority associated with the zone (roughly equivalent to
  the DNSSEC NS RRTYPE, but not always consulted directly during resolution).
  The Object contains a set of names.
- Address: one or more addresses associated with the name (replaces DNS A and
  AAAA RTYPEs). The Object contains a set of Addresses. An Address is an 
  {address-family, value} tuple.
- Service-Info: one or more layer 4 ports and hostnames associated with a
  service name (replaces DNS SRV RRTYPE). The object contains a {hostname,
  port-number, priority tuple}.
- Name: one or more names associated with the name (roughly equivalent to DNS
  CNAME). The Object contains a set of names.
- Certificate: a certificate which must appear at a specified location in the
  certificate chain presented on a connection attempt with the named entity
  (roughly equivalent to DNS TLSA). The details of this type will be described 
  in a separate document.
- Zone-Nameset: an expression of the set of names allowed within a zone; e.g.
  Unicode scripts or codepages in which names in the zone may be issued. This
  allows a zone to set policy on names in support of the distinguishability
  property in {{I-D.trammell-inip-pins}} that can be checked by authority and
  oracle servers at runtime. An assertion about a Subject within a Zone whose
  name is not allowed by a valid signed Zone-Nameset expression is taken to be
  invalid, even if it has a valid signature. The details of this type will be
  described in a separate document.
- Registrar: Information about the organization that caused a Subject name 
  to exist, for organization-level names.
- Registrant: Information about the organization responsible for a Subject name, 
  for organization-level names.

For a given {subject, type} tuple, multiple assertions can be valid at a given
point in time; the union of the object values of all of these assertions is
considered to be the set of valid values at that point in time.

### Context in Assertions

Assertion contexts are used to determine the validity of the signature by the
declared authority as follows:

- The global context is identified by the special context name `.'. Assertions
  in the global context are signed by the authority for the subject name. For
  example, assertions about the name simplon.inf.ethz.ch in the global context
  are only valid if signed by the relevant authority inf.ethz.ch.
- A local context is associated with a given authority. The authority-part and
  the context-part of a local context name are divided by a context marker 
  ('cx--'). The authority-part directly identifies the authority whose key was
  used to sign the assertion; assertions within a local context are only valid
  if signed by the identified authority. Authorities have complete control
  over how the contexts under their namespaces are arranged, and over the names 
  within those contexts.

Assertion context is the mechanism by which RAINS provides explicit
inconsistency (see section 5.3.2 of {{I-D.trammell-inip-pins}}). Some
examples illustrate how context works:

- For the common split-DNS case, an enterprise could place names for machines
  on its local networks within a separate context. E.g., a workstation could
  be named simplon.cab.inf.ethz.ch within the context 
  staff-workstations.cx--.inf.ethz.ch. Assertions about this name would 
  be signed by the authority
  for inf.ethz.ch. Here, the context serves simply as a marker, without enabling
  an alternate signature chain: note that the name simplon.cab.inf.ethz.ch can
  be validly signed by the authority for inf.ethz.ch if no delegation exists
  for cab.inf.ethz.ch. but simply marks this assertion as internal. This
  allows a client making requests of local names to know they are local, and
  for local resolvers to manage visibility of assertions outside the
  enterprise: explicit context makes accidental leakage of both queries and
  assertions easier to detect and avoid.
- Contexts make captive-portal interactions more explicit: a captive portal 
  resolver could respond to a query for a common website (e.g. www.google.ch)
  with a signed response directed at the captive portal, but within a context
  identifying the location as well as the ISP (e.g. 
  sihlquai.zurich.ch.cx--.starbucks.access.some-isp.net.). This response will
  be signed by the authority for starbucks.access.some-isp.net. This
  signature achieves two things: first, the client knows the result for
  www.google.ch is not globally valid; second, it can present the user with
  some indication as to the identity of the captive portal it is connected to.
 
Further examples showing how context can be used in queries as well are given
in {{context-in-queries}} below.

Developing conventions for assertion contexts for different situations will
require implementation and deployment experience, and is a subject for future
work.

### Signatures in Assertions

A signature over an assertion contains the following information elements:

- Algorithm: identifier of the algorithm used to generate the signature.
- Valid-Since: a timestamp of the start of validity of this signature.
- Valid-Until: a timestamp of the end of validity of this signature.
- Signature: the cryptographic signature itself, whose format is determined by
  the algorithm used.
- Revocation-Token: an optional revocation token for this signature, which 
  allows a signature to be replaced or removed before the end of its validity.
  Revocation tokens are generally based on hash chains, meaning that a
  signature with a revocation token "down" the chain from a given token
  supercedes it. The format and mechanism used by the revocation token is
  determined by the alogrithm used.

The signature protects all the information in an assertion as well as its own
valid-since and valid-until values and the revocation token; it does not
protect other signatures on the assertion.

### Shards and Zones

Assertions may also be grouped and signed as a group. A shard is a set of
assertions subject to the same authority within the same context, protected by
one or more signatures over all assertions within the shard. A shard may have
an additional property that given a subject and an authenticated shard, it can
be shown that either an assertion with a given name and type exists within the
shard or does not exist at all. 

A shard has the following information elements:

- Context: name of the context in which the assertions in the shard are valid;
  see {{context-in-assertions}} above.
- Zone: name of the zone in which the assertions are made.
- Content: a set of assertions sharing the context and zone.
- Signatures: one or more signatures generated by the authority for the
  shard; see {{signatures-in-assertions}}.
- Complete-Flag: if true, the shard is lexicographically complete, and subject
  names that sort such that they would be within the shard if they existed,
  but are not in the shard, can be assumed not to exist.

For efficiency's sake, information elements within a shard common to all
assertions (zone, context, signature) within the shard may be omitted from the
assertions themselves.

A zone is the entire set of shards subject to a given
authority within a given context. There are three kinds of zones;
treating these zones differently may allow lookup protocol
optimizations:

- Zones containing only delegation assertions are delegation-only zones.
  Delegation-only zones are not relevant as part of an assertion lookup, other
  than for discovering and verifying authority. Top-level domains are
  generally delegation-only.
- Zones containing no delegation assertions are final zones. Final zones are
  not relevant as part of an authority discovery.
- Zones containing at least one delegation assertion and at least one
  assertion that is not a delegation assertion are mixed zones. No
  optimizations are available for mixed zones.

A zone has the following information elements:

- Context: name of the context in which the assertions in the zone are valid;
  see {{context-in-assertions}} above.
- Zone: name of the zone.
- Content: a set of assertions and/or shards sharing the context and zone.
- Signatures: one or more signatures generated by the authority for the
  shard; see {{signatures-in-assertions}}.
- Kind: delegation-only, final, or mixed; see above.

## Query

A query is a request for a set of assertions supporting a conclusion about a
given subject-object mapping. It consists of the following information
elements:

- Contexts: an expression of the context(s) in which assertions answering the
  query will be accepted; see {{context-in-queries}} below.
- Qualified-Subject: the name about which the query is made. The subject name
  in a query must be fully-qualified. 
- Types: a set of assertion types the querier is interested in.
- Valid-Until: an optional client-generated timestamp for the query after 
  which it expires and should not be answered.
- Token: an optional client-generated token for the query, which can be used
  in the answer to refer to the query (instead of the answer containing the
  query itself).

A query expresses interest about all the given types of assertion in all the
specified contexts; more complex expressions of which types in which contexts
must be asked using multiple queries.

TODO: provide mechanisms for privacy/performance tradeoffs in queries; are
infomodel changes required here?

### Context in Queries

Contexts are used in queries as they are in assertions (see {{context-in-
assertions}}). Assertion contexts in an answer to a query have to match some
context in the query in order to respond to a query. However, there are a few
additional considerations. An assertion can only exist with a specific
context, while queries may accept answers in multiple contexts. The Contexts
part of a query is a sequence of context specifiers taken to be in order of
decreasing priority. A special null context (represented by the empty string)
indicates that assertions in any context will be accepted. Any context in the
Contexts part of a query may additionally be negated, in order to note that
assertions in those contexts are not acceptable. Negated context name
appearing in the Contexts part of a query before the null context expresses
"any context except these".

Query contexts can also be used to provide additional information to RAINS
servers about the query. For example, contexts can provide a method for
explicit selection of a CDN servers not based on either the client's or the
resolver's address (see {{RFC7871}}). Here, the CDN creates a context for
each of its content zones, and an external service selects appropriate
contexts for the client based not just on client source address but passive
and active measurement of performance. Queries for names at which content
resides can then be made within these contexts, with the priority order of
the contexts reflecting the goodness of the zone for the client. Here, a
context might be zrh.cx--.cdn-zones.some-cdn.com for names of servers
hosting content in a CDN's Zurich data center, and a client could represent
its desire to find content nearby by making queries in the zrh.cx--,
fra.cx-- (Frankfurt), and ams.cx-- (Amsterdam) contexts within cdn-zones
.some-cdn.com. In all cases, the assertions themselves will be signed by the
authority for cdn-zones.some-cdn.com, accurately representing that it is
the CDN, not the owner of the related name in the global context, that is
making the assertion.

As with assertion contexts, developing conventions for query contexts for
different situations will require implementation and deployment experience,
and is a subject for future work.

## Answer

An answer consists of a set of assertions, shards, and/or zones which respond
to a query, bound to that query. It consists of the following information elements:

- Query: the query this answer applies to. If the query was issued with a
  token, the query in the answer may omit all content except the token.
- Content: a set of assertions and/or shards answering the query.

The content of an answer content depends on whether the answer is positive or
negative. A positive answer contains the information requested in the smallest
atomic container that can be found, usually a single assertion. A negative
answer contains the information used to verify it; either a shard with the
Complete-Flag set, an entire Zone, or a Zone-Nameset assertion showing the
name is illegal within the zone.

A query is taken to have an inconclusive answer when no answer returns to the
querier before the query's Valid-Until time.

# Data Model

The RAINS data model is a relatively straightforward mapping of the
information model in {{information-model}} to the Concise Binary Object
Representation (CBOR) {{RFC7049}}, with an outer message type providing a
mechanism for future capabilities-based versioning and recognition of a
message as a RAINS message.

## Symbol Table {#cbor-symtab}

Each CBOR object in a RAINS message is implemented as maps of integer keys to
values, or arrays whose first value is integer-encoded type information, which
implements a good tradeoff between efficiency of representation and
flexibility. The meaning of each of these integer keys is given in the symbol
table below:

| Code | Name         | Description                                   |
|-----:|--------------|-----------------------------------------------|
| 0    | content      | Key: Content of a message, shard, or zone     |
| 1    | capabilities | Key: Capabilities of server sending message   |
| 2    | signatures   | Key: Signatures on a message or section       |
| 3    | subject-name | Key: Subject name in an assertion             |
| 4    | subject-zone | Key: Zone name in an assertion                |
| 5    | query-name   | Key: Qualified subject name in a query        |
| 6    | context      | Key: Context(s) of an assertion or query      |
| 7    | objects      | Key: Objects of an assertion                  |
| 8    | token        | Key: Token for referring to a data item       |
| 9    | assertion    | Section type: Assertion                       |
| 10   | shard        | Section type: Shard                           |
| 11   | shard-range  | Key: Lexical range of Assertions in Shard     |
| 12   | zone         | Section type: Zone                            |
| 13   | query        | Section type: Query                           |
| 14   | query-types  | Key: acceptable object types for query        |
| 15   | reserved     | Reserved for future use in RAINS              |
| 16   | reserved     | Reserved for future use in RAINS              |
| 17   | note-type    | Key: Notification type                        |
| 18   | notification | Section type: Notification                    |
| 19   | name         | Object type: name associated with subject     |
| 20   | reserved     | Reserved for future use in RAINS              |
| 21   | ip6-addr     | Object type: IPv6 address of subject          |
| 22   | redirection  | Object type: name of zone authority server    |
| 23   | delegation   | Object type: public key for zone delgation    |
| 24   | ip4-addr     | Object type: IPv4 address of subject          |
| 25   | reserved     | Reserved for future use in RAINS              |
| 26   | nameset      | Object type: name set expression for zone     |
| 27   | cert-info    | Object type: certificate information for name |
| 28   | service-info | Object type: service information for srvname  |
| 29   | query-opts   | Key: set of query options requested           |
| 30   | note-data    | Key: additional notification data             |
| 31   | registrar    | Object type: registrar information            |
| 32   | registrant   | Object type: registrant information           |

## Message

All interactions in RAINS take place in an outer envelope called a Message,
which is a CBOR map tagged with the RAINS Message tag (hex 0xE99BA8, decimal
15309736). 

A Message map MUST contain a content (0) key, whose value is an array of
Message Sections; a Message Section is either an Assertion, Shard, Zone, or
Query.

A Message map MAY contain a capabilities (1) key, whose value is described in
{#cbor-capabilities}.

A Message map MAY contain a signatures (2) key, whose value is an array of
Signatures as defined in {{cbor-signature}}. 

A Message map MAY contain a token (8) key, whose value is either an integer or
a UTF-8 string of maximum byte length 32. The token key may be used to refer
to the message in future messages, or may refer to a past message or query by
token.

## Message Section header

Each Message Section in the Message's content value MUST be a two-element
array. The first element in the array is the message section type, encoded as
an integer as in {{cbor-symtab}}. The second element in the array is the
message section body, defined as in {{cbor-assertion}}, {{cbor-shard}},
{{cbor-zone}}, {{cbor-query}}, or {{cbor-notification}}.

Section types are as in the following table, taken from {{cbor-symtab}}:

| Code | Name         | Description                                   |
|-----:|--------------|-----------------------------------------------|
| 9    | assertion    | Section type: Assertion                       |
| 10   | shard        | Section type: Shard                           |
| 12   | zone         | Section type: Zone                            |
| 13   | query        | Section type: Query                           |
| 18   | notification | Section type: Notification                    |

## Assertion body {#cbor-assertion}

An Assertion body is a map. The keys present in this map depend on whether the
Assertion is contained in a Message Section or in a Shard or Zone.

Assertions contained in Message Sections are "bare Assertions". Since they
cannot inherit any values from their containers, they MUST contain the
signatures (2), subject-name (3), subject-zone (4), context (6), and objects
(7) keys.

Assertions within a Shard or Zone are "contained Assertions", and can inherit
values from their containers. A contained Assertion MAY contain the signatures
(2) key and MUST contain the subject-name (3) and objects (7) keys. It MAY
contain subject-zone (4) and context (6) keys, but in this case the values of
these keys MUST be identical to the values in the containing Shard or Zone.

The value of the signatures (2) key, if present, is an array of one or more
Signatures as defined in {{cbor-signature}}. If not present, the containing
Shard or Zone MUST be signed. Signatures on a contained Assertion are
generated as if the inherited values are present in the Assertion, whether
actually present or not.

The value of the subject-name (3) key is a UTF-8 encoded {{RFC3629}} string
containing the name of the subject of the assertion. The subject name never
contains the zone in which the subject name; the fully-qualified name is
obtained by joining the subject-name to the subject-zone with a '.' character.
The subject-name must be valid according to the nameset expression for the
zone, if any.

The value of the subject-zone (4) key, if present, is a UTF-8 encoded string
containing the name of the zone in which the assertion is made. If not
present, the zone of the assertion is inherited from the containing Shard or Zone.

The value of the context (6) key, if present, is a UTF-8 encoded string
containing the name of the context in which the assertion is valid. If not
present, the context of the assertion is inherited from the containing Shard
or Zone.

The value of the objects (7) key is an array of objects, as defined in {{cbor-
object}}.

## Shard body {#cbor-shard}

A Shard body is a map. The keys present in the map depend on whether the Shard
is contained in a Message Section or in a Zone.

Shards contained in Message Sections are "bare Shards". Since they cannot
inherit any values from their contained Zone, they MUST contain the content
(0), signatures (2), subject-zone (4), and context (6) keys.

Shards within a Zone are "contained Shards", and can inherit values from their
containing Zone. A contained Shard MUST contain the content (0) key, and MAY
contain the signatures (2) key and shard-range (11) keys. It MAY contain
subject-zone (4) and context (6) keys, but in this case the values of these
keys MUST be identical to the values in the containing Zone.

The value of the content (0) key is an array of Assertion bodies as defined in
{#cbor-assertion}.

The value of the signatures (2) key, if present, is an array of one or more
Signatures as defined in {{cbor-signature}}. If not present, the containing
Zone MUST be signed. Signatures on a contained Shard are generated as if the
inherited values are present in the Shard, whether actually present or not.

The value of the subject-zone (4) key, if present, is a UTF-8 encoded string
containing the name of the zone in which the Assertions within the Shard is
made. If not present, the zone of the assertion is inherited from the
containing Zone.

The value of the context (6) key, if present, is a UTF-8 encoded string
containing the name of the context in which the Assertions within the Shard
are valid. If not present, the context of the assertion is inherited from the
containing Zone.

If the shard-range (11) key is present, the shard is lexicographically
complete within the range described in its value: a mapping for a (subject-
name, object-type) pair that should be between the two values given in the
range but is not is asserted to not exist. Lexicographic sorting is done on
subject names by ordering Unicode codepoints in ascending order; ordering on
object types is done via their code values in the symbol table in {{cbor-
symtab}}. 

The shard-range value MUST be a four element array of (subject-name A, object-
type A, subject-name B, object type B) where A does not necessarily need to
sort before B, and the (subject-name, object-type) pairs need not exist in the
shard. The shard MUST NOT contain any assertions for subject-names outside the
range.

If the shard-range key is not present, the shard is not lexicographically
complete and MUST NOT be used to make assertions about nonexistance.

## Zone Message Section body {#cbor-zone}

A Zone body is a map. Zones MUST contain the content (0), signatures (2),
subject-zone (4), and context (6) keys.

The value of the content (0) key is an array of Shard bodies as defined in
{#cbor-shard} and/or Assertion bodies as defined in {#cbor-assertion}.

The value of the subject-zone (4) key is a UTF-8 encoded string
containing the name of the Zone.

The value of the context (6) key is a UTF-8 encoded string
containing the name of the context for which the Zone is valid.

TODO: determine if Zones MUST contain all the valid assertions within the
Zone. I think so. This leads (as with inconsistent Shards) to the question of
"what happens if not", and defending against malicious inconsistency.

## Query Message Section body {#cbor-query}

A Query body is a map. Queries MUST contain the query-name (5), context (6),
and query-type (14) keys. Queries MAY contain the token(8) key and the query-
opts (30) key.

The value of the query-name (5) key is a UTF-8 encoded string containing the
fully qualified name that is the subject of the query

The value of the context (6) key is an allowable context expression, as an
array of context names as UTF-8 encoded strings. The allowable context
expression is evaluated in-order, as follows:

- Context names appearing earlier in the expression are given priority over
  context names appearing later in the expression.
- A context name may be negated by prepending the context negation marker 
  'cx--0-.' to the context name; a negated context name means the named context
  is not acceptable in answers to this query.
- The special context name '.' refers to the global context.
- The special context name 'cx--any-' means 'any context is acceptable'.

Some examples:

- ['cx--.inf.ethz.ch', 'cx--any-'] means that answers in the 
  'cx--.inf.ethz.ch' context are preferred, but any context is acceptable; 
- ['.', 'cx--.inf.ethz.ch'] means that only answers in the
  'cx--.inf.ethz.ch' or global contexts are acceptable, with the global
  context preferred;
- ['.', cx--0-.cx--.inf.ethz.ch', 'cx--any-'] means that answers in any 
  context except 'cx--.inf.ethz.ch' are acceptable, with the global context
  preferred.

An empty context array in a query is taken to be equivalent to an array
containing only ['.', 'cx--any-']; i.e. any context acceptable, global context
preferred.

The value of the query-type (14) key is an array of integers encoding the
type(s) of objects acceptable in answers to the query. All values in the
query-type array are treated at equal priority: [21,24] means the querier is
equally interested in both IPv4 and IPv6 addresses for the query-name.

The value of the token (8) key, if present, is either an integer or a UTF-8
string of maximum byte length 32. Future messages containing answers to this
query may contain the token instead of the query itself.

TODO: how do query options work?

## Notification Message Section body {#cbor-notification}

Notification Message Sections contain information about the operation of the
RAINS protocol itself. A Notification Message Section body is a map which MUST
contain the note-type (17) key and MAY contain the note-data (30) key. The
value of the note-type key is encoded as an integer as in the following table:

| Code | Description                                                    |
|-----:|----------------------------------------------------------------|
| 100  | Connection heartbeat                                           |
| 400  | Malformed message received                                     |
| 403  | Inconsistent message received                                  |
| 404  | No assertion available                                         |
| 500  | Unspecified server error                                       |
| 501  | Server not capable                                             |

Note that the status codes are chosen to be mnemonically similar to status
codes for HTTP {{RFC7231}}. Details of the meaning of each status code are
given in {{protocol-def}}.

The value of the note-data (30) key is a UTF-8 encoded string with additional
information about the notification, intended to be displayed to an
administrator to help debug the issue identified by the negotiation.

## Object {#cbor-object}

Objects are encoded as arrays in CBOR, where the first element is the type of
the object, encoded as an integer in the following table:

| Code | Name         | Description                                   |
|-----:|--------------|-----------------------------------------------|
| 19   | name         | Object type: name associated with subject     |
| 21   | ip6-addr     | Object type: IPv6 address of subject          |
| 22   | redirection  | Object type: name of zone authority server    |
| 23   | delegation   | Object type: public key for zone delgation    |
| 24   | ip4-addr     | Object type: IPv4 address of subject          |
| 26   | nameset      | Object type: name set expression for zone     |
| 27   | cert-info    | Object type: certificate information for name |
| 28   | service-info | Object type: service information for srvname  |
| 31   | registrar    | Object type: registrar information            |
| 32   | registrant   | Object type: registrant information           |

A name (19) object contains a name associated with a name as an alias. It is
represented as a two-element array. The second element is a fully-qualified
name as a UTF-8 encoded string.

An ip6-addr (21) object contains an IPv6 address associated with a name. It is
represented as a two element array. The second element is a byte array of
length 16 containing an IPv6 address in network byte order.

An ip4-addr (24) object contains an IPv4 address associated with a name. It is
represented as a two element array. The second element is a byte array of
length 4 containing an IPv4 address in network byte order.

A redirection (22) object contains the fully-qualified name of a RAINS
authority server for a named zone. It is represented as a two-element array.
The second element is a fully-qualified name of an RAINS authority server as a
UTF-8 encoded string.

A delegation (23) object contains the public key used to generate signatures
on assertions in a named zone, and by which a delegation of a name within a
zone to a subordinate zone may be verified. It is represented as an N-element
array. The second element is a signature algorithm identifier as in 
{{cbor-signature}}. Additional elements are as defined in {{cbor-signature}} 
for the given algorithm identifier.

A nameset (26) object contains an expression defining which names are allowed
and which names are disallowed in a given zone. It is represented as an N-
element array, as defined in a future draft-trammell-rains-nameset.

A cert-info (27) object contains an expression binding a certificate or
certificate authority to a name, such that connections to the name must either
use the bound certificate or a certificate signed by a bound authority. It is
represented as an N-element array, as defined in a future 
draft-trammell-rains-cert-info.

A service-info (28) object gives information about a named service. Services
are named as in {{RFC2782}}. It is represented as a four-element array. The
second element is a fully-qualified name of a host providing the named service
as a UTF-8 string. The third element is a transport port number as a positive
integer in the range 0-65535. The fourth element is a priority as a positive
integer, with lower numbers having higher priority.

A registrar (31) object gives the name and other identifying information of
the registrar (the organization which caused the name to be added to the
namespace) for organization-level names. It is represented as a UTF-8 string
containing identifying information chosen by the registrar according to the
registry's policy.

A registrant (32) object gives information about the registrant of an
organization-level name. It is represented as a UTF-8 string containing this
information, with a format chosen by the registrar according to the registry's
policy.

## Signatures and delegation keys {#cbor-signature}

RAINS supports multiple signature algorithms and hash functions for signing
assertions for cryptographic algorithm agility {{RFC7696}}. A RAINS signature
algorithm identifier specifies the signature algorithm; a hash function for
generating the HMAC; a method for generating, verifying, and interpreting hash
chain tokens in signatures; and the format of the encodings of the signature
values in Assertions, Shards, Zones, and Messages, as well as of public key
values in delegation objects.

RAINS signatures have four common elements: the algorithm identifier, a valid-
since timestamp, a valid-until timestamp, and a hash chain token. Signatures
are represented as an array of these four tokens followed by additional
elements containing the signature data itself, according to the algorithm
identifier.

Valid-since and valid-until timestamps are represented as CBOR integers
counting seconds since the UNIX epoch UTC, idenfied with tag value 1 and
encoded as in section 2.4.1 of {{RFC7049}}. A signature MUST have a valid-
until timestamp. If a signature has no specified valid-since time (i.e., is
valid from the beginning of time until its valid-until timestamp), the valid-
since time MAY be null (as in Table 2 in Section 2.3 of {{RFC7049}}).

Hash chain tokens and their use are specified in the appropriate subsection of
this section for the given algorithm identifier.

TODO: specify exactly how to generate the byte stream to be signed from a
given section. Thing serialized as CBOR with only the signature to be added,
its signature-specific elements replaced with Null. Open question: should we
remove signatures within the contents too? To verify: regenerate the object to be
signed.

The following algorithms are supported:

| Code | Signatures | Hash/HMAC | Hash Chain Token       | Format               |
|-----:|------------|-----------|------------------------|----------------------|
| 2    | ecdsa-256  | sha-256   | See {{hash-chain-rev}} | See {{ecdsa-format}} |

### ECDSA signature and public key format {#ecdsa-format}

ECDSA public keys consist of a single value, called "Q" in {{FIPS-186-3}}. Q
is a simple bit string that represents the uncompressed form of a curve point,
concatenated together as "x | y". The third element in a RAINS delegation
object is the Q bit string encoded as a CBOR byte array; RAINS delegation
objects for ECDSA-256 signatures are therefore represented as the array [23, 2, Q].

ECDSA signatures are a combination of two non-negative integers, called "r"
and "s" in {{FIPS-186-3}}. A Signature using ECDSA is represented using a six
element CBOR array, with the fifth element being r represented as a byte array
as described in Section C.2 of {{FIPS-186-3}}, and the sixth being s
represented as a byte array as described in Section C.2 of {{FIPS-186-3}}. For
ECDSA-256 signatures, each integer MUST be represented as a 32-byte array.
RAINS signatures using ECDSA-256 are therefore the array [2, valid-from,
valid-until, token, r, s].

ECDSA-256 signatures and public keys use the P-256 curve as defined in {{FIPS-186-3}}.

### Hash-chain based revocation {#hash-chain-rev}

Hash-chain based revocation allows a signature (and the Assertion, Shard, or
Zone it protects) to be replaced before it expires. To use hash-chain based
revocation, a signing entity generates a hash chain from a known seed using
the hash function specified by the signature algorithm in use, and places the
Nth value derived therefrom in the hash chain revocation token on a signature.

A revocation can be issued by generating a new section and signing it,
revealing the N-1st value from the hash chain in the revocation token. To
allow a recipient of a revoked section to verify the revocation, the following
restrictions on what can replace what apply:

- An Assertion can only be replaced by another Assertion with the same 
  Subject within the same Context and Zone, containing an Objects array 
  of the same length containing the same types of Objects. To delete Object 
  values, those values can be replaced with Null in the replacing Assertion.
- A Shard can only be replaced by another Shard with an identical shard-range 
  key, within the same Context and Zone. Incomplete Shards cannot be replaced.
- A Zone can only be replaced by another Zone with an identical name within 
  the same Context.

Signing entities can decline to use hash-chain based revocation by replacing
the revocation token with Null.

## Capabilities {#cbor-capabilities}

TODO: URNs naming server capabilities. The only one we presently support is "I listen on TCP".

# RAINS Protocol Definition {#protocol-def}

TODO: note CBOR is self-framing so we can use any transport we want. define TLS 1.3 with TFO for now, note nice fit atop QUIC.

TODO: note further that signatures are prime in RAINS, so it really doesn't matter where servers exist.

# RAINS Client Protocol

TODO: define as a subset of the full RAINS protocol, plus oracle signatures
and tags in answers to allow oracles to verify proof of answer. Preferences
for privacy/latency tradeoffs might go here.

TODO: add cx--link- and cx--site- link- and site-local contexts.

# Deployment Considerations

## Runtime consistency checking

TODO: note that the mechanisms allow inconsistent information to exist. define
algorithms for maintaining consistency at any given RAINS server. evaluate
global inconsistency of these algorithms.

## On Confidentiality and Integrity Protection

TODO: note that queries require more confidentiality than assertions. use TLS
for hop-by-hop confidentiality for now. point out data confidentiality using
COSE as a future next step.

## Authority Signer Interface

TODO: need to define a way to keep authority servers from needing secret keys.

## Client Resolver Interfaces

TODO: note we should add RAINS resolver information to DHCP. do we want a multicast
address as well? do we need to add context information to DHCP?

## Translation between RAINS and DNS

TODO: contexts are really hard to wedge into DNS.

## Rendering RAINS messages as JSON for debugging

TODO: note an algorithmic transform to replace keys with names.

# Experimental Design and Evaluation

TODO: note that this is primarily a prototype for discussion, but that we do
intend to implement it. how will we tell if something like RAINS is ready for
standardization?

# IANA Considerations

The present revision of this document 

The authors have registered the CBOR tag 15309736 to identify RAINS messages in the CBOR tag registry at https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml. 

The symbol table in this document in {{cbor-symtab}}, the notification code table in {{cbor-notification}}, and the 

# Security Considerations

TODO: point at {{signatures-in-assertions}}, {{on-confidentiality-and-
integrity-protection}}, and {{authority-signer-interface}}. Note that shards
for proving non-existence of a name are equivalent to NSEC, and that there is
explicitly no resistance against zone enumeration.

# Acknowledgments

Thanks to Daniele Asoni, Laurent Chuat, Ted Hardie, Joe Hildebrand, Steve
Matsumoto, Adrian Perrig, Raphael Reischuk, Stephen Shirley, Andrew Sullivan,
and Suzanne Woolf for the discussions leading to the design of this protocol.
