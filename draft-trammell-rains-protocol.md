---
title: RAINS (Another Internet Naming Service) Protocol Specification
abbrev: RAINS
docname: draft-trammell-rains-protocol
date: 
category: exp

ipr: trust200902
area: Internet Architecture Board
workgroup: Names and Identifiers Program
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: B. Trammell
    name: Brian Trammell
    organization: ETH Zurich NetSec
    street: Universitaetstrasse 6
    city: Zurich
    code: 8092
    country: Switzerland
    email: ietf@trammell.ch

normative:
    I-D.trammell-inip-pins:
    RFC2119:
    RFC3629:
    RFC7049:

informative:
    RFC1035:
    RFC7871:

--- abstract

This document defines an alternate protocol for Internet name resolution,
designed as a prototype to facilitate conversation about the evolution or
replacement of the Domain Name System protocol. It attempts to answer the
question: "how would we design the DNS knowing what we do now, with current
computing power at our disposal," on the background of the properties of an
ideal naming service described in {{I-D.trammell-inip-pins}}.

--- middle

# Introduction

TODO: what is this

TODO: what is this not

TODO: why does it exist

# Terminology

TODO

2119ify!

- assertion

- authority

- querier

- context

# Architecture

The RAINS architecture is simple, and resembles the architecture of DNS. A
RAINS Server is an entity that provides transient and/or permanent storage for
assertions about names, and a lookup function that finds assertions for a
given query about a name, either by searching local storage or by delegating
to another RAINS server. RAINS servers can take on any or all of three roles:

- authority service, acting on behalf of an authority to ensure properly
  signed assertions are made available to the system (equivalent to an
  authoritative server in DNS);
- query service, acting on behalf of a client to answer queries with relevant
  assertions (equivalent to a recursive resolver in DNS), and to validate
  assertions on the client's behalf; and/or
- intermediary service, acting on behalf of neither but providing storage and
  lookup for assertions with certain properties for query and authority
  servers (partially replacing, but not really equivalent to, caching
  resolvers in DNS).

RAINS Servers use the RAINS Protocol defined in this document to exchange
queries and assertions. RAINS Clients use a subset variant of the RAINS Protocol
(called the RAINS Client Protocol) to interact with RAINS Servers providing
query services on their behalf.

# Information Model

Messages in the RAINS Protocol are made up of two kinds of elements: Assertion
and Query. A third type of element, Answer, binds a Query to a set of
Assertions in response to a Query.

## Assertion

An Assertion is a signed statement about a mapping from a subject name to an
object value, and consists of the following elements:

- Context: name of the context in which the assertion is valid;
  see {{context-in-assertions}} below.
- Subject: name about which the assertion is made. 
- Zone: name of the zone in which the assertion is made. The fully qualified
  name of the subject is made by appending the zone name to the subject name
  with a domain name separator ('.').
- Type: the type of information about the Subject contained in the 
  assertion. Each Assertion is about a single type of data.
- Object: the data of the indicated type associated with the Subject
- Signatures: one or more signatures generated by the authority for the
  Assertion. Signatures contain a time interval during which they are considered
  valid, and may contain a revocation token allowing them to be revoked before
  the end of the time interval. See {{signatures-in-assertions}} below.

The Types supported for each assertion are:

- Delegation: the authority associated with the zone identified by the name
  (roughly equivalent to the DNSSEC DS RRTYPE). The Object contains a public
  key by which the authority can be identified. 
- Redirection: The name(s) of one or more a RAINS servers providing authority
  service for the authority associated with the zone (roughly equivalent to
  the DNSSEC NS RRTYPE, but not always consulted directly during resolution).
  The Object contains a set of names.
- Address: one or more addresses associated with the name (replaces DNS A and
  AAAA RTYPEs). The Object contains a set of Addresses. An Address is an 
  {address-family, value} tuple.
- Service-Info: one or more layer 4 ports and hostnames associated with a
  service name (replaces DNS SRV RRTYPE). The object contains a {hostname,
  port-number, priority tuple}.
- Name: one or more names associated with the name (roughly equivalent to DNS
  CNAME). The Object contains a set of names.
- Certificate: a certificate which must appear at a specified location in the
  certificate chain presented on a connection attempt with the named entity
  (roughly equivalent to DNS TLSA). The details of this type will be described 
  in a separate document.
- Zone-Nameset: an expression of the set of names allowed within a zone; e.g.
  Unicode scripts or codepages in which names in the zone may be issued. This
  allows a zone to set policy on names in support of the distinguishability
  property in {{I-D.trammell-inip-pins}} that can be checked by authority and
  oracle servers at runtime. An assertion about a Subject within a Zone whose
  name is not allowed by a valid signed Zone-Nameset expression is taken to be
  invalid, even if it has a valid signature. The details of this type will be
  described in a separate document.

For a given {subject, type} tuple, multiple assertions can be valid at a given
point in time; the union of the object values of all of these assertions is
considered to be the set of valid values at that point in time.

### Context in Assertions

Assertion contexts are used to determine the validity of the signature by the
declared authority as follows:

- The global context is identified by the special context name `.'. Assertions
  in the global context are signed by the authority for the subject name. For
  example, assertions about the name simplon.inf.ethz.ch in the global context
  are only valid if signed by the relevant authority inf.ethz.ch.
- A local context is associated with a given authority. The authority-part and
  the context-part of a local context name are divided by a context marker 
  ('cx--'). The authority-part directly identifies the authority whose key was
  used to sign the assertion; assertions within a local context are only valid
  if signed by the identified authority. Authorities have complete control
  over how the contexts under their namespaces are arranged, and over the names 
  within those contexts.

Assertion context is the mechanism by which RAINS provides explicit
inconsistency (see section 5.3.2 of {{I-D.trammell-inip-pins}}). Some
examples illustrate how context works:

- For the common split-DNS case, an enterprise could place names for machines
  on its local networks within a separate context. E.g., a workstation could
  be named simplon.cab.inf.ethz.ch within the context 
  staff-workstations.cx--.inf.ethz.ch. Assertions about this name would 
  be signed by the authority
  for inf.ethz.ch. Here, the context serves simply as a marker, without enabling
  an alternate signature chain: note that the name simplon.cab.inf.ethz.ch can
  be validly signed by the authority for inf.ethz.ch if no delegation exists
  for cab.inf.ethz.ch. but simply marks this assertion as internal. This
  allows a client making requests of local names to know they are local, and
  for local resolvers to manage visibility of assertions outside the
  enterprise: explicit context makes accidental leakage of both queries and
  assertions easier to detect and avoid.
- Contexts make captive-portal interactions more explicit: a captive portal 
  resolver could respond to a query for a common website (e.g. www.google.ch)
  with a signed response directed at the captive portal, but within a context
  identifying the location as well as the ISP (e.g. 
  sihlquai.zurich.ch.cx--.starbucks.access.some-isp.net.). This response will
  be signed by the authority for starbucks.access.some-isp.net. This
  signature achieves two things: first, the client knows the result for
  www.google.ch is not globally valid; second, it can present the user with
  some indication as to the identity of the captive portal it is connected to.
 
Further examples showing how context can be used in queries as well are given
in {{context-in-queries}} below.

Developing conventions for assertion contexts for different situations will
require implementation and deployment experience, and is a subject for future
work.

### Signatures in Assertions

A signature over an assertion contains the following information elements:

- Algorithm: identifier of the algorithm used to generate the signature.
- Valid-Since: a timestamp of the start of validity of this signature.
- Valid-Until: a timestamp of the end of validity of this signature.
- Signature: the cryptographic signature itself, whose format is determined by
  the algorithm used.
- Revocation-Token: an optional revocation token for this signature, which 
  allows a signature to be replaced or removed before the end of its validity.
  Revocation tokens are generally based on hash chains, meaning that a
  signature with a revocation token "down" the chain from a given token
  supercedes it. The format and mechanism used by the revocation token is
  determined by the alogrithm used.

The signature protects all the information in an assertion as well as its own
valid-since and valid-until values; it does not protect the revocation token
or other signatures on the assertion.

### Shards and Zones

Assertions may also be grouped and signed as a group. A shard is a set of
assertions subject to the same authority within the same context, protected by
one or more signatures over all assertions within the shard. A shard may have
an additional property that given a subject and an authenticated shard, it can
be shown that either an assertion with a given name and type exists within the
shard or does not exist at all. 

A shard has the following information elements:

- Context: name of the context in which the assertions in the shard are valid;
  see {{context-in-assertions}} above.
- Zone: name of the zone in which the assertions are made.
- Content: a set of assertions sharing the context and zone.
- Signatures: one or more signatures generated by the authority for the
  shard; see {{signatures-in-assertions}}.
- Complete-Flag: if true, the shard is lexicographically complete, and subject
  names that sort such that they would be within the shard if they existed,
  but are not in the shard, can be assumed not to exist.

For efficiency's sake, information elements within a shard common to all
assertions (zone, context, signature) within the shard may be omitted from the
assertions themselves.

A zone is the entire set of shards subject to a given
authority within a given context. There are three kinds of zones;
treating these zones differently may allow lookup protocol
optimizations:

- Zones containing only delegation assertions are delegation-only zones.
  Delegation-only zones are not relevant as part of an assertion lookup, other
  than for discovering and verifying authority. Top-level domains are
  generally delegation-only.
- Zones containing no delegation assertions are final zones. Final zones are
  not relevant as part of an authority discovery.
- Zones containing at least one delegation assertion and at least one
  assertion that is not a delegation assertion are mixed zones. No
  optimizations are available for mixed zones.

A zone has the following information elements:

- Context: name of the context in which the assertions in the zone are valid;
  see {{context-in-assertions}} above.
- Zone: name of the zone.
- Content: a set of assertions and/or shards sharing the context and zone.
- Signatures: one or more signatures generated by the authority for the
  shard; see {{signatures-in-assertions}}.
- Kind: delegation-only, final, or mixed; see above.

## Query

A query is a request for a set of assertions supporting a conclusion about a
given subject-object mapping. It consists of the following information
elements:

- Contexts: an expression of the context(s) in which assertions answering the
  query will be accepted; see {{context-in-queries}} below.
- Qualified-Subject: the name about which the query is made. The subject name
  in a query must be fully-qualified. 
- Types: a set of assertion types the querier is interested in.
- Valid-Until: an optional client-generated timestamp for the query after 
  which it expires and should not be answered.
- Token: an optional client-generated token for the query, which can be used
  in the answer to refer to the query (instead of the answer containing the
  query itself).

A query expresses interest about all the given types of assertion in all the
specified contexts; more complex expressions of which types in which contexts
must be asked using multiple queries.

TODO: provide mechanisms for privacy/performance tradeoffs in queries; are
infomodel changes required here?

### Context in Queries

Contexts are used in queries as they are in assertions (see {{context-in-
assertions}}). Assertion contexts in an answer to a query have to match some
context in the query in order to respond to a query. However, there are a few
additional considerations. An assertion can only exist with a specific
context, while queries may accept answers in multiple contexts. The Contexts
part of a query is a sequence of context specifiers taken to be in order of
decreasing priority. A special null context (represented by the empty string)
indicates that assertions in any context will be accepted. Any context in the
Contexts part of a query may additionally be negated, in order to note that
assertions in those contexts are not acceptable. Negated context name
appearing in the Contexts part of a query before the null context expresses
"any context except these".

Query contexts can also be used to provide additional information to RAINS
servers about the query. For example, contexts can provide a method for
explicit selection of a CDN servers not based on either the client's or the
resolver's address (see {{RFC7871}}). Here, the CDN creates a context for
each of its content zones, and an external service selects appropriate
contexts for the client based not just on client source address but passive
and active measurement of performance. Queries for names at which content
resides can then be made within these contexts, with the priority order of
the contexts reflecting the goodness of the zone for the client. Here, a
context might be zrh.cx--.cdn-zones.some-cdn.com for names of servers
hosting content in a CDN's Zurich data center, and a client could represent
its desire to find content nearby by making queries in the zrh.cx--,
fra.cx-- (Frankfurt), and ams.cx-- (Amsterdam) contexts within cdn-zones
.some-cdn.com. In all cases, the assertions themselves will be signed by the
authority for cdn-zones.some-cdn.com, accurately representing that it is
the CDN, not the owner of the related name in the global context, that is
making the assertion.

As with assertion contexts, developing conventions for query contexts for
different situations will require implementation and deployment experience,
and is a subject for future work.

## Answer

An answer consists of a set of assertions, shards, and/or zones which respond
to a query, bound to that query. It consists of the following information elements:

- Query: the query this answer applies to. If the query was issued with a
  token, the query in the answer may omit all content except the token.
- Content: a set of assertions and/or shards answering the query.

The content of an answer content depends on whether the answer is positive or
negative. A positive answer contains the information requested in the smallest
atomic container that can be found, usually a single assertion. A negative
answer contains the information used to verify it; either a shard with the
Complete-Flag set, an entire Zone, or a Zone-Nameset assertion showing the
name is illegal within the zone.

A query is taken to have an inconclusive answer when no answer returns to the
querier before the query's Valid-Until time.

# Data Model

The RAINS data model is a relatively straightforward mapping of the
information model in {{information-model}} to the Concise Binary Object
Representation (CBOR) {{RFC7049}}, with an outer message type providing a
mechanism for future capabilities-based versioning and recognition of a
message as a RAINS message.

## Symbol Table {#cbor-symtab}

Each CBOR object in a RAINS message is implemented as maps of integer keys to
values, or arrays whose first value is integer-encoded type information, which
implements a good tradeoff between efficiency of representation and
flexibility. The meaning of each of these integer keys is given in the symbol
table below:

| Code | Name         | Description                                   |
|-----:|--------------|-----------------------------------------------|
| 0    | content      | Key: Content of a message, shard, or zone     |
| 1    | reserved     | Reserved for future use in RAINS              |
| 2    | signatures   | Key: Signatures on a message or section       |
| 3    | subject-name | Key: Subject name in an assertion             |
| 4    | subject-zone | Key: Zone name in an assertion                |
| 5    | query-name   | Key: Qualified subject name in a query        |
| 6    | context      | Key: Context(s) of an assertion or query      |
| 7    | objects      | Key: Objects of an assertion                  |
| 8    | token        | Key: Token for referring to a data item       |
| 9    | assertion    | Section type: Assertion                       |
| 10   | shard        | Section type: Shard                           |
| 11   | shard-range  | Key: Lexical range of Assertions in Shard     |
| 12   | zone         | Section type: Zone                            |
| 13   | query        | Section type: Query                           |
| 14   | query-types  | Section type: queried object types            |
| 15   | reserved     | Reserved for future use in RAINS              |
| 16   | reserved     | Reserved for future use in RAINS              |
| 17   | reserved     | Reserved for future use in RAINS              |
| 18   | reserved     | Reserved for future use in RAINS              |
| 19   | name         | Object type: name associated with subject     |
| 20   | reserved     | Reserved for future use in RAINS              |
| 21   | ip6-addr     | Object type: IPv6 address of subject          |
| 22   | redirection  | Object type: name of zone authority server    |
| 23   | delegation   | Object type: public key for zone delgation    |
| 24   | ip4-addr     | Object type: IPv4 address of subject          |
| 25   | reserved     | Reserved for future use in RAINS              |
| 26   | nameset      | Object type: name set expression for zone     |
| 27   | cert-info    | Object type: certificate information for name |
| 28   | service-info | Object type: service information for srvname  |

## Message

All interactions in RAINS take place in an outer envelope called a Message,
which is a CBOR map tagged with the RAINS Message tag (hex 0xE99BA8, decimal
15309736). 

A Message map MUST contain a content (0) key, whose value is an array of
Message Sections; a Message Section is either an Assertion, Shard, Zone, or
Query.

A Message map MAY contain a signatures (2) key, whose value is an array of
Signatures as defined in {{cbor-signature}}. 

A Message map MAY contain a token (8) key, whose value is either an integer or
a UTF-8 string of maximum byte length 32.

## Message Section header

Each Message Section in the Message's content value MUST be a two-element
array. The first element in the array is the message section type, encoded as
an integer as in {{cbor-symtab}}. The second element in the array is the
message section body, defined as in {{cbor-assertion}}, {{cbor-shard}},
{{cbor-zone}}, or {{cbor-query}}.

## Assertion body {#cbor-assertion}

An Assertion body is a map. The keys present in this map depend on whether the
Assertion is contained in a Message Section or in a Shard or Zone.

Assertions contained in Message Sections are "bare Assertions". Since they
cannot inherit any values from their containers, they MUST contain the
signatures (2), subject-name (3), subject-zone (4), context (6), and objects
(7) keys.

Assertions within a Shard or Zone are "contained Assertions", and can inherit
values from their containers. A contained Assertion MAY contain the signatures
(2) key and MUST contain the subject-name (3) and objects (7) keys. It MAY
contain subject-zone (4) and context (6) keys, but in this case the values of
these keys MUST be identical to the values in the containing Shard or Zone.

The value of the signatures (2) key, if present, is an array of one or more
Signatures as defined in {{cbor-signature}}. If not present, the containing
Shard or Zone MUST be signed. Signatures on a contained Assertion are
generated as if the inherited values are present in the Assertion, whether
actually present or not.

The value of the subject-name (3) key is a UTF-8 encoded {{RFC3629}} string
containing the name of the subject of the assertion. The subject name never
contains the zone in which the subject name; the fully-qualified name is
obtained by joining the subject-name to the subject-zone with a '.' character.
The subject-name must be valid according to the nameset expression for the
zone, if any.

The value of the subject-zone (4) key, if present, is a UTF-8 encoded string
containing the name of the zone in which the assertion is made. If not
present, the zone of the assertion is inherited from the containing Shard or Zone.

The value of the context (6) key, if present, is a UTF-8 encoded string
containing the name of the context in which the assertion is valid. If not
present, the context of the assertion is inherited from the containing Shard
or Zone.

The value of the objects (7) key is an array of objects, as defined in {{cbor-
object}}.

## Shard body {#cbor-shard}

A Shard body is a map. The keys present in the map depend on whether the Shard
is contained in a Message Section or in a Zone.

Shards contained in Message Sections are "bare Shards". Since they cannot
inherit any values from their contained Zone, they MUST contain the content
(0), signatures (2), subject-zone (4), and context (6) keys.

Shards within a Zone are "contained Shards", and can inherit values from their
containing Zone. A contained Shard MUST contain the content (0) key, and MAY
contain the signatures (2) key and shard-range (11) keys. It MAY contain
subject-zone (4) and context (6) keys, but in this case the values of these
keys MUST be identical to the values in the containing Zone.

The value of the content (0) key is an array of Assertion bodies as defined in
{#cbor-assertion}.

The value of the signatures (2) key, if present, is an array of one or more
Signatures as defined in {{cbor-signature}}. If not present, the containing
Zone MUST be signed. Signatures on a contained Shard are generated as if the
inherited values are present in the Shard, whether actually present or not.

The value of the subject-zone (4) key, if present, is a UTF-8 encoded string
containing the name of the zone in which the Assertions within the Shard is
made. If not present, the zone of the assertion is inherited from the
containing Zone.

The value of the context (6) key, if present, is a UTF-8 encoded string
containing the name of the context in which the Assertions within the Shard
are valid. If not present, the context of the assertion is inherited from the
containing Zone.

If the shard-range (11) key is present, the shard is lexicographically
complete within the range described in its value: a mapping for a (subject-
name, object-type) pair that should be between the two values given in the
range but is not is asserted to not exist. Lexicographic sorting is done on
subject names by ordering Unicode codepoints in ascending order; ordering on
object types is done via their code values in the symbol table in {{cbor-
symtab}}. 

The shard-range value MUST be a four element array of (subject-name A, object-
type A, subject-name B, object type B) where A does not necessarily need to
sort before B, and the (subject-name, object-type) pairs need not exist in the
shard. The shard MUST NOT contain any assertions for subject-names outside the
range.

If the shard-range key is not present, the shard is not lexicographically
complete and MUST NOT be used to make assertions about nonexistance.

## Zone Message Section body {#cbor-zone}

A Zone body is a map. Zones MUST contain the content (0), signatures (2),
subject-zone (4), and context (6) keys.

The value of the content (0) key is an array of Shard bodies as defined in
{#cbor-shard} and/or Assertion bodies as defined in {#cbor-assertion}.

The value of the subject-zone (4) key is a UTF-8 encoded string
containing the name of the Zone.

The value of the context (6) key is a UTF-8 encoded string
containing the name of the context for which the Zone is valid.

TODO: determine if Zones MUST contain all the valid assertions within the
Zone. I think so. This leads (as with inconsistent Shards) to the question of
"what happens if not", and defending against malicious inconsistency.

## Query Message Section body {#cbor-query}

A Query body is a map. Queries MUST contain the query-name (5), context (6),
and query-type (14) keys.

TODO: work pointer here

## Object {#cbor-object}

## Signature {#cbor-signature}

TODO: choose an MTI algorithm and define this for it. make the structure as
COSE-like as possible so we can move over COSE in the future, if that makes
sense.

Signature algorithm identifiers are encoded in a signature as follows:

| Code | Signature alg | Hash function |
|-----:|---------------|---------------|
| 1    | ed25516       | sha-256       |
| 2    | ecdsa         | sha-256       |


# RAINS Protocol Definition

TODO: note CBOR is self-framing so we can use any transport we want. define TLS 1.3 with TFO for now, note nice fit atop QUIC.

TODO: note further that signatures are prime in RAINS, so it really doesn't matter where servers exist.

# RAINS Client Protocol

TODO: define as a subset of the full RAINS protocol, plus oracle signatures
and tags in answers to allow oracles to verify proof of answer. Preferences
for privacy/latency tradeoffs might go here.

# Deployment Considerations

## On Confidentiality and Integrity Protection

TODO: note that queries require more confidentiality than assertions. use TLS
for hop-by-hop confidentiality for now. point out data confidentiality using
COSE as a future next step.

## Authority Signer Interface

TODO: need to define a way to keep authority servers from needing secret keys.

## Client Resolver Interfaces

TODO: note we should add RAINS resolver information to DHCP. do we want a multicast
address as well? do we need to add context information to DHCP?

## Translation between RAINS and DNS

TODO: contexts are really hard to wedge into DNS.

# Experimental Design and Evaluation

TODO: note that this is primarily a prototype for discussion, but that we do
intend to implement it. how will we tell if something like RAINS is ready for
standardization?

# IANA Considerations

TODO: tables of CBOR integer keys to meanings in RAINS messages.

# Security Considerations

TODO: point at {{signatures-in-assertions}}, {{on-confidentiality-and-
integrity-protection}}, and {{authority-signer-interface}}. note that shards
for proving non-existence of a name are equivalent to NSEC, and that there is
explicitly no resistance against zone enumeration.

# Acknowledgments

Daniele Asoni, Laurent Chuat, Ted Hardie, Joe Hildebrand, Steve Matsumoto,
Adrian Perrig, Raphael Reischuk, Stephen Shirley, Andrew Sullivan, Suzanne
Woolf.
