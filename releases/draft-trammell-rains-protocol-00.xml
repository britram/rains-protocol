<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-trammell-rains-protocol-00" category="exp">

  <front>
    <title abbrev="RAINS">RAINS (Another Internet Naming Service) Protocol Specification</title>

    <author initials="B." surname="Trammell" fullname="Brian Trammell">
      <organization>ETH Zurich NetSec</organization>
      <address>
        <postal>
          <street>Universitaetstrasse 6</street>
          <city>Zurich</city>
          <code>8092</code>
          <country>Switzerland</country>
        </postal>
        <email>ietf@trammell.ch</email>
      </address>
    </author>

    <date year="2016" month="October" day="17"/>

    <area>Internet Architecture Board</area>
    <workgroup>Names and Identifiers Program</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines an alternate protocol for Internet name resolution,
designed as a prototype to facilitate conversation about the evolution or
replacement of the Domain Name System protocol. It attempts to answer the
question: “how would we design the DNS knowing what we do now,” on the
background of the properties of an ideal naming service described in 
<xref target="I-D.trammell-inip-pins"/>.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This document defines an experimental protocol for providing Internet name
resolution services, as a replacement for DNS, called RAINS (RAINS, Another
Internet Naming Service). It is designed as a prototype to facilitate
conversation about the evolution or replacement of the Domain Name System
protocol, and was developed as a name resolution system for the SCION
(“Scalability, Control, and Isolation on Next-Generation Networks”) future
Internet architecture <xref target="SCION"/>. It attempts to answer the
question: “how would we design the DNS knowing what we do now,” on the
background of the properties of an ideal naming service described in 
<xref target="I-D.trammell-inip-pins"/>.</t>

<t>Its architecture (<xref target="architecture"/>) and information model ({{information-
model}}) are largely compatible with the existing Domain Name System. However,
it does take several radical departures from DNS as presently defined and
implemented:</t>

<t><list style="symbols">
  <t>Delegation from a superordinate zone to a subordinate zone is done solely
with cryptography: a superordinate defines the key(s) that are valid for
signing assertions in the subordinate during a particular time interval.
Assertions about names can therefore safely be served from any infrastructure.</t>
  <t>All time references in RAINS are absolute: instead of a time to live, each
assertion’s temporal validity is defined by the temporal validity of the
signature(s) on it.</t>
  <t>All assertions have validity within a specific context. A context determines
the rules for chaining signatures to verify validity of an assertion. The
global context is a special case of context, which uses chains from the
global naming root key. The use of context explicitly separates global usage
of the DNS from local usage thereof, and allows other application-specific
naming constraints to be bound to names; see <xref target="context-in-assertions"/>.
Queries are valid in one or more contexts, with specific rules for
determining which assertions answer which queries; see {{context-in-
queries}}.</t>
  <t>There is an explicit separation between registrant-level names and sub-
registrant-level names, and explicit information about registrars and
registrants available in the naming system at runtime.</t>
  <t>Sets of valid characters and rules for valid names are defined on a per-zone
basis, and can be verified at runtime.</t>
</list></t>

<t>Instead of using a custom binary framing as DNS, RAINS uses Concise Binary
Object Representation <xref target="RFC7049"/>, partially in an effort to make
implementations easier to verify and less likely to contain potentially
dangerous parser bugs <xref target="PARSER-BUGS"/>. Like DNS, CBOR messages can be carried
atop any number of substrate protocols; RAINS is presently defined to use TLS
over persistent TCP connections (see <xref target="protocol-def"/>).</t>

</section>
<section anchor="terminology" title="Terminology">

<t>The terms MUST, MUST NOT, SHOULD, SHOULD NOT, and MAY, when they appear in
all-capitals, are to be interpreted as defined in <xref target="RFC2119"/>.</t>

<t>In addition, the following terms are used in this document as defined:</t>

<t><list style="symbols">
  <t>Authority: An entity which may make assertions about names in a zone, by virtue of holding a secret key which can generate signatures verifiable using a public key associated with a delegation to the zone.</t>
  <t>Assertion: A mapping between a name and object(s) of specified types describing the name, signed by an authority for the zone containing the subject name. See <xref target="assertion"/>.</t>
  <t>Subject: The name to which an assertion pertains.</t>
  <t>Object: A type/value pair of information about a name within an assertion.</t>
  <t>Query: An expression of interest in certain types of objects pertaining to a subject name in one or more contexts. See <xref target="query"/>.</t>
  <t>Context: Additional information about the scope in which an assertion or query is valid. See <xref target="context-in-assertions"/> and <xref target="context-in-queries"/>.</t>
  <t>Shard: A group of assertions common to a zone, with common signatures, which may be lexicographically complete for purposes of proving nonexistence of an assertion. See <xref target="shards-and-zones"/>.</t>
  <t>Zone: A group of all assertions valid at a given point in time, with common signatures, for a given level of delegation and context within the namespace. See <xref target="shards-and-zones"/>.</t>
  <t>RAINS Message: Unit of exchange in the RAINS protocol, containing assertions, shards, zones, queries, and notifications. See <xref target="cbor-message"/>.</t>
  <t>Notification: A RAINS-internal message section carrying information about the operation of the protocol itself. See <xref target="cbor-notification"/>.</t>
  <t>Authority Service: A service provided by a RAINS Server for publishing assertions by an authority. See <xref target="architecture"/>.</t>
  <t>Query Service: A service provided by a RAINS Server for answering queries on behalf of a RAINS Client. See <xref target="architecture"/>.</t>
  <t>Intermediary Service: A service provided by a RAINS Server for answering queries and providing temporary storage for assertions on behalf of other RAINS Servers. See <xref target="architecture"/>.</t>
  <t>RAINS Server: A server that speaks the RAINS Protocol, and provides on or more services on behalf of other RAINS Servers and/or RAINS Clients. See <xref target="architecture"/>.</t>
  <t>RAINS Client: A client that uses the Query Service of one or more RAINS Servers to retrieve assertions on behalf of applications that wish to connect to named services in the Internet.</t>
</list></t>

</section>
<section anchor="architecture" title="Architecture">

<t>The RAINS architecture is simple, and resembles the architecture of DNS. A
RAINS Server is an entity that provides transient and/or permanent storage for
assertions about names, and a lookup function that finds assertions for a
given query about a name, either by searching local storage or by delegating
to another RAINS server. RAINS servers can take on any or all of three roles:</t>

<t><list style="symbols">
  <t>authority service, acting on behalf of an authority to ensure properly
signed assertions are made available to the system (equivalent to an
authoritative server in DNS);</t>
  <t>query service, acting on behalf of a client to answer queries with relevant
assertions (equivalent to a recursive resolver in DNS), and to validate
assertions on the client’s behalf; and/or</t>
  <t>intermediary service, acting on behalf of neither but providing storage and
lookup for assertions with certain properties for query and authority
servers (partially replacing, but not really equivalent to, caching
resolvers in DNS).</t>
</list></t>

<t>RAINS Servers use the RAINS Protocol defined in this document to exchange
queries and assertions. RAINS Clients use a subset variant of the RAINS Protocol
(called the RAINS Client Protocol) to interact with RAINS Servers providing
query services on their behalf.</t>

</section>
<section anchor="information-model" title="Information Model">

<t>Messages in the RAINS Protocol are made up of two kinds of elements: Assertion
and Query. A third type of element, Answer, binds a Query to a set of
Assertions in response to a Query.</t>

<t>The information model in this section omits information elements required by
the resolution mechanism itself; these are defined in more detail in 
<xref target="cbor"/> and <xref target="protocol-def"/>.</t>

<section anchor="assertion" title="Assertion">

<t>An Assertion is a signed statement about a mapping from a subject name to an
object value, and consists of the following elements:</t>

<t><list style="symbols">
  <t>Context: name of the context in which the assertion is valid;
see <xref target="context-in-assertions"/> below.</t>
  <t>Subject: name about which the assertion is made.</t>
  <t>Zone: name of the zone in which the assertion is made. The fully qualified
name of the subject is made by appending the zone name to the subject name
with a domain name separator (‘.’).</t>
  <t>Type: the type of information about the Subject contained in the 
assertion. Each Assertion is about a single type of data.</t>
  <t>Object: the data of the indicated type associated with the Subject</t>
  <t>Signatures: one or more signatures generated by the authority for the
Assertion. Signatures contain a time interval during which they are considered
valid, and may contain a revocation token allowing them to be revoked before
the end of the time interval. See <xref target="signatures-in-assertions"/> below.</t>
</list></t>

<t>The Types supported for each assertion are:</t>

<t><list style="symbols">
  <t>Delegation: the authority associated with the zone identified by the name
(roughly equivalent to the DNSSEC DS RRTYPE). The Object contains a public
key by which the authority can be identified.</t>
  <t>Redirection: The name(s) of one or more a RAINS servers providing authority
service for the authority associated with the zone (roughly equivalent to
the DNSSEC NS RRTYPE, but not always consulted directly during resolution).
The Object contains a set of names.</t>
  <t>Address: one or more addresses associated with the name (replaces DNS A and
AAAA RTYPEs). The Object contains a set of Addresses. An Address is an 
{address-family, value} tuple.</t>
  <t>Service-Info: one or more layer 4 ports and hostnames associated with a
service name (replaces DNS SRV RRTYPE). The object contains a {hostname,
port-number, priority tuple}.</t>
  <t>Name: one or more names associated with the name (roughly equivalent to DNS
CNAME). The Object contains a set of names.</t>
  <t>Certificate: a certificate which must appear at a specified location in the
certificate chain presented on a connection attempt with the named entity
(roughly equivalent to DNS TLSA). The details of this type will be described 
in a separate document.</t>
  <t>Zone-Nameset: an expression of the set of names allowed within a zone; e.g.
Unicode scripts or codepages in which names in the zone may be issued. This
allows a zone to set policy on names in support of the distinguishability
property in <xref target="I-D.trammell-inip-pins"/> that can be checked by RAINS 
servers at runtime. An assertion about a Subject within a Zone whose
name is not allowed by a valid signed Zone-Nameset expression is taken to be
invalid, even if it has a valid signature. The details of this type will be
described in a separate document.</t>
  <t>Registrar: Information about the organization that caused a Subject name 
to exist, for registrant-level names.</t>
  <t>Registrant: Information about the organization responsible for a Subject name, 
for registrant-level names.</t>
</list></t>

<t>For a given {subject, type} tuple, multiple assertions can be valid at a given
point in time; the union of the object values of all of these assertions is
considered to be the set of valid values at that point in time.</t>

<section anchor="context-in-assertions" title="Context in Assertions">

<t>Assertion contexts are used to determine the validity of the signature by the
declared authority as follows:</t>

<t><list style="symbols">
  <t>The global context is identified by the special context name `.’. Assertions
in the global context are signed by the authority for the subject name. For
example, assertions about the name simplon.inf.ethz.ch in the global context
are only valid if signed by the relevant authority inf.ethz.ch.</t>
  <t>A local context is associated with a given authority. The authority-part and
the context-part of a local context name are divided by a context marker 
(‘cx–’). The authority-part directly identifies the authority whose key was
used to sign the assertion; assertions within a local context are only valid
if signed by the identified authority. Authorities have complete control
over how the contexts under their namespaces are arranged, and over the names 
within those contexts.</t>
</list></t>

<t>Assertion context is the mechanism by which RAINS provides explicit
inconsistency (see section 5.3.2 of <xref target="I-D.trammell-inip-pins"/>). Some
examples illustrate how context works:</t>

<t><list style="symbols">
  <t>For the common split-DNS case, an enterprise could place names for machines
on its local networks within a separate context. E.g., a workstation could
be named simplon.cab.inf.ethz.ch within the context 
staff-workstations.cx–.inf.ethz.ch. Assertions about this name would 
be signed by the authority
for inf.ethz.ch. Here, the context serves simply as a marker, without enabling
an alternate signature chain: note that the name simplon.cab.inf.ethz.ch can
be validly signed by the authority for inf.ethz.ch if no delegation exists
for cab.inf.ethz.ch. The context simply marks this assertion as internal. This
allows a client making requests of local names to know they are local, and
for local resolvers to manage visibility of assertions outside the
enterprise: explicit context makes accidental leakage of both queries and
assertions easier to detect and avoid.</t>
  <t>Contexts make captive-portal interactions more explicit: a captive portal 
resolver could respond to a query for a common website (e.g. www.google.ch)
with a signed response directed at the captive portal, but within a context
identifying the location as well as the ISP (e.g. 
sihlquai.zurich.ch.cx–.starbucks.access.some-isp.net.). This response will
be signed by the authority for starbucks.access.some-isp.net. This
signature achieves two things: first, the client knows the result for
www.google.ch is not globally valid; second, it can present the user with
some indication as to the identity of the captive portal it is connected to.</t>
</list></t>

<t>Further examples showing how context can be used in queries as well are given
in <xref target="context-in-queries"/> below.</t>

<t>Developing conventions for assertion contexts for different situations will
require implementation and deployment experience, and is a subject for future
work.</t>

</section>
<section anchor="signatures-in-assertions" title="Signatures in Assertions">

<t>A signature over an assertion contains the following information elements:</t>

<t><list style="symbols">
  <t>Algorithm: identifier of the algorithm used to generate the signature.</t>
  <t>Valid-Since: a timestamp of the start of validity of this signature.</t>
  <t>Valid-Until: a timestamp of the end of validity of this signature.</t>
  <t>Signature: the cryptographic signature itself, whose format is determined by
the algorithm used.</t>
  <t>Revocation-Token: an optional revocation token for this signature, which 
allows a signature to be replaced or removed before the end of its validity.
Revocation tokens are generally based on hash chains, meaning that a
signature with a revocation token “down” the chain from a given token
supercedes it. The format and mechanism used by the revocation token is
determined by the alogrithm used.</t>
</list></t>

<t>The signature protects all the information in an assertion as well as its own
valid-since and valid-until values and the revocation token; it does not
protect other signatures on the assertion.</t>

</section>
<section anchor="shards-and-zones" title="Shards and Zones">

<t>Assertions may also be grouped and signed as a group. A shard is a set of
assertions subject to the same authority within the same context, protected by
one or more signatures over all assertions within the shard. A shard may have
an additional property that given a subject and an authenticated shard, it can
be shown that either an assertion with a given name and type exists within the
shard or does not exist at all.</t>

<t>A shard has the following information elements:</t>

<t><list style="symbols">
  <t>Context: name of the context in which the assertions in the shard are valid;
see <xref target="context-in-assertions"/> above.</t>
  <t>Zone: name of the zone in which the assertions are made.</t>
  <t>Content: a set of assertions sharing the context and zone.</t>
  <t>Signatures: one or more signatures generated by the authority for the
shard; see <xref target="signatures-in-assertions"/>.</t>
  <t>Complete-Flag: if true, the shard is lexicographically complete, and subject
names that sort such that they would be within the shard if they existed,
but are not in the shard, can be assumed not to exist.</t>
</list></t>

<t>For efficiency’s sake, information elements within a shard common to all
assertions (zone, context, signature) within the shard may be omitted from the
assertions themselves.</t>

<t>A zone is the entire set of shards subject to a given
authority within a given context. There are three kinds of zones;
treating these zones differently may allow lookup protocol
optimizations:</t>

<t><list style="symbols">
  <t>Zones containing only delegation assertions are delegation-only zones.
Delegation-only zones are not relevant as part of an assertion lookup, other
than for discovering and verifying authority. Top-level domains are
generally delegation-only.</t>
  <t>Zones containing no delegation assertions are final zones. Final zones are
not relevant as part of an authority discovery.</t>
  <t>Zones containing at least one delegation assertion and at least one
assertion that is not a delegation assertion are mixed zones. No
optimizations are available for mixed zones.</t>
</list></t>

<t>A zone has the following information elements:</t>

<t><list style="symbols">
  <t>Context: name of the context in which the assertions in the zone are valid;
see <xref target="context-in-assertions"/> above.</t>
  <t>Zone: name of the zone.</t>
  <t>Content: a set of assertions and/or shards sharing the context and zone.</t>
  <t>Signatures: one or more signatures generated by the authority for the
shard; see <xref target="signatures-in-assertions"/>.</t>
  <t>Kind: delegation-only, final, or mixed; see above.</t>
</list></t>

</section>
</section>
<section anchor="query" title="Query">

<t>A query is a request for a set of assertions supporting a conclusion about a
given subject-object mapping. It consists of the following information
elements:</t>

<t><list style="symbols">
  <t>Contexts: an expression of the context(s) in which assertions answering the
query will be accepted; see <xref target="context-in-queries"/> below.</t>
  <t>Qualified-Subject: the name about which the query is made. The subject name
in a query must be fully-qualified.</t>
  <t>Types: a set of assertion types the querier is interested in.</t>
  <t>Valid-Until: an optional client-generated timestamp for the query after 
which it expires and should not be answered.</t>
  <t>Token: an optional client-generated token for the query, which can be used
in the answer to refer to the query (instead of the answer containing the
query itself).</t>
</list></t>

<t>A query expresses interest about all the given types of assertion in all the
specified contexts; more complex expressions of which types in which contexts
must be asked using multiple queries. Preferences for tradeoffs (freshness,
bandwidth efficiency, latency, privacy preservation) in servicing a query may
be bound to the query using query options.</t>

<section anchor="context-in-queries" title="Context in Queries">

<t>Contexts are used in queries as they are in assertions (see {{context-in-
assertions}}). Assertion contexts in an answer to a query have to match some
context in the query in order to respond to a query. However, there are a few
additional considerations. An assertion can only exist with a specific
context, while queries may accept answers in multiple contexts. The Contexts
part of a query is a sequence of context specifiers taken to be in order of
decreasing priority. A special null context (represented by the empty string)
indicates that assertions in any context will be accepted. Any context in the
Contexts part of a query may additionally be negated, in order to note that
assertions in those contexts are not acceptable. Negated context name
appearing in the Contexts part of a query before the null context expresses
“any context except these”.</t>

<t>Query contexts can also be used to provide additional information to RAINS
servers about the query. For example, contexts can provide a method for
explicit selection of a CDN servers not based on either the client’s or the
resolver’s address (see <xref target="RFC7871"/>). Here, the CDN creates a context for
each of its content zones, and an external service selects appropriate
contexts for the client based not just on client source address but passive
and active measurement of performance. Queries for names at which content
resides can then be made within these contexts, with the priority order of
the contexts reflecting the goodness of the zone for the client. Here, a
context might be zrh.cx–.cdn-zones.some-cdn.com for names of servers
hosting content in a CDN’s Zurich data center, and a client could represent
its desire to find content nearby by making queries in the zrh.cx–,
fra.cx– (Frankfurt), and ams.cx– (Amsterdam) contexts within cdn-zones
.some-cdn.com. In all cases, the assertions themselves will be signed by the
authority for cdn-zones.some-cdn.com, accurately representing that it is
the CDN, not the owner of the related name in the global context, that is
making the assertion.</t>

<t>As with assertion contexts, developing conventions for query contexts for
different situations will require implementation and deployment experience,
and is a subject for future work.</t>

</section>
</section>
<section anchor="answer" title="Answer">

<t>An answer consists of a set of assertions, shards, and/or zones which respond
to a query, bound to that query. It consists of the following information elements:</t>

<t><list style="symbols">
  <t>Query: the query this answer applies to. If the query was issued with a
token, the query in the answer may omit all content except the token.</t>
  <t>Content: a set of assertions and/or shards answering the query.</t>
</list></t>

<t>The content of an answer content depends on whether the answer is positive or
negative. A positive answer contains the information requested in the smallest
atomic container that can be found, usually a single assertion. A negative
answer contains the information used to verify it; either a shard with the
Complete-Flag set, an entire Zone, or a Zone-Nameset assertion showing the
name is illegal within the zone.</t>

<t>A query is taken to have an inconclusive answer when no answer returns to the
querier before the query’s Valid-Until time.</t>

</section>
</section>
<section anchor="cbor" title="Data Model">

<t>The RAINS data model is a relatively straightforward mapping of the
information model in <xref target="information-model"/> to the Concise Binary Object
Representation (CBOR) <xref target="RFC7049"/>, with an outer message type providing a
mechanism for future capabilities-based versioning and recognition of a
message as a RAINS message.</t>

<section anchor="cbor-symtab" title="Symbol Table">

<t>Each CBOR object in a RAINS message is implemented as maps of integer keys to
values, which
implements a good tradeoff between efficiency of representation and
flexibility. The meaning of each of the integer keys is given in the symbol
table below:</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>0</c>
      <c>content</c>
      <c>Content of a message, shard, or zone</c>
      <c>1</c>
      <c>capabilities</c>
      <c>Capabilities of server sending message</c>
      <c>2</c>
      <c>signatures</c>
      <c>Signatures on a message or section</c>
      <c>3</c>
      <c>subject-name</c>
      <c>Subject name in an assertion</c>
      <c>4</c>
      <c>subject-zone</c>
      <c>Zone name in an assertion</c>
      <c>5</c>
      <c>query-name</c>
      <c>Qualified subject name in a query</c>
      <c>6</c>
      <c>context</c>
      <c>Context of an assertion</c>
      <c>7</c>
      <c>objects</c>
      <c>Objects of an assertion</c>
      <c>8</c>
      <c>token</c>
      <c>Token for referring to a data item</c>
      <c>9</c>
      <c>reserved</c>
      <c>Reserved for future use in RAINS</c>
      <c>10</c>
      <c>reserved</c>
      <c>Reserved for future use in RAINS</c>
      <c>11</c>
      <c>shard-range</c>
      <c>Lexical range of Assertions in Shard</c>
      <c>12</c>
      <c>reserved</c>
      <c>Reserved for future use in RAINS</c>
      <c>13</c>
      <c>query-contexts</c>
      <c>Reserved for future use in RAINS</c>
      <c>14</c>
      <c>query-types</c>
      <c>acceptable object types for query</c>
      <c>15</c>
      <c>reserved</c>
      <c>Reserved for future use in RAINS</c>
      <c>16</c>
      <c>reserved</c>
      <c>Reserved for future use in RAINS</c>
      <c>17</c>
      <c>note-type</c>
      <c>Notification type</c>
      <c>18</c>
      <c>reserved</c>
      <c>Reserved for future use in RAINS</c>
      <c>19</c>
      <c>reserved</c>
      <c>Reserved for future use in RAINS</c>
      <c>20</c>
      <c>reserved</c>
      <c>Reserved for future use in RAINS</c>
      <c>21</c>
      <c>reserved</c>
      <c>Reserved for future use in RAINS</c>
      <c>22</c>
      <c>query-opts</c>
      <c>Set of query options requested</c>
      <c>23</c>
      <c>note-data</c>
      <c>Additional notification data</c>
</texttable>

</section>
<section anchor="cbor-message" title="Message">

<t>All interactions in RAINS take place in an outer envelope called a Message,
which is a CBOR map tagged with the RAINS Message tag (hex 0xE99BA8, decimal
15309736).</t>

<t>A Message map MUST contain a content (0) key, whose value is an array of
Message Sections; a Message Section is either an Assertion, Shard, Zone, or
Query.</t>

<t>A Message map MAY contain a capabilities (1) key, whose value is described in
{#cbor-capabilities}.</t>

<t>A Message map MAY contain a signatures (2) key, whose value is an array of
Signatures over the entire message as defined in <xref target="cbor-signature"/>, to be verified against the</t>

<t>A Message map MAY contain a token (8) key, whose value is either an integer or
a UTF-8 string of maximum byte length 32. The token key may be used to refer
to the message in future messages, or may refer to a past message or query by
token. If the message is in response to a message or query containing a token,
the message MUST contain that token.</t>

</section>
<section anchor="message-section-header" title="Message Section header">

<t>Each Message Section in the Message’s content value MUST be a two-element
array. The first element in the array is the message section type, encoded as
an integer as in <xref target="cbor-symtab"/>. The second element in the array is the
message section body, defined as in <xref target="cbor-assertion"/>, <xref target="cbor-shard"/>,
<xref target="cbor-zone"/>, <xref target="cbor-query"/>, or <xref target="cbor-notification"/>.</t>

<t>Section types are as in the following table, taken from <xref target="cbor-symtab"/>:</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>1</c>
      <c>assertion</c>
      <c>Assertion (see {{cbor-assertion})</c>
      <c>2</c>
      <c>shard</c>
      <c>Shard (see {{cbor-shard})</c>
      <c>3</c>
      <c>zone</c>
      <c>Zone (see <xref target="cbor-zone"/>)</c>
      <c>4</c>
      <c>query</c>
      <c>Query (see <xref target="cbor-query"/>)</c>
      <c>23</c>
      <c>notification</c>
      <c>Notification (see <xref target="cbor-notification"/>)</c>
</texttable>

</section>
<section anchor="cbor-assertion" title="Assertion body">

<t>An Assertion body is a map. The keys present in this map depend on whether the
Assertion is contained in a Message Section or in a Shard or Zone.</t>

<t>Assertions contained in Message Sections are “bare Assertions”. Since they
cannot inherit any values from their containers, they MUST contain the
signatures (2), subject-name (3), subject-zone (4), context (6), and objects
(7) keys.</t>

<t>Assertions within a Shard or Zone are “contained Assertions”, and can inherit
values from their containers. A contained Assertion MAY contain the signatures
(2) key and MUST contain the subject-name (3) and objects (7) keys. It MAY
contain subject-zone (4) and context (6) keys, but in this case the values of
these keys MUST be identical to the values in the containing Shard or Zone.</t>

<t>The value of the signatures (2) key, if present, is an array of one or more
Signatures as defined in <xref target="cbor-signature"/>. If not present, the containing
Shard or Zone MUST be signed. Signatures on a contained Assertion are
generated as if the inherited values are present in the Assertion, whether
actually present or not.</t>

<t>The value of the subject-name (3) key is a UTF-8 encoded <xref target="RFC3629"/> string
containing the name of the subject of the assertion. The subject name never
contains the zone in which the subject name; the fully-qualified name is
obtained by joining the subject-name to the subject-zone with a ‘.’ character.
The subject-name must be valid according to the nameset expression for the
zone, if any.</t>

<t>The value of the subject-zone (4) key, if present, is a UTF-8 encoded string
containing the name of the zone in which the assertion is made. If not
present, the zone of the assertion is inherited from the containing Shard or Zone.</t>

<t>The value of the context (6) key, if present, is a UTF-8 encoded string
containing the name of the context in which the assertion is valid. If not
present, the context of the assertion is inherited from the containing Shard
or Zone.</t>

<t>The value of the objects (7) key is an array of objects, as defined in {{cbor-
object}}.</t>

</section>
<section anchor="cbor-shard" title="Shard body">

<t>A Shard body is a map. The keys present in the map depend on whether the Shard
is contained in a Message Section or in a Zone.</t>

<t>Shards contained in Message Sections are “bare Shards”. Since they cannot
inherit any values from their contained Zone, they MUST contain the content
(0), signatures (2), subject-zone (4), and context (6) keys.</t>

<t>Shards within a Zone are “contained Shards”, and can inherit values from their
containing Zone. A contained Shard MUST contain the content (0) key, and MAY
contain the signatures (2) key and shard-range (11) keys. It MAY contain
subject-zone (4) and context (6) keys, but in this case the values of these
keys MUST be identical to the values in the containing Zone.</t>

<t>The value of the content (0) key is an array of Assertion bodies as defined in
{#cbor-assertion}.</t>

<t>The value of the signatures (2) key, if present, is an array of one or more
Signatures as defined in <xref target="cbor-signature"/>. If not present, the containing
Zone MUST be signed. Signatures on a contained Shard are generated as if the
inherited values are present in the Shard, whether actually present or not.</t>

<t>The value of the subject-zone (4) key, if present, is a UTF-8 encoded string
containing the name of the zone in which the Assertions within the Shard is
made. If not present, the zone of the assertion is inherited from the
containing Zone.</t>

<t>The value of the context (6) key, if present, is a UTF-8 encoded string
containing the name of the context in which the Assertions within the Shard
are valid. If not present, the context of the assertion is inherited from the
containing Zone.</t>

<t>If the shard-range (11) key is present, the shard is lexicographically
complete within the range described in its value: a mapping for a (subject-
name, object-type) pair that should be between the two values given in the
range but is not is asserted to not exist. Lexicographic sorting is done on
subject names by ordering Unicode codepoints in ascending order; ordering on
object types is done via their code values in <xref target="cbor-object"/> in ascending order</t>

<t>The shard-range value MUST be a four element array of (subject-name A, object-
type A, subject-name B, object type B) where A does not necessarily need to
sort before B, and the (subject-name, object-type) pairs need not exist in the
shard. The shard MUST NOT contain any assertions for subject-names outside the
range.</t>

<t>If the shard-range key is not present, the shard is not lexicographically
complete and MUST NOT be used to make assertions about nonexistance.</t>

</section>
<section anchor="cbor-zone" title="Zone Message Section body">

<t>A Zone body is a map. Zones MUST contain the content (0), signatures (2),
subject-zone (4), and context (6) keys.</t>

<t>The value of the content (0) key is an array of Shard bodies as defined in
{#cbor-shard} and/or Assertion bodies as defined in {#cbor-assertion}.</t>

<t>The value of the subject-zone (4) key is a UTF-8 encoded string
containing the name of the Zone.</t>

<t>The value of the context (6) key is a UTF-8 encoded string
containing the name of the context for which the Zone is valid.</t>

</section>
<section anchor="cbor-query" title="Query Message Section body">

<t>A Query body is a map. Queries MUST contain the query-name (5), query-contexts (13),
and query-type (14) keys. Queries MAY contain the token(8) key and the 
query-opts (22) key.</t>

<t>The value of the query-name (5) key is a UTF-8 encoded string containing the
fully qualified name that is the subject of the query.</t>

<t>The value of the query-contexts (13) key is an allowable context expression, as an
array of context names as UTF-8 encoded strings. The allowable context
expression is evaluated in-order, as follows:</t>

<t><list style="symbols">
  <t>Context names appearing earlier in the expression are given priority over
context names appearing later in the expression.</t>
  <t>A context name may be negated by prepending the context negation marker 
‘cx–0-.’ to the context name; a negated context name means the named context
is not acceptable in answers to this query.</t>
  <t>The special context name ‘.’ refers to the global context.</t>
  <t>The special context name ‘cx–any-‘ means ‘any context is acceptable’.</t>
</list></t>

<t>Some examples:</t>

<t><list style="symbols">
  <t>[‘cx–.inf.ethz.ch’, ‘cx–any-‘] means that answers in the 
‘cx–.inf.ethz.ch’ context are preferred, but any context is acceptable;</t>
  <t>[’.’, ‘cx–.inf.ethz.ch’] means that only answers in the
‘cx–.inf.ethz.ch’ or global contexts are acceptable, with the global
context preferred;</t>
  <t>[’.’, cx–0-.cx–.inf.ethz.ch’, ‘cx–any-‘] means that answers in any 
context except ‘cx–.inf.ethz.ch’ are acceptable, with the global context
preferred.</t>
</list></t>

<t>An empty context array in a query is taken to be equivalent to an array
containing only [’.’, ‘cx–any-‘]; i.e. any context acceptable, global context
preferred.</t>

<t>The value of the query-type (14) key is an array of integers encoding the
type(s) of objects (as in <xref target="cbor-object"/>) acceptable in answers to the query.
All values in the query-type array are treated at equal priority: [2,3] means
the querier is equally interested in both IPv4 and IPv6 addresses for the
query-name.</t>

<t>The value of the token (8) key, if present, is either an integer or a UTF-8
string of maximum byte length 32. Future messages or notifications containing
answers to this query MUST contain this token, if present.</t>

<t>The value of the query-opts (22) key, if present, is an array of integers in
priority order of the querier’s preferences in tradeoffs in answering the
query.</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>1</c>
      <c>Minimize end-to-end latency</c>
      <c>2</c>
      <c>Minimize last-hop answer size (bandwidth)</c>
      <c>3</c>
      <c>Minimize information leakage beyond first hop</c>
      <c>4</c>
      <c>No information leakage beyond first hop: cached answers only</c>
      <c>5</c>
      <c>Expired assertions are acceptable</c>
      <c>6</c>
      <c>Enable token tracing</c>
      <c>7</c>
      <c>Disable verification delegation (client protocol only)</c>
</texttable>

<t>Each server is free to determine how to minimize each performance metric
requested; however, servers MUST NOT generate queries to other servers if “no
information leakage” is specified, and servers MUST NOT return expired
assertions unless “expired assertions acceptable” is specified.</t>

</section>
<section anchor="cbor-notification" title="Notification Message Section body">

<t>Notification Message Sections contain information about the operation of the
RAINS protocol itself. A Notification Message Section body is a map which MUST
contain the note-type (17) key and MAY contain the token (8) and note-data (23) keys. The
value of the note-type key is encoded as an integer as in the following table:</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>100</c>
      <c>Connection heartbeat</c>
      <c>399</c>
      <c>Capability hash not understood</c>
      <c>400</c>
      <c>Malformed message received</c>
      <c>403</c>
      <c>Inconsistent message received</c>
      <c>404</c>
      <c>No assertion exists (client protocol only)</c>
      <c>413</c>
      <c>Message too large</c>
      <c>500</c>
      <c>Unspecified server error</c>
      <c>501</c>
      <c>Server not capable</c>
      <c>504</c>
      <c>No assertion available</c>
</texttable>

<t>Note that the status codes are chosen to be mnemonically similar to status
codes for HTTP <xref target="RFC7231"/>. Details of the meaning of each status code are
given in <xref target="protocol-def"/>.</t>

<t>The value of the token (8) key, if present, is either an integer or a UTF-8
string of maximum byte length 32. If the notification is in response to a
message or query containing a token, the notification MUST contain that token.</t>

<t>The value of the note-data (23) key, if present, is a UTF-8 encoded string
with additional information about the notification, intended to be displayed
to an administrator to help debug the issue identified by the negotiation.</t>

</section>
<section anchor="cbor-object" title="Object">

<t>Objects are encoded as arrays in CBOR, where the first element is the type of
the object, encoded as an integer in the following table:</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>1</c>
      <c>name</c>
      <c>name associated with subject</c>
      <c>2</c>
      <c>ip6-addr</c>
      <c>IPv6 address of subject</c>
      <c>3</c>
      <c>ip4-addr</c>
      <c>IPv4 address of subject</c>
      <c>4</c>
      <c>redirection</c>
      <c>name of zone authority server</c>
      <c>5</c>
      <c>delegation</c>
      <c>public key for zone delgation</c>
      <c>6</c>
      <c>nameset</c>
      <c>name set expression for zone</c>
      <c>7</c>
      <c>cert-info</c>
      <c>certificate information for name</c>
      <c>8</c>
      <c>service-info</c>
      <c>service information for srvname</c>
      <c>9</c>
      <c>registrar</c>
      <c>registrar information</c>
      <c>10</c>
      <c>registrant</c>
      <c>registrant information</c>
      <c>11</c>
      <c>infrakey</c>
      <c>public key for RAINS infrastructure</c>
      <c>12-23</c>
      <c>reserved</c>
      <c>Reserved for future use in RAINS</c>
</texttable>

<t>A name (1) object contains a name associated with a name as an alias. It is
represented as a two-element array. The second element is a fully-qualified
name as a UTF-8 encoded string.</t>

<t>An ip6-addr (2) object contains an IPv6 address associated with a name. It is
represented as a two element array. The second element is a byte array of
length 16 containing an IPv6 address in network byte order.</t>

<t>An ip4-addr (3) object contains an IPv4 address associated with a name. It is
represented as a two element array. The second element is a byte array of
length 4 containing an IPv4 address in network byte order.</t>

<t>A redirection (4) object contains the fully-qualified name of a RAINS
authority server for a named zone. It is represented as a two-element array.
The second element is a fully-qualified name of an RAINS authority server as a
UTF-8 encoded string.</t>

<t>A delegation (5) object contains the public key used to generate signatures
on assertions in a named zone, and by which a delegation of a name within a
zone to a subordinate zone may be verified. It is represented as an N-element
array. The second element is a signature algorithm identifier as in 
<xref target="cbor-signature"/>. Additional elements are as defined in <xref target="cbor-signature"/> 
for the given algorithm identifier.</t>

<t>A nameset (6) object contains an expression defining which names are allowed
and which names are disallowed in a given zone. It is represented as an N-
element array, as defined in <xref target="cbor-nameset"/></t>

<t>A cert-info (7) object contains an expression binding a certificate or
certificate authority to a name, such that connections to the name must either
use the bound certificate or a certificate signed by a bound authority. It is
represented as an N-element array, as defined in <xref target="cbor-certinfo"/>.</t>

<t>A service-info (8) object gives information about a named service. Services
are named as in <xref target="RFC2782"/>. It is represented as a four-element array. The
second element is a fully-qualified name of a host providing the named service
as a UTF-8 string. The third element is a transport port number as a positive
integer in the range 0-65535. The fourth element is a priority as a positive
integer, with lower numbers having higher priority.</t>

<t>A registrar (9) object gives the name and other identifying information of
the registrar (the organization which caused the name to be added to the
namespace) for organization-level names. It is represented as a UTF-8 string
containing identifying information chosen by the registrar according to the
registry’s policy.</t>

<t>A registrant (10) object gives information about the registrant of an
organization-level name. It is represented as a UTF-8 string containing this
information, with a format chosen by the registrar according to the registry’s
policy.</t>

<t>An infrakey (11) object contains the public key used to generate signatures on
messages by a named RAINS server, by which a RAINS message signature may be
verified by a receiver. It is identical in structure to a delegation object,
as defined in <xref target="cbor-signature"/>.</t>

</section>
<section anchor="cbor-signature" title="Signatures, delegation keys, and RAINS infrastructure keys">

<t>RAINS supports multiple signature algorithms and hash functions for signing
assertions for cryptographic algorithm agility <xref target="RFC7696"/>. A RAINS signature
algorithm identifier specifies the signature algorithm; a hash function for
generating the HMAC; a method for generating, verifying, and interpreting hash
chain tokens in signatures; and the format of the encodings of the signature
values in Assertions, Shards, Zones, and Messages, as well as of public key
values in delegation objects.</t>

<t>RAINS signatures have four common elements: the algorithm identifier, a valid-
since timestamp, a valid-until timestamp, and a hash chain token. Signatures
are represented as an array of these four values followed by additional
elements containing the signature data itself, according to the algorithm
identifier.</t>

<t>Valid-since and valid-until timestamps are represented as CBOR integers
counting seconds since the UNIX epoch UTC, identified with tag value 1 and
encoded as in section 2.4.1 of <xref target="RFC7049"/>. A signature MUST have a valid-
until timestamp. If a signature has no specified valid-since time (i.e., is
valid from the beginning of time until its valid-until timestamp), the valid-
since time MAY be null (as in Table 2 in Section 2.3 of <xref target="RFC7049"/>).</t>

<t>Hash chain tokens and their use are specified in the appropriate subsection of
this section for the given algorithm identifier.</t>

<t>Signatures in RAINS are generated over a normalized serialized CBOR object (a
Message; or an Assertion, Shard, or Zone section body). To normalize and
serialize an object for sigining or verifying:</t>

<t><list style="symbols">
  <t>Remove all signatures from the object.</t>
  <t>Add a new “blank” signature to the object, containing Null in the place 
of any elements containing signature data.</t>
  <t>Serialize the object, emitting all keys in CBOR maps in ascending numerical
order. Note that when serializing anything with a Content array, the order 
of the content array is preserved. If the serialized object is a Message, 
it should be tagged with the RAINS tag.</t>
  <t>Generate a signature on the resulting byte stream according to the 
algorithm selected, and fill the resulting values into the “blank” 
signature; or verify the signature of the resulting byte stream according 
to the algorithm selected.</t>
</list></t>

<t>The following algorithms are supported:</t>

<texttable>
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Signatures</ttcol>
      <ttcol align='left'>Hash/HMAC</ttcol>
      <ttcol align='left'>Format</ttcol>
      <ttcol align='left'>Token</ttcol>
      <c>2</c>
      <c>ecdsa-256</c>
      <c>sha-256</c>
      <c>See <xref target="ecdsa-format"/></c>
      <c>See <xref target="hash-chain-rev"/></c>
      <c>3</c>
      <c>ecdsa-384</c>
      <c>sha-384</c>
      <c>See <xref target="ecdsa-format"/></c>
      <c>See <xref target="hash-chain-rev"/></c>
</texttable>

<section anchor="ecdsa-format" title="ECDSA signature and public key format">

<t>ECDSA public keys consist of a single value, called “Q” in <xref target="FIPS-186-3"/>. Q
is a simple bit string that represents the uncompressed form of a curve point,
concatenated together as “x | y”. The third element in a RAINS delegation
object is the Q bit string encoded as a CBOR byte array. RAINS delegation
objects for ECDSA-256 public keys are therefore represented as the array 
[5, 2, Q]; and for ECDSA-384 public keys as [5, 3, Q].</t>

<t>ECDSA signatures are a combination of two non-negative integers, called “r”
and “s” in <xref target="FIPS-186-3"/>. A Signature using ECDSA is represented using a six
element CBOR array, with the fifth element being r represented as a byte array
as described in Section C.2 of <xref target="FIPS-186-3"/>, and the sixth being s
represented as a byte array as described in Section C.2 of <xref target="FIPS-186-3"/>. For
ECDSA-256 signatures, each integer MUST be represented as a 32-byte array. For
ECDSA-384 signatures, each integer MUST be represented as a 48-byte array.
RAINS signatures using ECDSA-256 are therefore the array [2, valid-from,
valid-until, token, r, s]; and for ECDSA-384 the array [3, valid-from,
valid-until, token, r, s].</t>

<t>ECDSA-256 signatures and public keys use the P-256 curve as defined in <xref target="FIPS-186-3"/>.
ECDSA-384 signatures and public keys use the P-384 curve as defined in <xref target="FIPS-186-3"/>.</t>

<t>All RAINS servers MUST implement ECDSA-256 and ECDSA-384.</t>

</section>
<section anchor="hash-chain-rev" title="Hash-chain based revocation">

<t>Hash-chain based revocation allows a signature (and the Assertion, Shard, or
Zone it protects) to be replaced before it expires. To use hash-chain based
revocation, a signing entity generates a hash chain from a known seed using
the hash function specified by the signature algorithm in use, and places the
Nth value derived therefrom in the hash chain revocation token on a signature.</t>

<t>A revocation can be issued by generating a new section and signing it,
revealing the N-1st value from the hash chain in the revocation token. To
allow a recipient of a revoked section to verify the revocation, the following
restrictions on what can replace what apply:</t>

<t><list style="symbols">
  <t>An Assertion can only be replaced by another Assertion with the same 
Subject within the same Context and Zone, containing an Objects array 
of the same length containing the same types of Objects. To delete Object 
values, those values can be replaced with Null in the replacing Assertion.</t>
  <t>A Shard can only be replaced by another Shard with an identical shard-range 
key, within the same Context and Zone. Incomplete Shards cannot be replaced.</t>
  <t>A Zone can only be replaced by another Zone with an identical name within 
the same Context.</t>
</list></t>

<t>Signing entities can decline to use hash-chain based revocation by replacing
the revocation token with Null.</t>

</section>
</section>
<section anchor="cbor-certinfo" title="Certificate information format">

<t>[EDITOR’S NOTE: Not yet defined. Write me. This should be largely in line with
TLSA; determine if there’s any guidance from implementation experience we
should consider, as well.]</t>

</section>
<section anchor="cbor-nameset" title="Name expression format">

<t>[EDITOR’S NOTE: Not yet defined. Write me. For discussion within the INIP. 
The expression language is primarily intended to solve the same problem the
IDNA tables to – acceptable character sets and character set mixing –
although a general-purpose expression language that allows arbitrary matching
of whole names would be more flexible.]</t>

</section>
<section anchor="cbor-capabilities" title="Capabilities">

<t>When a RAINS server or client sends the first message in a stream to a peer, it MAY expose optional
capabilities to its peer using the capabilities (1) key. This key contains either:</t>

<t><list style="symbols">
  <t>an array of uniform resource names specifying capabilities supported by the
sending server, taken from the table below, with each name encoded as a
UTF-8 string.</t>
  <t>a SHA-256 hash of the CBOR byte stream derived from normalizing such an
array by sorting it in lexicographically increasing order, then serializing
it.</t>
</list></t>

<t>This mechanism is inspired by <xref target="XEP0115"/>, and is intended to be used to
reduce the overhead in exposing common sets of capabilities. Each RAINS server
can cache a set of recently-seen or common hashes, and only request the full
URN set (using notification code 399) on a cache miss.</t>

<t>The following URNs are presently defined; other URNs will specify future
optional features, support for alternate transport protocols and new signature
algorithms, etc.</t>

<texttable>
      <ttcol align='left'>URN</ttcol>
      <ttcol align='left'>Meaning</ttcol>
      <c>urn:x-rains:tlssrv</c>
      <c>Listens for connections on TLS over TCP from other RAINS servers.</c>
</texttable>

<t>Since there are only two defined capabilities at this time, RAINS servers can
be implemented with two hard-coded hashes to determine whether a peer is
listening or not. The hash presented by a server supporting urn:x-rains:tlssrv
is e5365a09be554ae55b855f15264dbc837b04f5831daeb321359e18cdabab5745; the hash
presented by a server supporting no capabilities is
76be8b528d0075f7aae98d6fa57a6d3c83ae480a8469e668d7b0af968995ac71.</t>

<t>A RAINS server MUST NOT assume that a peer server supports a given capability
unless it has received a message containing that capability from that server.
An exception are the capabilities indicating that a server listens for
connections using a given transport protocol; servers and clients can also
learn this information from RAINS itself (given a redirection assertion for a
named zone) or from external configuration values.</t>

</section>
</section>
<section anchor="protocol-def" title="RAINS Protocol Definition">

<t>As noted in <xref target="cbor"/>, RAINS is a message-exchange protocol that uses
CBOR <xref target="RFC7049"/> as its framing. Since CBOR is self-framing – a CBOR parser
can determine when a CBOR object is complete at the point at which it has read
its final byte – RAINS requires no external framing. It can therefore run
over any streaming, multistreaming, or message-oriented transport protocol. In
order to protect query confidentiality, and support rapid deployment over a
ubiquitously implemented transport, RAINS is defined in this document to run
over persistent TLS 1.2 connections <xref target="RFC5246"/> over TCP <xref target="RFC0793"/> with
mutual authentication. The TLS certificates of RAINS server peers can be
verified as specified in the certificate assertions for those servers.</t>

<t>RAINS servers MUST support this transport; future transports can be negotiated
using the capabilities mechanism after bootstrapping using TLS 1.2. As RAINS
is an experimental protocol, RAINS servers listen on port 1022 <xref target="RFC4727"/> for
connections from other RAINS servers and clients. RAINS servers should strive
to keep connections open to peer servers, unless it is clear that no future
messages will be exchanged with those peers, or in the face of resource
limitations at either peer. If a RAINS server needs to send a message to
another RAINS server to which it does not have an open connection, it attempts
to open a connection with that server.</t>

<t>This section describes the operation of the protocol as used among RAINS
servers. A simplified version of the protocol for client access is described
in <xref target="protocol-client"/>.</t>

<section anchor="protocol-processing" title="Message processing">

<t>Once a transport is established, any server may validly send a message with
any content to any other server. Upon receipt of a message, a server parses it, and:</t>

<t><list style="symbols">
  <t>notes the token on the message. If present, the token MUST be present on any
messages sent in reply to this message.</t>
  <t>processes any capabilities present, replacing the set of capabilities known
for the peer with the set present in the message. If the present
capabilities are represented by a hash that the server does not have in its
cache, it prepares a notification of type 399 “Capability hash not
understood” to send to its peer.</t>
  <t>splits the contents into its constituent message sections, processing them
independently.</t>
</list></t>

<t>On receipt of an assertion, shard, or zone message section, the server:</t>

<t><list style="symbols">
  <t>verifies its consistency (see <xref target="runtime-consistency-checking"/>). If the
section is not consistent, it prepares to send a notification of type 403
Inconsistent Message to the peer, and discards the section. Otherwise, it:</t>
  <t>determines whether it answers an outstanding query; if so, it prepares to
forward the section to the server that issued the query.</t>
  <t>determines whether it replaces any information presently in its cache (see
<xref target="hash-chain-rev"/>). If so, it discards the old information, and caches the
new section.</t>
  <t>determines whether it is likely to answer a future query, according to its 
configuration, policy, and query history; if so, it caches the section.</t>
</list></t>

<t>On receipt of a query, the server:</t>

<t><list style="symbols">
  <t>determines whether it has a stored assertion, shard, and/or zone message
section which answers the query. If so, it prepares to return the most
specific such section with the signature of the longest remaining validity to the
peer that issued the query. If not, it:</t>
  <t>checks to see whether the query specifies option 4 (cached answers only). If
so, and if option 5 (expired assertions acceptable) is also specified, it
then checks to see if it has any cached sections that answer the query on
which signatures are expired; otherwise, processing stops. If the query does
not specify option 4, delegation proceeds as follows:</t>
  <t>determines whether it has other non-authoritative servers it can forward the
query to, according to its configuration and policy, and in compliance with
any query options (see <xref target="cbor-query"/>). If so, it prepares to forward the
query to those servers, noting the reply for the received query depends on
the replies for the forwarded query. If not, it:</t>
  <t>determines the responsible authority servers for the zone containing the
query name in the query for contexts requested, and forwards the query to
those authority servers, noting the reply for the received query depends on
the reply for the forwarded query.</t>
</list></t>

<t>If query delegation fails to return an answer within a configured timeout for
a delegated query, the server prepares to send a 504 No assertion available
response to the peer from which it received the query.</t>

<t>When a server creates a new query to forward to another server in response to
a query it received, it SHOULD NOT use the same token on the delegated query
as on the received query, unless option 6 Enable Tracing is present in the
received , in which case it MUST use the same token. The Enable Tracing option
is designed to allow debugging of query processing across multiple servers,
and MUST NOT be enabled by default.</t>

<t>On receipt of a notification, the server’s behavior depends on the notification type:</t>

<t><list style="symbols">
  <t>For type 100 “Connection Heartbeat”, the server does nothing: these null
messages are used to keep long-lived connections open in the presence of
network behaviors that may drop state for idle connections.</t>
  <t>For type 399 “Capability hash not understood”, the server prepares to send a
full capabilities list on the next message it sends to the peer.</t>
  <t>For type 504 “No assertion available”, the server checks the token on the
message, and prepares to forward the assertion to the associated query.</t>
  <t>For type 413 “Message too large” the server notes that large messages may 
not be sent to a peer and tries again (see <xref target="protocol-limits"/>), or logs
the error along with the note-data content.</t>
  <t>For type 400 “Malformed message”, type 403 “Inconsistent message”, type 500
“Server error”, or type 501 “Server not capable”, the server logs the error
along with the note-data content, as these notifications generally represent
implementation or configuration error conditions which will require human
intervention to mitigate.</t>
</list></t>

<t>The first message a server sends to a peer after a new connection is
established SHOULD contain a capabilities section, if the server supports any
optional capabilities. See <xref target="cbor-capabilities"/>.</t>

<t>If the server is configured to keep long-running connections open, due to the
presence of network behaviors that may drop state for idle connections, it
SHOULD send a message containing a type 100 Connection Heartbeat notification
after a configured idle time without any messages containing other content
being sent.</t>

</section>
<section anchor="message-transmission" title="Message Transmission">

<t>As noted in <xref target="protocol-processing"/> many messages are sent in reply to messages
received from peers. Servers may also originate messages on their own, based
on their configuration and policy:</t>

<t><list style="symbols">
  <t>Proactive queries to retrieve assertions, shards, and zones for which all
signatures have expired or will soon expire, for cache management purposes.</t>
  <t>Proactive push of assertions, shards, and zones to other servers, based on
query history or other information indicating those servers may query for
the assertions they contain.</t>
</list></t>

</section>
<section anchor="protocol-limits" title="Message Limits">

<t>RAINS servers MUST accept messages up to 65536 bytes in length, but MAY accept
messages of greater length, subject to resource limitations of the server. A
server with resource limitations MUST respond to a message rejected due to
length restrictions with a notification of type 414 (Message Too Large). A
server that receives a type 413 notification must note that the peer sending
the message only accepts messages smaller than the largest message it’s
successfully sent that peer, or cap messages to that peer to 65536 bytes in
length.</t>

<t>Since a bare assertion with a single ECDSA signature requires on the order of
180 bytes, it is clear that many full zones won’t fit into a single minimum
maximum-size message. Authorities are therefore encouraged to publish zones
grouped into shards that will fit into 65536-byte messages, to allow servers
to reply using these shards when full-zone transfers are not possible due to
message size limitations.</t>

</section>
<section anchor="runtime-consistency-checking" title="Runtime consistency checking">

<t>The data model used by the RAINS protocol allows inconsistent information to
be asserted, all resulting from misconfigured or misbehaving authority
servers. For example, a shard valid at a given point in time can be marked
lexically complete, but not contain an assertion within its lexical range,
which is also valid at that point. This would allow both proof of the presence
and absence of an assertion at the same time, which is clearly nonsensical.</t>

<t>RAINS relies on runtime consistency checking to mitigate this problem: each
server receiving an assertion, shard, or zone SHOULD, subject to resource
constraints, ensure that it is consistent with other information it has, and
if not, discard all assertions, shards, and zones in its cache, log the error,
and send a 403 Inconsistent Message to the source of the message.</t>

</section>
<section anchor="integrity-and-confidentiality-protection" title="Integrity and Confidentiality Protection">

<t>Assertions are not valid unless they contain at least one signature that can
be verified from the chain of authorities specified by the name and context on
the assertion; integrity protection is built into the information model. The
infrastructure key object type allows keys to be associated with RAINS
servers in addition to zone authorities, which allows a client to
delegate integrity verification of assertions to a trusted query service (see
<xref target="protocol-client"/>).</t>

<t>Since the job of an Internet naming service is to provide publicly-available
information mapping names to information needed to connect to the services
they name, confidentiality protection for assertions is not a goal of the
system. Specifically, the information model and the mechanism for proving non-
existence of an assertion is not designed to provide resistance against zone
enumeration.</t>

<t>On the other hand, confidentiality protection of query information in crucial.
Linking naming queries to a specific user can be nearly as useful to build a
profile of that user for surveillance purposes as full access to the clear
text of that client’s communications <xref target="RFC7624"/>. In this revision, RAINS uses
TLS to protect communications between servers and between servers and clients,
with certificate information for RAINS infrastructure stored in RAINS itself.
Together with hop-by-hop confidentiality protection, query options, proactive
caching, default use of non-persistent tokens, and redirection among servers
can be used to mix queries and reduce the linkability of query information to
specific clients.</t>

</section>
</section>
<section anchor="protocol-client" title="RAINS Client Protocol">

<t>The protocol used by clients to issue queries to and receive responses from an
query service is a subset of the full RAINS protocol, with the following differences:</t>

<t><list style="symbols">
  <t>Clients only process assertion, shard, zone, and notification sections;
sending a query to a client results in a 400 Malformed Message notification.</t>
  <t>Clients never listen for connections; a client must initiate and maintain a
transport session to the query server(s) it uses for name resolution.</t>
  <t>Servers only process query and notification sections when connected to
clients; a client sending assertions to a server results in a 400 Malformed
Message notification.</t>
</list></t>

<t>Since signature verification is resource-intensive, clients delegate signature
verification to query servers by default. The query server signs the message
containing results for a query using its own key (published as an infrakey
object associated with the query server’s name), and a validity time corresponding
to the signature it verified with the longest lifetime, stripping other
signatures from the reply. This behavior can be disabled by a client by
specifying query option 7, allowing the client to do its own verification.</t>

</section>
<section anchor="deployment-considerations" title="Deployment Considerations">

<t>The following subsections discuss issues that must be considered in any
deployment of RAINS at scale.</t>

<section anchor="assertion-lifetime-management" title="Assertion lifetime management">

<t>An assertion can contain multiple signatures, each with a different lifetime.
Signature lifetimes are equivalent to a time to live in the present DNS:
authorities should compute a new signature for each validity period, and make
these new signatures available when old ones are expiring.</t>

<t>If an unexpected change to an assertion is necessary, the hash chain based
replacement mechanism described in <xref target="hash-chain-rev"/> provides a way for an
authority to replace signed assertions with new information or with Null
objects, in the case of deletion.</t>

<t>Since assertion lifetime management is based on a real-time clock expressed in
UTC, RAINS servers MUST use a clock synchronization protocol such as NTP <xref target="RFC5905"/>.</t>

</section>
<section anchor="secret-key-management" title="Secret Key Management">

<t>The secret keys associated with public keys for each RAINS server (via
infrakey objects) must be available on that server, whether through a hardware
or software security device, so they can sign messages on demand; this is
particularly important for query servers. In addition, the secret keys
associated with TLS certificates for each server (published via certinfo
objects) must be available as well in order to establish TLS sessions.</t>

<t>However, storing zone secret keys (associated via delegation objects) on RAINS
servers would represent a more serious operational risk. To keep this from
being necessary, authority servers have an additional signer interface, from
which they will accept and cache any assertion, shard, or zone for which they
are authority servers until at least the end of validity of the last
signature, provided the signature is verifiable.</t>

</section>
<section anchor="query-service-discovery" title="Query Service Discovery">

<t>A client that will not do its own verification must be able to discover the
oracle server(s) it should trust for resolution. Integration with e.g. DHCP or
selection of a local multicast discovery method are left to a future revision
of this document.</t>

<t>In any case, clients MUST provide a configuration interface to allow a user to
specify (by address or name) and/or constrain (by certificate property) a
preferred/trusted oracle. This would allow client on an untrusted network to
use an untrusted locally-available oracle to discover a preferred oracle
(doing key verification on its own for bootstrapping), before connecting to
that oracle for normal name resolution.</t>

</section>
<section anchor="transition-using-translation-between-rains-and-dns-information-models" title="Transition using translation between RAINS and DNS information models">

<t>Full adoption of RAINS would require changes to every client device (replacing
DNS stub resolvers with RAINS clients) and name server on the Internet. In
addition, most client software would need to change, as well, to get the full
benefits of explicit context in name resolution. This is a wholly unrealistic goal.</t>

<t>RAINS servers can, however, coexist with Domain Name System servers and
clients during an indefinite transition period. RAINS assertions can be
algorithmically translated into DNS answers, and RAINS queries can be
algorithmically translated into DNS queries, by RAINS to DNS gateways, given
the mostly compatible information models used by the two.</t>

<t>While DNSSEC and RAINS keys for equivalent ciphersuites are compatible with
each other, there is no equivalent to query option 7 for gateways, since the
RAINS signatures are generated over the RAINS bytestream for an assertion, not
the DNS bytestream. Therefore, RAINS to DNS gateways must provide verification
services for DNS clients. DNS over TLS <xref target="RFC7858"/> SHOULD be used between the
DNS client and gateway to ensure confidentiality and integrity for queries and
answers.</t>

<t>Object type mappings are as follows:</t>

<t><list style="symbols">
  <t>Objects of type name can (largely) be represented as CNAME RRs.</t>
  <t>Objects of type ip6-addr can be represented as AAAA RRs.</t>
  <t>Objects of type ip4-addr can be represented as A RRs.</t>
  <t>Objects of type redirection can be represented as NS RRs.</t>
  <t>Objects of type cert-info can be represented as TLSA RRs</t>
  <t>Objects of type service-info can be represented as SRV RRs.</t>
</list></t>

<t>There are a few object types without mappings:</t>

<t><list style="symbols">
  <t>Objects of type delegation can be represented as DS RRs, and signatures as
RRSIG RRs, but since these keys are verified by the gateway, there is no need
to represent this information to the client.</t>
  <t>Objects of type infrakey cannot be represented in DNS, but are irrelevant for
DNS translation of RAINS messages, since DNS does not support server signing
of responses.</t>
  <t>Objects of type registrar and registrant cannot be represented in DNS; clients
can use WHOIS instead. In addition, RRTYPEs could be added for them in the
future if RAINS sees significant deployment with DNS as a front-end protocol.</t>
  <t>Objects of type nameset cannot be represented in DNS; the current equivalent
are the IDNA parameters maintained by IANA (for the DNS root zone only) at
https://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml.</t>
</list></t>

<t>When translating a DNS query from a client to a RAINS query for that client,
client options can be set on a per-server, per-client, or per-query basis
using some out of band configuration options.</t>

<t>When translating a RAINS assertion to a DNS answer, the gateway can use the
time to expiry for the verified signature as the TTL.</t>

<t>There is no method for exposing context information in a DNS query or answer.
Therefore, queries and answers at a RAINS gateway are only supported for the
global context “.”.</t>

</section>
</section>
<section anchor="experimental-design-and-evaluation" title="Experimental Design and Evaluation">

<t>The protocol described in this document is intended primarily as a prototype
for discussion, though the goal of the document is to specify RAINS completely
enough to allow independent, interoperable implementation of clients an
servers. The massive inertia behind the deployment of the present domain name
system makes full deployment as a replacement for DNS unlikely. Despite this,
there are some criteria by which the success of the RAINS experiment may be
judged:</t>

<t>First, deployment in simulated or closed networks, or in alternate Internet
architectures such as SCION, allows implementation experience with the
features of RAINS which DNS lacks (signatures as a first-order delegation
primitive, support for explicit contexts, explicit tradeoffs in queries,
runtime availability of registrar/registrant data, and nameset support),
which in turn may inform the specification and deployment of these features
on the present DNS.</t>

<t>Second, deployment of RAINS “islands” in the present Internet alongside DNS on
a per-domain basis would allow for comparison between operational and
implementation complexity and efficiency and benefits derived from RAINS’
features, as information for future development of the DNS protocol.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>The present revision of this document has no actions for IANA.</t>

<t>The authors have registered the CBOR tag 15309736 to identify RAINS messages
in the CBOR tag registry at 
https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml.</t>

<t>RAINS servers currently listen for connections from other servers on Port
1022. Future revisions of this document may specify a different port,
registered with IANA via Expert Review <xref target="RFC5226"/>.</t>

<t>The symbol table in this document in <xref target="cbor-symtab"/>, the notification code
table in <xref target="cbor-notification"/>, and the signature algorithm table in 
<xref target="cbor-signature"/> may be candidates for IANA registries in future revisions 
of this document.</t>

<t>The urn:x-rains namespace used by the RAINS capability mechanism in {{cbor-
capabilities}} may be a candidate for replacement with an IANA-registered
namespace in a future revision of this document.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>This document specifies a new, experimental protocol for Internet name
resolution, with mandatory integrity protection for assertions about names
built into the information model, and confidentiality for query information
protected on a hop-by-hop basis. See especially <xref target="signatures-in-assertions"/>,
<xref target="integrity-and-confidentiality-protection"/>, <xref target="cbor-signature"/>, 
<xref target="cbor-certinfo"/>, and <xref target="secret-key-management"/> for security-relevant 
details.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>Thanks to Daniele Asoni, Laurent Chuat, Ted Hardie, Joe Hildebrand, Steve
Matsumoto, Adrian Perrig, Raphael Reischuk, Stephen Shirley, Andrew Sullivan,
and Suzanne Woolf for the discussions leading to the design of this protocol.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='I-D.trammell-inip-pins'>
<front>
<title>Properties of an Ideal Naming Service</title>

<author initials='B' surname='Trammell' fullname='Brian Trammell'>
    <organization />
</author>

<date month='September' day='6' year='2016' />

<abstract><t>This document specifies a set of necessary functions and desirable properties of an ideal system for resolving names to addresses and associated information for establishing communication associations in the Internet.  For each property, it briefly explains the rationale behind it, and how the property is or could be met with the present Domain Name System.  It is intended to start a discussion within the IAB's Names and Identifiers program about gaps between the present reality of DNS and the naming service the Internet needs by returning to first principles.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-trammell-inip-pins-02' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-trammell-inip-pins-02.txt' />
</reference>



<reference  anchor='RFC0793' target='http://www.rfc-editor.org/info/rfc793'>
<front>
<title>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='J. Postel'><organization /></author>
<date year='1981' month='September' />
</front>
<seriesInfo name='STD' value='7'/>
<seriesInfo name='RFC' value='793'/>
<seriesInfo name='DOI' value='10.17487/RFC0793'/>
</reference>



<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor='RFC2782' target='http://www.rfc-editor.org/info/rfc2782'>
<front>
<title>A DNS RR for specifying the location of services (DNS SRV)</title>
<author initials='A.' surname='Gulbrandsen' fullname='A. Gulbrandsen'><organization /></author>
<author initials='P.' surname='Vixie' fullname='P. Vixie'><organization /></author>
<author initials='L.' surname='Esibov' fullname='L. Esibov'><organization /></author>
<date year='2000' month='February' />
<abstract><t>This document describes a DNS RR which specifies the location of the server(s) for a specific protocol and domain.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='2782'/>
<seriesInfo name='DOI' value='10.17487/RFC2782'/>
</reference>



<reference  anchor='RFC3629' target='http://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor='RFC4727' target='http://www.rfc-editor.org/info/rfc4727'>
<front>
<title>Experimental Values In IPv4, IPv6, ICMPv4, ICMPv6, UDP, and TCP Headers</title>
<author initials='B.' surname='Fenner' fullname='B. Fenner'><organization /></author>
<date year='2006' month='November' />
<abstract><t>When experimenting with or extending protocols, it is often necessary to use some sort of protocol number or constant in order to actually test or experiment with the new function, even when testing in a closed environment.  This document reserves some ranges of numbers for experimentation purposes in specific protocols where the need to support experimentation has been identified, and it describes the numbers that have already been reserved by other documents.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4727'/>
<seriesInfo name='DOI' value='10.17487/RFC4727'/>
</reference>



<reference  anchor='RFC5246' target='http://www.rfc-editor.org/info/rfc5246'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2008' month='August' />
<abstract><t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5246'/>
<seriesInfo name='DOI' value='10.17487/RFC5246'/>
</reference>



<reference  anchor='RFC7049' target='http://www.rfc-editor.org/info/rfc7049'>
<front>
<title>Concise Binary Object Representation (CBOR)</title>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<date year='2013' month='October' />
<abstract><t>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.  These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t></abstract>
</front>
<seriesInfo name='RFC' value='7049'/>
<seriesInfo name='DOI' value='10.17487/RFC7049'/>
</reference>


<reference anchor="FIPS-186-3" >
  <front>
    <title>Digital Signature Standard FIPS 186-3</title>
    <author initials="." surname="NIST">
      <organization></organization>
    </author>
    <date year="2009" month="June"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>





<reference  anchor='RFC1035' target='http://www.rfc-editor.org/info/rfc1035'>
<front>
<title>Domain names - implementation and specification</title>
<author initials='P.V.' surname='Mockapetris' fullname='P.V. Mockapetris'><organization /></author>
<date year='1987' month='November' />
<abstract><t>This RFC is the revised specification of the protocol and format used in the implementation of the Domain Name System.  It obsoletes RFC-883. This memo documents the details of the domain name client - server communication.</t></abstract>
</front>
<seriesInfo name='STD' value='13'/>
<seriesInfo name='RFC' value='1035'/>
<seriesInfo name='DOI' value='10.17487/RFC1035'/>
</reference>



<reference  anchor='RFC5226' target='http://www.rfc-editor.org/info/rfc5226'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'><organization /></author>
<date year='2008' month='May' />
<abstract><t>Many protocols make use of identifiers consisting of constants and other well-known values.  Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec).  To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority.  For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).</t><t>In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made.  If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role.  This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.</t><t>This document obsoletes RFC 2434.  This document specifies an Internet Best  Current Practices for the Internet Community, and requests discussion and  suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='26'/>
<seriesInfo name='RFC' value='5226'/>
<seriesInfo name='DOI' value='10.17487/RFC5226'/>
</reference>



<reference  anchor='RFC5905' target='http://www.rfc-editor.org/info/rfc5905'>
<front>
<title>Network Time Protocol Version 4: Protocol and Algorithms Specification</title>
<author initials='D.' surname='Mills' fullname='D. Mills'><organization /></author>
<author initials='J.' surname='Martin' fullname='J. Martin' role='editor'><organization /></author>
<author initials='J.' surname='Burbank' fullname='J. Burbank'><organization /></author>
<author initials='W.' surname='Kasch' fullname='W. Kasch'><organization /></author>
<date year='2010' month='June' />
<abstract><t>The Network Time Protocol (NTP) is widely used to synchronize computer clocks in the Internet.  This document describes NTP version 4 (NTPv4), which is backwards compatible with NTP version 3 (NTPv3), described in RFC 1305, as well as previous versions of the protocol. NTPv4 includes a modified protocol header to accommodate the Internet Protocol version 6 address family.  NTPv4 includes fundamental improvements in the mitigation and discipline algorithms that extend the potential accuracy to the tens of microseconds with modern workstations and fast LANs.  It includes a dynamic server discovery scheme, so that in many cases, specific server configuration is not required.  It corrects certain errors in the NTPv3 design and implementation and includes an optional extension mechanism.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5905'/>
<seriesInfo name='DOI' value='10.17487/RFC5905'/>
</reference>



<reference  anchor='RFC6605' target='http://www.rfc-editor.org/info/rfc6605'>
<front>
<title>Elliptic Curve Digital Signature Algorithm (DSA) for DNSSEC</title>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<author initials='W.C.A.' surname='Wijngaards' fullname='W.C.A. Wijngaards'><organization /></author>
<date year='2012' month='April' />
<abstract><t>This document describes how to specify Elliptic Curve Digital Signature Algorithm (DSA) keys and signatures in DNS Security (DNSSEC).  It lists curves of different sizes and uses the SHA-2 family of hashes for signatures.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6605'/>
<seriesInfo name='DOI' value='10.17487/RFC6605'/>
</reference>



<reference  anchor='RFC7231' target='http://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor='RFC7624' target='http://www.rfc-editor.org/info/rfc7624'>
<front>
<title>Confidentiality in the Face of Pervasive Surveillance: A Threat Model and Problem Statement</title>
<author initials='R.' surname='Barnes' fullname='R. Barnes'><organization /></author>
<author initials='B.' surname='Schneier' fullname='B. Schneier'><organization /></author>
<author initials='C.' surname='Jennings' fullname='C. Jennings'><organization /></author>
<author initials='T.' surname='Hardie' fullname='T. Hardie'><organization /></author>
<author initials='B.' surname='Trammell' fullname='B. Trammell'><organization /></author>
<author initials='C.' surname='Huitema' fullname='C. Huitema'><organization /></author>
<author initials='D.' surname='Borkmann' fullname='D. Borkmann'><organization /></author>
<date year='2015' month='August' />
<abstract><t>Since the initial revelations of pervasive surveillance in 2013, several classes of attacks on Internet communications have been discovered.  In this document, we develop a threat model that describes these attacks on Internet confidentiality.  We assume an attacker that is interested in undetected, indiscriminate eavesdropping.  The threat model is based on published, verified attacks.</t></abstract>
</front>
<seriesInfo name='RFC' value='7624'/>
<seriesInfo name='DOI' value='10.17487/RFC7624'/>
</reference>



<reference  anchor='RFC7696' target='http://www.rfc-editor.org/info/rfc7696'>
<front>
<title>Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms</title>
<author initials='R.' surname='Housley' fullname='R. Housley'><organization /></author>
<date year='2015' month='November' />
<abstract><t>Many IETF protocols use cryptographic algorithms to provide confidentiality, integrity, authentication, or digital signature.  Communicating peers must support a common set of cryptographic algorithms for these mechanisms to work properly.  This memo provides guidelines to ensure that protocols have the ability to migrate from one mandatory-to-implement algorithm suite to another over time.</t></abstract>
</front>
<seriesInfo name='BCP' value='201'/>
<seriesInfo name='RFC' value='7696'/>
<seriesInfo name='DOI' value='10.17487/RFC7696'/>
</reference>



<reference  anchor='RFC7858' target='http://www.rfc-editor.org/info/rfc7858'>
<front>
<title>Specification for DNS over Transport Layer Security (TLS)</title>
<author initials='Z.' surname='Hu' fullname='Z. Hu'><organization /></author>
<author initials='L.' surname='Zhu' fullname='L. Zhu'><organization /></author>
<author initials='J.' surname='Heidemann' fullname='J. Heidemann'><organization /></author>
<author initials='A.' surname='Mankin' fullname='A. Mankin'><organization /></author>
<author initials='D.' surname='Wessels' fullname='D. Wessels'><organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<date year='2016' month='May' />
<abstract><t>This document describes the use of Transport Layer Security (TLS) to provide privacy for DNS.  Encryption provided by TLS eliminates opportunities for eavesdropping and on-path tampering with DNS queries in the network, such as discussed in RFC 7626.  In addition, this document specifies two usage profiles for DNS over TLS and provides advice on performance considerations to minimize overhead from using TCP and TLS with DNS.</t><t>This document focuses on securing stub-to-recursive traffic, as per the charter of the DPRIVE Working Group.  It does not prevent future applications of the protocol to recursive-to-authoritative traffic.</t></abstract>
</front>
<seriesInfo name='RFC' value='7858'/>
<seriesInfo name='DOI' value='10.17487/RFC7858'/>
</reference>



<reference  anchor='RFC7871' target='http://www.rfc-editor.org/info/rfc7871'>
<front>
<title>Client Subnet in DNS Queries</title>
<author initials='C.' surname='Contavalli' fullname='C. Contavalli'><organization /></author>
<author initials='W.' surname='van der Gaast' fullname='W. van der Gaast'><organization /></author>
<author initials='D.' surname='Lawrence' fullname='D. Lawrence'><organization /></author>
<author initials='W.' surname='Kumari' fullname='W. Kumari'><organization /></author>
<date year='2016' month='May' />
<abstract><t>This document describes an Extension Mechanisms for DNS (EDNS0) option that is in active use to carry information about the network that originated a DNS query and the network for which the subsequent response can be cached.  Since it has some known operational and privacy shortcomings, a revision will be worked through the IETF for improvement.</t></abstract>
</front>
<seriesInfo name='RFC' value='7871'/>
<seriesInfo name='DOI' value='10.17487/RFC7871'/>
</reference>


<reference anchor="XEP0115" >
  <front>
    <title>XEP-0115 Entity Capababilities</title>
    <author initials="J." surname="Hildebrand">
      <organization></organization>
    </author>
    <author initials="P." surname="Saint-Andre">
      <organization></organization>
    </author>
    <author initials="R." surname="Troncon">
      <organization></organization>
    </author>
    <author initials="J." surname="Konieczny">
      <organization></organization>
    </author>
    <date year="2008" month="February" day="26"/>
  </front>
</reference>
<reference anchor="SCION" >
  <front>
    <title>SCION Five Years Later - Revisiting Scalability, Control, and Isolation Next-Generation Networks (arXiv:1508.01651v1)</title>
    <author initials="D." surname="Barrera">
      <organization></organization>
    </author>
    <author initials="R." surname="Reischuk">
      <organization></organization>
    </author>
    <author initials="P." surname="Szalachowski">
      <organization></organization>
    </author>
    <author initials="A." surname="Perrig">
      <organization></organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="PARSER-BUGS" >
  <front>
    <title>The Bugs We Have To Kill (USENIX login)</title>
    <author initials="S." surname="Bratus">
      <organization></organization>
    </author>
    <author initials="M." surname="Patterson">
      <organization></organization>
    </author>
    <author initials="A." surname="Shubina">
      <organization></organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>


    </references>


<section anchor="open-issues" title="Open Issues">

<t><list style="symbols">
  <t>The format of the nameset and certinfo object types needs to be specified.</t>
  <t>A method for clients to discover local oracles needs to be specified.</t>
</list></t>

</section>


  </back>
</rfc>

