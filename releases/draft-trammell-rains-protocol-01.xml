<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-trammell-rains-protocol-01" category="exp">

  <front>
    <title abbrev="RAINS">RAINS (Another Internet Naming Service) Protocol Specification</title>

    <author initials="B." surname="Trammell" fullname="Brian Trammell">
      <organization>ETH Zurich NetSec</organization>
      <address>
        <postal>
          <street>Universitaetstrasse 6</street>
          <city>Zurich</city>
          <code>8092</code>
          <country>Switzerland</country>
        </postal>
        <email>ietf@trammell.ch</email>
      </address>
    </author>

    <date year="2016" month="November" day="23"/>

    <area>Internet Architecture Board</area>
    <workgroup>Names and Identifiers Program</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This document defines an alternate protocol for Internet name resolution,
designed as a prototype to facilitate conversation about the evolution or
replacement of the Domain Name System protocol. It attempts to answer the
question: “how would we design DNS knowing what we do now,” on the
background of the properties of an ideal naming service described in 
<xref target="I-D.trammell-inip-pins"/>.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>This document defines an experimental protocol for providing Internet name
resolution services, as a replacement for DNS, called RAINS (RAINS, Another
Internet Naming Service). It is designed as a prototype to facilitate
conversation about the evolution or replacement of the Domain Name System
protocol, and was developed as a name resolution system for the SCION
(“Scalability, Control, and Isolation on Next-Generation Networks”) future
Internet architecture <xref target="SCION"/>. It attempts to answer the
question: “how would we design the DNS knowing what we do now,” on the
background of the properties of an ideal naming service described in 
<xref target="I-D.trammell-inip-pins"/>.</t>

<t>Its architecture (<xref target="architecture"/>) and information model 
(<xref target="information-model"/>) are largely compatible with the existing 
Domain Name System. However, it does take several radical departures 
from DNS as presently defined and implemented:</t>

<t><list style="symbols">
  <t>Delegation from a superordinate zone to a subordinate zone is done solely
with cryptography: a superordinate defines the key(s) that are valid for
signing assertions in the subordinate during a particular time interval.
Assertions about names can therefore safely be served from any infrastructure.</t>
  <t>All time references in RAINS are absolute: instead of a time to live, each
assertion’s temporal validity is defined by the temporal validity of the
signature(s) on it.</t>
  <t>All assertions have validity within a specific context. A context determines
the rules for chaining signatures to verify validity of an assertion. The
global context is a special case of context, which uses chains from the
global naming root key. The use of context explicitly separates global usage
of the DNS from local usage thereof, and allows other application-specific
naming constraints to be bound to names; see <xref target="context-in-assertions"/>.
Queries are valid in one or more contexts, with specific rules for
determining which assertions answer which queries; see 
<xref target="context-in-queries"/>.</t>
  <t>There is an explicit separation between registrant-level names and
sub-registrant-level names, and explicit information about registrars and
registrants available in the naming system at runtime.</t>
  <t>Sets of valid characters and rules for valid names are defined on a per-zone
basis, and can be verified at runtime.</t>
  <t>Reverse lookups are done using a completely separate tree, supporting
delegations of any prefix length, in accordance with CIDR <xref target="RFC4632"/> and
the IPv6 addressing architecture <xref target="RFC4291"/>.</t>
</list></t>

<t>Instead of using a custom binary framing as DNS, RAINS uses Concise Binary
Object Representation <xref target="RFC7049"/>, partially in an effort to make
implementations easier to verify and less likely to contain potentially
dangerous parser bugs <xref target="PARSER-BUGS"/>. Like DNS, CBOR messages can be carried
atop any number of substrate protocols; RAINS is presently defined to use TLS
over persistent TCP connections (see <xref target="protocol-def"/>).</t>

</section>
<section anchor="terminology" title="Terminology">

<t>The terms MUST, MUST NOT, SHOULD, SHOULD NOT, and MAY, when they appear in
all-capitals, are to be interpreted as defined in <xref target="RFC2119"/>.</t>

<t>In addition, the following terms are used in this document as defined:</t>

<t><list style="symbols">
  <t>Authority: An entity which may make assertions about names in a zone, by virtue of holding a secret key which can generate signatures verifiable using a public key associated with a delegation to the zone.</t>
  <t>Assertion: A mapping between a name and object(s) of specified types describing the name, signed by an authority for the zone containing the subject name. See <xref target="assertion"/>.</t>
  <t>Subject: The name to which an assertion pertains.</t>
  <t>Object: A type/value pair of information about a name within an assertion.</t>
  <t>Query: An expression of interest in certain types of objects pertaining to a subject name in one or more contexts. See <xref target="query"/>.</t>
  <t>Context: Additional information about the scope in which an assertion or query is valid. See <xref target="context-in-assertions"/> and <xref target="context-in-queries"/>.</t>
  <t>Shard: A group of assertions common to a zone, with common signatures, which may be lexicographically complete for purposes of proving nonexistence of an assertion. See <xref target="shards-and-zones"/>.</t>
  <t>Zone: A group of all assertions valid at a given point in time, with common signatures, for a given level of delegation and context within the namespace. See <xref target="shards-and-zones"/>.</t>
  <t>RAINS Message: Unit of exchange in the RAINS protocol, containing assertions, shards, zones, queries, and notifications. See <xref target="cbor-message"/>.</t>
  <t>Notification: A RAINS-internal message section carrying information about the operation of the protocol itself. See <xref target="cbor-notification"/>.</t>
  <t>Authority Service: A service provided by a RAINS Server for publishing assertions by an authority. See <xref target="architecture"/>.</t>
  <t>Query Service: A service provided by a RAINS Server for answering queries on behalf of a RAINS Client. See <xref target="architecture"/>.</t>
  <t>Intermediary Service: A service provided by a RAINS Server for answering queries and providing temporary storage for assertions on behalf of other RAINS Servers. See <xref target="architecture"/>.</t>
  <t>RAINS Server: A server that speaks the RAINS Protocol, and provides on or more services on behalf of other RAINS Servers and/or RAINS Clients. See <xref target="architecture"/>.</t>
  <t>RAINS Client: A client that uses the Query Service of one or more RAINS Servers to retrieve assertions on behalf of applications that wish to connect to named services in the Internet.</t>
</list></t>

</section>
<section anchor="architecture" title="Architecture">

<t>The RAINS architecture is simple, and resembles the architecture of DNS. A
RAINS Server is an entity that provides transient and/or permanent storage for
assertions about names, and a lookup function that finds assertions for a
given query about a name, either by searching local storage or by delegating
to another RAINS server. RAINS servers can take on any or all of three roles:</t>

<t><list style="symbols">
  <t>authority service, acting on behalf of an authority to ensure properly
signed assertions are made available to the system (equivalent to an
authoritative server in DNS);</t>
  <t>query service, acting on behalf of a client to answer queries with relevant
assertions (equivalent to a recursive resolver in DNS), and to validate
assertions on the client’s behalf; and/or</t>
  <t>intermediary service, acting on behalf of neither but providing storage and
lookup for assertions with certain properties for query and authority
servers (partially replacing, but not really equivalent to, caching
resolvers in DNS).</t>
</list></t>

<t>RAINS Servers use the RAINS Protocol defined in this document to exchange
queries and assertions. RAINS Clients use a subset variant of the RAINS Protocol
(called the RAINS Client Protocol) to interact with RAINS Servers providing
query services on their behalf.</t>

</section>
<section anchor="information-model" title="Information Model">

<t>Messages in the RAINS Protocol are made up of two kinds of elements: Assertion
and Query.</t>

<t>The information model in this section omits information elements required by
the resolution mechanism itself; these are defined in more detail in 
<xref target="cbor"/> and <xref target="protocol-def"/>.</t>

<section anchor="assertion" title="Assertion">

<t>An Assertion is a signed statement about a mapping from a subject name to an
object value, and consists of the following elements:</t>

<t><list style="symbols">
  <t>Context: name of the context in which the assertion is valid;
see <xref target="context-in-assertions"/> below.</t>
  <t>Subject: name about which the assertion is made.</t>
  <t>Zone: name of the zone in which the assertion is made. The fully qualified
name of the subject is made by appending the zone name to the subject name
with a domain name separator (‘.’).</t>
  <t>Type: the type of information about the Subject contained in the 
assertion. Each Assertion is about a single type of data.</t>
  <t>Object: the data of the indicated type associated with the Subject</t>
  <t>Signatures: one or more signatures generated by the authority for the
Assertion. Signatures contain a time interval during which they are considered
valid, and may contain a revocation token allowing them to be revoked before
the end of the time interval. See <xref target="signatures-in-assertions"/> below.</t>
</list></t>

<t>The Types supported for each assertion are:</t>

<t><list style="symbols">
  <t>Delegation: the authority associated with the zone identified by the name
(roughly equivalent to the DNSSEC DS RRTYPE). The Object contains a public
key by which the authority can be identified.</t>
  <t>Redirection: The name(s) of one or more a RAINS servers providing authority
service for the authority associated with the zone (roughly equivalent to
the DNSSEC NS RRTYPE, but not always consulted directly during resolution).
The Object contains a set of names.</t>
  <t>Address: one or more addresses associated with the name (replaces DNS A and
AAAA RTYPEs). The Object contains a set of Addresses. An Address is an 
{address-family, value} tuple.</t>
  <t>Service-Info: one or more layer 4 ports and hostnames associated with a
service name (replaces DNS SRV RRTYPE). The object contains a {hostname,
port-number, priority tuple}.</t>
  <t>Name: one or more names associated with the name (roughly equivalent to DNS
CNAME). The Object contains a set of names.</t>
  <t>Certificate: a certificate which must appear at a specified location in the
certificate chain presented on a connection attempt with the named entity
(roughly equivalent to DNS TLSA). The details of this type will be described 
in a separate document.</t>
  <t>Zone-Nameset: an expression of the set of names allowed within a zone; e.g.
Unicode scripts or codepages in which names in the zone may be issued. This
allows a zone to set policy on names in support of the distinguishability
property in <xref target="I-D.trammell-inip-pins"/> that can be checked by RAINS 
servers at runtime. An assertion about a Subject within a Zone whose
name is not allowed by a valid signed Zone-Nameset expression is taken to be
invalid, even if it has a valid signature. The details of this type will be
described in a separate document.</t>
  <t>Zone-Registrar: Information about the organization that caused a Subject name 
to exist, for registrant-level names.</t>
  <t>Zone-Registrant: Information about the organization responsible for a 
Subject name, for registrant-level names.</t>
</list></t>

<t>For a given {subject, type} tuple, multiple assertions can be valid at a given
point in time; the union of the object values of all of these assertions is
considered to be the set of valid values at that point in time.</t>

<section anchor="context-in-assertions" title="Context in Assertions">

<t>Assertion contexts are used to determine the validity of the signature by the
declared authority as follows:</t>

<t><list style="symbols">
  <t>The global context is identified by the special context name `.’. Assertions
in the global context are signed by the authority for the subject name. For
example, assertions about the name simplon.inf.ethz.ch in the global context
are only valid if signed by the relevant authority inf.ethz.ch.</t>
  <t>A local context is associated with a given authority. The authority-part and
the context-part of a local context name are divided by a context marker 
(‘cx–’). The authority-part directly identifies the authority whose key was
used to sign the assertion; assertions within a local context are only valid
if signed by the identified authority. Authorities have complete control
over how the contexts under their namespaces are arranged, and over the names 
within those contexts.</t>
</list></t>

<t>Assertion context is the mechanism by which RAINS provides explicit
inconsistency (see section 5.3.2 of <xref target="I-D.trammell-inip-pins"/>). Some
examples illustrate how context works:</t>

<t><list style="symbols">
  <t>For the common split-DNS case, an enterprise could place names for machines
on its local networks within a separate context. E.g., a workstation could
be named simplon.cab.inf.ethz.ch within the context 
staff-workstations.cx–.inf.ethz.ch. Assertions about this name would 
be signed by the authority
for inf.ethz.ch. Here, the context serves simply as a marker, without enabling
an alternate signature chain: note that the name simplon.cab.inf.ethz.ch can
be validly signed by the authority for inf.ethz.ch if no delegation exists
for cab.inf.ethz.ch. The context simply marks this assertion as internal. This
allows a client making requests of local names to know they are local, and
for local resolvers to manage visibility of assertions outside the
enterprise: explicit context makes accidental leakage of both queries and
assertions easier to detect and avoid.</t>
  <t>Contexts make captive-portal interactions more explicit: a captive portal 
resolver could respond to a query for a common website (e.g. www.google.ch)
with a signed response directed at the captive portal, but within a context
identifying the location as well as the ISP (e.g. 
sihlquai.zurich.ch.cx–.starbucks.access.some-isp.net.). This response will
be signed by the authority for starbucks.access.some-isp.net. This
signature achieves two things: first, the client knows the result for
www.google.ch is not globally valid; second, it can present the user with
some indication as to the identity of the captive portal it is connected to.</t>
</list></t>

<t>Further examples showing how context can be used in queries as well are given
in <xref target="context-in-queries"/> below.</t>

<t>Developing conventions for assertion contexts for different situations will
require implementation and deployment experience, and is a subject for future
work.</t>

</section>
<section anchor="signatures-in-assertions" title="Signatures in Assertions">

<t>A signature over an assertion contains the following information elements:</t>

<t><list style="symbols">
  <t>Algorithm: identifier of the algorithm used to generate the signature.</t>
  <t>Valid-Since: a timestamp of the start of validity of this signature.</t>
  <t>Valid-Until: a timestamp of the end of validity of this signature.</t>
  <t>Signature: the cryptographic signature itself, whose format is determined by
the algorithm used.</t>
  <t>Revocation-Token: an optional revocation token for this signature, which 
allows a signature to be replaced or removed before the end of its validity.
Revocation tokens are generally based on hash chains, meaning that a
signature with a revocation token “down” the chain from a given token
supercedes it. The format and mechanism used by the revocation token is
determined by the alogrithm used. (Note that revocation is a presently 
unspecified feature in the protocol; see <xref target="hash-chain-rev"/>.)</t>
</list></t>

<t>The signature protects all the information in an assertion as well as its own
valid-since and valid-until values and the revocation token; it does not
protect other signatures on the assertion.</t>

</section>
<section anchor="shards-and-zones" title="Shards and Zones">

<t>Assertions may also be grouped and signed as a group. A shard is a set of
assertions subject to the same authority within the same context, protected by
one or more signatures over all assertions within the shard. A shard may have
an additional property that given a subject and an authenticated shard, it can
be shown that either an assertion with a given name and type exists within the
shard or does not exist at all.</t>

<t>A shard has the following information elements:</t>

<t><list style="symbols">
  <t>Context: name of the context in which the assertions in the shard are valid;
see <xref target="context-in-assertions"/> above.</t>
  <t>Zone: name of the zone in which the assertions are made.</t>
  <t>Content: a set of assertions sharing the context and zone.</t>
  <t>Signatures: one or more signatures generated by the authority for the
shard; see <xref target="signatures-in-assertions"/>.</t>
  <t>Complete-Flag: if true, the shard is lexicographically complete, and subject
names that sort such that they would be within the shard if they existed,
but are not in the shard, can be assumed not to exist.</t>
</list></t>

<t>For efficiency’s sake, information elements within a shard common to all
assertions (zone, context, signature) within the shard may be omitted from the
assertions themselves.</t>

<t>A zone is the entire set of shards subject to a given
authority within a given context. There are three kinds of zones;
treating these zones differently may allow lookup protocol
optimizations:</t>

<t><list style="symbols">
  <t>Zones containing only delegation assertions are delegation-only zones.
Delegation-only zones are not relevant as part of an assertion lookup, other
than for discovering and verifying authority. Top-level domains are
generally delegation-only.</t>
  <t>Zones containing no delegation assertions are final zones. Final zones are
not relevant as part of an authority discovery.</t>
  <t>Zones containing at least one delegation assertion and at least one
assertion that is not a delegation assertion are mixed zones. No
optimizations are available for mixed zones.</t>
</list></t>

<t>A zone has the following information elements:</t>

<t><list style="symbols">
  <t>Context: name of the context in which the assertions in the zone are valid;
see <xref target="context-in-assertions"/> above.</t>
  <t>Zone: name of the zone.</t>
  <t>Content: a set of assertions and/or shards sharing the context and zone.</t>
  <t>Signatures: one or more signatures generated by the authority for the
shard; see <xref target="signatures-in-assertions"/>.</t>
  <t>Kind: delegation-only, final, or mixed; see above.</t>
</list></t>

</section>
</section>
<section anchor="query" title="Query">

<t>A query is a request for a set of assertions supporting a conclusion about a
given subject-object mapping. It consists of the following information
elements:</t>

<t><list style="symbols">
  <t>Contexts: an expression of the context(s) in which assertions answering the
query will be accepted; see <xref target="context-in-queries"/> below.</t>
  <t>Qualified-Subject: the name about which the query is made. The subject name
in a query must be fully-qualified.</t>
  <t>Types: a set of assertion types the querier is interested in.</t>
  <t>Valid-Until: an optional client-generated timestamp for the query after 
which it expires and should not be answered.</t>
  <t>Query Token: a client-generated token for the query, which can be used
in the answer to refer to the query.</t>
</list></t>

<t>A query expresses interest about all the given types of assertion in all the
specified contexts; more complex expressions of which types in which contexts
must be asked using multiple queries. Preferences for tradeoffs (freshness,
bandwidth efficiency, latency, privacy preservation) in servicing a query may
be bound to the query using query options.</t>

<section anchor="context-in-queries" title="Context in Queries">

<t>Contexts are used in queries as they are in assertions 
(see <xref target="context-in-assertions"/>). 
Assertion contexts in an answer to a query have to match some
context in the query in order to respond to a query. However, there are a few
additional considerations. An assertion can only exist with a specific
context, while queries may accept answers in multiple contexts. The Contexts
part of a query is a sequence of context specifiers taken to be in order of
decreasing priority. A special null context (represented by the empty string)
indicates that assertions in any context will be accepted. Any context in the
Contexts part of a query may additionally be negated, in order to note that
assertions in those contexts are not acceptable. Negated context name
appearing in the Contexts part of a query before the null context expresses
“any context except these”.</t>

<t>Query contexts can also be used to provide additional information to RAINS
servers about the query. For example, contexts can provide a method for
explicit selection of a CDN server not based on either the client’s or the
resolver’s address (see <xref target="RFC7871"/>). Here, the CDN creates a context for
each of its content zones, and an external service selects appropriate
contexts for the client based not just on client source address but passive
and active measurement of performance. Queries for names at which content
resides can then be made within these contexts, with the priority order of
the contexts reflecting the goodness of the zone for the client. Here, a
context might be zrh.cx–.cdn-zones.some-cdn.com for names of servers
hosting content in a CDN’s Zurich data center, and a client could represent
its desire to find content nearby by making queries in the zrh.cx–,
fra.cx– (Frankfurt), and ams.cx– (Amsterdam) contexts within cdn-zones
.some-cdn.com. In all cases, the assertions themselves will be signed by the
authority for cdn-zones.some-cdn.com, accurately representing that it is
the CDN, not the owner of the related name in the global context, that is
making the assertion.</t>

<t>As with assertion contexts, developing conventions for query contexts for
different situations will require implementation and deployment experience,
and is a subject for future work.</t>

</section>
<section anchor="answers-to-queries" title="Answers to Queries">

<t>An answer consists of a set of assertions, shards, and/or zones which respond
to a query. If the query contained a token, it is bound to that query via the
token.</t>

<t>The content of an answer depends on whether the answer is positive or negative.
A positive answer contains the information requested in the smallest atomic
container that can be found, usually a single assertion. A negative answer
contains the information used to verify it; either a shard with the
Complete-Flag set, an entire Zone, or a Zone-Nameset assertion showing the name
is illegal within the zone.</t>

<t>A query is taken to have an inconclusive answer when no answer returns to the
querier before the query’s Valid-Until time.</t>

</section>
</section>
<section anchor="address-to-object-mapping" title="Address to Object Mapping">

<t>In contrast to the current domain name system, information about addresses is
stored in a completely separate tree, keyed by address and prefix. An address 
assertion consists of the following elements:</t>

<t><list style="symbols">
  <t>Context: name of the context in which the assertion is valid;
see <xref target="context-in-address-assertions"/>.</t>
  <t>Subject: address about which the assertion is made, consisting of an address
family, address, and prefix length. A subject may be a network address
(where the prefix length is less than the address length for the given
address family) or a host address (where the prefix length is equal to the
address length for the given address family)</t>
  <t>Type: the type of information about the Subject contained in the 
assertion. Each Assertion is about a single type of data.</t>
  <t>Object: the data of the indicated type associated with the Subject</t>
  <t>Signatures: one or more signatures generated by the authority for the
Assertion. Signatures contain a time interval during which they are considered
valid, and may contain a revocation token allowing them to be revoked before
the end of the time interval, as in <xref target="signatures-in-assertions"/>.</t>
</list></t>

<t>The following object types are available:</t>

<t><list style="symbols">
  <t>Delegation: the authority associated with the subject network address. 
The Object contains a public key by which the authority can be identified. Only available for network address subjects.</t>
  <t>Redirection: The name(s) of one or more a RAINS servers providing authority
service for the authority associated with the subject network address.
The Object contains a set of names. Only available for network address subjects.</t>
  <t>Name: one or more names associated with the subject network address.
The Object contains a set of names. Only available for host address subjects.</t>
  <t>Zone-Registrant: Information about the organization responsible for a 
network. Only available for network address subjects.</t>
</list></t>

<t>Assertions about addresses can be grouped into Zones. An address Zone has the following information elements:</t>

<t><list style="symbols">
  <t>Context: name of the context in which the assertions in the zone are valid;
see <xref target="context-in-address-assertions"/>.</t>
  <t>Zone: subject address of the zone, consisting of an address family,
address, and prefix length. The prefix length must be less than the address
length for the given address family.</t>
  <t>Content: a set of assertions and/or shards sharing the context and zone.</t>
  <t>Signatures: one or more signatures generated by the authority for the
shard; see <xref target="signatures-in-assertions"/>.</t>
</list></t>

<t>Queries for addresses are similar to those for names, and consist of the following information elements:</t>

<t><list style="symbols">
  <t>Context: Context in which the query is made; this must match the assertion 
context as in <xref target="context-in-address-assertions"/>.</t>
  <t>Subject: the address about which the query is made, consisting of an address
family, address, and prefix length.</t>
  <t>Types: a set of assertion types the querier is interested in, as above.</t>
  <t>Valid-Until: an optional client-generated timestamp for the query after 
which it expires and should not be answered.</t>
  <t>Query Token: a client-generated token for the query, which can be used
in the answer to refer to the query.</t>
</list></t>

<section anchor="context-in-address-assertions" title="Context in Address Assertions">

<t>Just as in forward Assertions, Assertion contexts are used in address
assertions to determine the scope of an address assertion, and the signature
chain used to verify it.</t>

<t><list style="symbols">
  <t>The global addressing context for each address family is identified by the
special context name `.’. For both IPv4 and IPv6 addresses, this is rooted at IANA, which delegates to the RIRs, which then delegates to LIRs and to address-holding registries.</t>
  <t>Local contexts associated with a given authority in a forward tree can 
also make assertions about addresses. As with contexts in forward 
assertions, the authority-part and
the context-part of a local context name are divided by a context marker 
(‘cx–’). The authority-part directly identifies the authority whose key was
used to sign the assertion; assertions within a local context are only valid
if signed by the identified authority. Authorities have complete control
over how the contexts under their namespaces are arranged, and over the names 
within those contexts.</t>
</list></t>

<t>Each local context may have a root address space zone (0/0), but these root
address spaces may only delegate addresses that are reserved for local use
<xref target="RFC1918"/> <xref target="RFC4193"/>. Local context assertions for other addresses are
invalid.</t>

</section>
</section>
</section>
<section anchor="cbor" title="Data Model">

<t>The RAINS data model is a relatively straightforward mapping of the
information model in <xref target="information-model"/> to the Concise Binary Object
Representation (CBOR) <xref target="RFC7049"/>, with an outer message type providing a
mechanism for future capabilities-based versioning and recognition of a
message as a RAINS message.</t>

<t>Messages, assertions, shards, zones, queries, and notifications are each
represented as a CBOR map of integer keys to values, which allows each of
these types to be extended in the future, as well as the addition of non-
standard, application-specific information to RAINS messages and data items. A
common registry of map keys is given in <xref target="tabmkey"/>. RAINS implementations
MUST ignore map keys the do not understand. Integer map keys in the range -22
to +23 are reserved for the use of future versions or extensions to the RAINS
protocol.</t>

<t>Message contents, signatures and object values are implemented as type-
prefixed CBOR arrays with fixed meanings of each array element; the structure
of these lower-level elements can therefore not be extended. Message section
types are given in <xref target="tabsection"/>, object types in <xref target="tabobj"/>, and signature
algorithms in <xref target="tabsig"/>.</t>

<section anchor="cbor-symtab" title="Symbol Table">

<t>The meaning of each of the integer keys in message, zone, shard, assertion,
and notification maps is given in the symbol table below:</t>

<texttable title="CBOR Map Keys used in RAINS" anchor="tabmkey">
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>0</c>
      <c>signatures</c>
      <c>Signatures on a message or section</c>
      <c>1</c>
      <c>capabilities</c>
      <c>Capabilities of server sending message</c>
      <c>2</c>
      <c>token</c>
      <c>Token for referring to a data item</c>
      <c>3</c>
      <c>subject-name</c>
      <c>Subject name in an assertion</c>
      <c>4</c>
      <c>subject-zone</c>
      <c>Zone name in an assertion</c>
      <c>5</c>
      <c>subject-addr</c>
      <c>Subject address in address assertion or zone</c>
      <c>6</c>
      <c>context</c>
      <c>Context of an assertion</c>
      <c>7</c>
      <c>objects</c>
      <c>Objects of an assertion</c>
      <c>8</c>
      <c>query-name</c>
      <c>Fully qualified name for a query</c>
      <c>9</c>
      <c>query-contexts</c>
      <c>Contexts acceptable in query answers</c>
      <c>10</c>
      <c>query-types</c>
      <c>Acceptable object types for query</c>
      <c>11</c>
      <c>shard-range</c>
      <c>Lexical range of Assertions in Shard</c>
      <c>12</c>
      <c>query-expires</c>
      <c>Absolute timestamp for query expiration</c>
      <c>13</c>
      <c>query-opts</c>
      <c>Set of query options requested</c>
      <c>21</c>
      <c>note-type</c>
      <c>Notification type</c>
      <c>22</c>
      <c>note-data</c>
      <c>Additional notification data</c>
      <c>23</c>
      <c>content</c>
      <c>Content of a message, shard, or zone</c>
</texttable>

</section>
<section anchor="cbor-message" title="Message">

<t>All interactions in RAINS take place in an outer envelope called a Message,
which is a CBOR map tagged with the RAINS Message tag (hex 0xE99BA8, decimal
15309736).</t>

<t>A Message map MAY contain a signatures (0) key, whose value is an array of
Signatures over the entire message as defined in <xref target="cbor-signature"/>, to be
verified against the infrastructure key for the RAINS Server originating the
message.</t>

<t>A Message map MAY contain a capabilities (1) key, whose value is described in
{#cbor-capabilities}.</t>

<t>A Message map MUST contain a token (2) key, whose value is a byte array of
maximum length 32. See <xref target="cbor-tokens"/>.</t>

<t>A Message map MUST contain a content (23) key, whose value is an array of
Message Sections; a Message Section is either an Assertion, Shard, Zone, or
Query.</t>

</section>
<section anchor="message-section-header" title="Message Section header">

<t>Each Message Section in the Message’s content value MUST be a two-element
array. The first element in the array is the message section type, encoded as
an integer as in <xref target="cbor-symtab"/>. The second element in the array is a message
section body, a CBOR map defined as in the subsections shown in <xref target="cbor-symtab"/>:</t>

<texttable title="Message Section Type Codes" anchor="tabsection">
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>1</c>
      <c>assertion</c>
      <c>Assertion (see <xref target="cbor-assertion"/>)</c>
      <c>-1</c>
      <c>revassertion</c>
      <c>Address Assertion (see <xref target="cbor-revassert"/>)</c>
      <c>2</c>
      <c>shard</c>
      <c>Shard (see <xref target="cbor-shard"/>)</c>
      <c>3</c>
      <c>zone</c>
      <c>Zone (see <xref target="cbor-zone"/>)</c>
      <c>-3</c>
      <c>revzone</c>
      <c>Address Zone (see <xref target="cbor-revzone"/>)</c>
      <c>4</c>
      <c>query</c>
      <c>Query (see <xref target="cbor-query"/>)</c>
      <c>-4</c>
      <c>revquery</c>
      <c>Address Query (see <xref target="cbor-revquery"/></c>
      <c>23</c>
      <c>notification</c>
      <c>Notification (see <xref target="cbor-notification"/>)</c>
</texttable>

</section>
<section anchor="cbor-assertion" title="Assertion body">

<t>An Assertion body is a map. The keys present in this map depend on whether the
Assertion is contained in a Message Section or in a Shard or Zone.</t>

<t>Assertions contained in Message Sections are “bare Assertions”. Since they
cannot inherit any values from their containers, they MUST contain the
signatures (0), subject-name (3), subject-zone (4), context (6), and objects
(7) keys.</t>

<t>Assertions within a Shard or Zone are “contained Assertions”, and can inherit
values from their containers. A contained Assertion MUST contain the subject-
name (3) and objects (7) keys. It MAY contain subject-zone (4) and context (6)
keys, but in this case the values of these keys MUST be identical to the
values in the containing Shard or Zone.</t>

<t>A contained Assertion SHOULD contain the signatures (0) key, since an unsigned
contained Assertion cannot be used by a RAINS server to answer a query; it
must be returned in a signed Shard or Zone.</t>

<t>The value of the signatures (0) key, if present, is an array of one or more
Signatures as defined in <xref target="cbor-signature"/>. If not present, the containing
Shard or Zone MUST be signed. Signatures on a contained Assertion are
generated as if the inherited subject-zone and context values are present in
the Assertion, whether actually present or not. The signatures on the
Assertion are to be verified against the appropriate key for the Zone
containing the Assertion in the given context, as described in 
<xref target="signatures-in-assertions"/>.</t>

<t>The value of the subject-name (3) key is a UTF-8 encoded <xref target="RFC3629"/> string
containing the name of the subject of the assertion. The subject name never
contains the zone in which the subject name; the fully-qualified name is
obtained by joining the subject-name to the subject-zone with a ‘.’ character.
The subject-name must be valid according to the nameset expression for the
zone, if any.</t>

<t>The value of the subject-zone (4) key, if present, is a UTF-8 encoded string
containing the name of the zone in which the assertion is made. If not
present, the zone of the assertion is inherited from the containing Shard or Zone.</t>

<t>The value of the context (6) key, if present, is a UTF-8 encoded string
containing the name of the context in which the assertion is valid. If not
present, the context of the assertion is inherited from the containing Shard
or Zone.</t>

<t>The value of the objects (7) key is an array of objects, as defined in 
<xref target="cbor-object"/>.</t>

</section>
<section anchor="cbor-shard" title="Shard body">

<t>A Shard body is a map. The keys present in the map depend on whether the Shard
is contained in a Message Section or in a Zone.</t>

<t>Shards contained in Message Sections are “bare Shards”. Since they cannot
inherit any values from their contained Zone, they MUST contain the content
(23), signatures (0), subject-zone (4), context (6), and may contain the shard-range (11) key.</t>

<t>Shards within a Zone are “contained Shards”, and can inherit values from their
containing Zone. A contained Shard MUST contain the content (23) key, and MAY
contain the shard-range(11) key. It MAY contain subject- zone (4) and context
(6) keys, but in this case the values of these keys MUST be identical to the
values in the containing Zone.</t>

<t>A contained Shard SHOULD contain the signatures (0) key if it also contains a
shard-range (11) key, since an unsigned contained Shard cannot be used by a
RAINS server to answer a query for nonexistence; it must be returned in a
signed Zone.</t>

<t>The value of the content (23) key is an array of Assertion bodies as defined in
{#cbor-assertion}.</t>

<t>The value of the signatures (0) key, if present, is an array of one or more
Signatures as defined in <xref target="cbor-signature"/>. If not present, the containing
Zone MUST be signed. Signatures on a contained Shard are generated as if the
inherited subject-zone and values are present in the Shard, whether actually
present or not. The signatures on the Shard are to be verified against the
appropriate key for the Zone containing the Shard in the given context, as
described in <xref target="signatures-in-assertions"/>.</t>

<t>The value of the subject-zone (4) key, if present, is a UTF-8 encoded string
containing the name of the zone in which the Assertions within the Shard is
made. If not present, the zone of the assertion is inherited from the
containing Zone.</t>

<t>The value of the context (6) key, if present, is a UTF-8 encoded string
containing the name of the context in which the Assertions within the Shard
are valid. If not present, the context of the assertion is inherited from the
containing Zone.</t>

<t>If the shard-range (11) key is present, the the shard is lexicographically complete
within the range described in its value: a mapping for a (subject-name,
object-type) pair that should be between the two values given in the range but
is not is asserted to not exist. Lexicographic sorting is done on subject names
by ordering Unicode codepoints in ascending order; ordering on object types is
done via their code values in <xref target="cbor-object"/> in ascending order.</t>

<t>The shard-range value MUST be a two element array of strings or nulls
(subject-name A, subject-name B). A must lexicographically sort before B, but
neither subject name need be present in the shard’s contents. If A is null,
the shard begins at the beginning of the zone. If B is null, the shard ends at
the end of the zone. The shard MUST NOT contain any assertions whose subject
names sort before A or after B. In addition, the authority for the shard belongs to
MUST NOT make any assertions during the period of validity of the shard’s
signatures that would fall between subject-name A and subject-name B inclusive
that are not contained within the shard 
(see <xref target="runtime-consistency-checking"/>).</t>

<t>If the shard-range key is not present, the shard is not lexicographically
complete and MUST NOT be used to make assertions about nonexistance.</t>

</section>
<section anchor="cbor-zone" title="Zone Message Section body">

<t>A Zone body is a map. Zones MUST contain the content (23), signatures (0),
subject-zone (4), and context (6) keys.</t>

<t>Signatures on the Zone are to be verified against the appropriate key for the
Zone in the given context, as described in <xref target="signatures-in-assertions"/>.</t>

<t>The value of the content (23) key is an array of Shard bodies as defined in
{#cbor-shard} and/or Assertion bodies as defined in {#cbor-assertion}.</t>

<t>The value of the subject-zone (4) key is a UTF-8 encoded string
containing the name of the Zone.</t>

<t>The value of the context (6) key is a UTF-8 encoded string
containing the name of the context for which the Zone is valid.</t>

</section>
<section anchor="cbor-query" title="Query Message Section body">

<t>A Query body is a map. Queries MUST contain the the token (2), query-name (8),
query-contexts (9), and query-types (10) keys. Queries MAY contain the query-
expires (12) and query-opts (13) keys.</t>

<t>The value of the token (2) key, is a byte array of maximum length
32. Future messages or notifications containing answers to this query MUST
contain this token, if present. See <xref target="cbor-tokens"/>.</t>

<t>The value of the query-name (8) key is a UTF-8 encoded string containing the
fully qualified name that is the subject of the query.</t>

<t>The value of the query-contexts (9) key is an allowable context expression, as an
array of context names as UTF-8 encoded strings. The allowable context
expression is evaluated in-order, as follows:</t>

<t><list style="symbols">
  <t>Context names appearing earlier in the expression are given priority over
context names appearing later in the expression.</t>
  <t>A context name may be negated by prepending the context negation marker 
‘cx–0-.’ to the context name; a negated context name means the named context
is not acceptable in answers to this query.</t>
  <t>The special context name ‘.’ refers to the global context.</t>
  <t>The special context name ‘cx–any-‘ means ‘any context is acceptable’.</t>
</list></t>

<t>Some examples:</t>

<t><list style="symbols">
  <t>[‘cx–.inf.ethz.ch.’, ‘cx–any-‘] means that answers in the 
‘cx–.inf.ethz.ch.’ context are preferred, but any context is acceptable;</t>
  <t>[’.’, ‘cx–.inf.ethz.ch.’] means that only answers in the
‘cx–.inf.ethz.ch.’ or global contexts are acceptable, with the global
context preferred;</t>
  <t>[’.’, cx–0-.cx–.inf.ethz.ch.’, ‘cx–any-‘] means that answers in any 
context except ‘cx–.inf.ethz.ch.’ are acceptable, with the global context
preferred.</t>
</list></t>

<t>An empty context array in a query is taken to be equivalent to an array
containing only [’.’, ‘cx–any-‘]; i.e. any context acceptable, global context
preferred.</t>

<t>The value of the query-types (10) key is an array of integers encoding the
type(s) of objects (as in <xref target="cbor-object"/>) acceptable in answers to the query.
All values in the query-type array are treated at equal priority: [2,3] means
the querier is equally interested in both IPv4 and IPv6 addresses for the
query-name. An empty query-types array indicates that objects of any type are
acceptable in answers to the query.</t>

<t>The value of the query-expires (12) key, if present, is a CBOR integer
counting seconds since the UNIX epoch UTC, identified with tag value 1 and
encoded as in section 2.4.1 of <xref target="RFC7049"/>. After the query-expires time, the
query will have been considered not answered by the original issuer.</t>

<t>The value of the query-opts (13) key, if present, is an array of integers in
priority order of the querier’s preferences in tradeoffs in answering the
query, as in <xref target="tabqopts"/>.</t>

<texttable title="Query Option Codes" anchor="tabqopts">
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>1</c>
      <c>Minimize end-to-end latency</c>
      <c>2</c>
      <c>Minimize last-hop answer size (bandwidth)</c>
      <c>3</c>
      <c>Minimize information leakage beyond first hop</c>
      <c>4</c>
      <c>No information leakage beyond first hop: cached answers only</c>
      <c>5</c>
      <c>Expired assertions are acceptable</c>
      <c>6</c>
      <c>Enable query token tracing</c>
      <c>7</c>
      <c>Disable verification delegation (client protocol only)</c>
      <c>8</c>
      <c>Suppress proactive caching of future assertions</c>
</texttable>

<t>Options 1-5 specify performance/privacy tradeoffs. Each server is free to
determine how to minimize each performance metric requested; however, servers
MUST NOT generate queries to other servers if “no information leakage” is
specified, and servers MUST NOT return expired assertions unless “expired
assertions acceptable” is specified.</t>

<t>Option 6 specifies that a given token (see <xref target="cbor-tokens"/>) should be used on
all queries resulting from a given query, allowing traceability through an
entire RAINS infrastructure. It is meant for debugging purposes.</t>

<t>By default, a client service will perform verification of negative queries and
return a 404 No Assertion Exists for queries with a consistent proof of non-
existence, within a message signed by the query service’s infrakey. Option 7
disables this behavior, and causes the query service to return the shard
proving nonexistence for verification by the client. It is intended to be used
with untrusted query services.</t>

<t>Option 8 specifies that a querier’s interest in a query is strictly ephemeral,
and that future assertions related to this query SHOULD NOT be proactively
pushed to the querier.</t>

</section>
<section anchor="cbor-revassert" title="Address Assertion Message Section body">

<t>Assertions about addresses are similar to assertions about names, but keyed by
address and restricted in terms of the objects they can contain. An Address
Assertion body is a map. The keys present in this map depend on whether the
Assertion is contained in a Message Section or in an Address Zone.</t>

<t>Address Assertions contained in Message Sections are “bare Address
Assertions”, and MUST contain the signatures (0), subject-addr (5),
context (6), and objects (7) keys.</t>

<t>Address Assertions contained in an Address Zone are “contained Address
Assertions”, and can inherit their context from and be signed within their
containing Zone. A contained Address Assertion MUST contain the 
subject-addr (5) and objects (7) keys. It MAY contain the context (6) key, but in
this case the value of this keys MUST be identical to the value in the
containing Address Zone.</t>

<t>A contained Address Assertion SHOULD contain the signatures (0) key, since an
unsigned contained Address Assertion cannot be used by a RAINS server to
answer a query; it must be returned in a signed Address Zone.</t>

<t>The value of the signatures (0) key, if present, is an array of one or more
Signatures as defined in <xref target="cbor-signature"/>. If not present, the containing
Address Zone MUST be signed. Signatures on a contained Address Assertion are
generated as if the inherited context value are present in
the Assertion, whether actually present or not. The signatures on the
Assertion are to be verified against the appropriate key for the Address Zone
containing the Assertion in the given context, as described in 
<xref target="signatures-in-assertions"/>.</t>

<t>The value of the subject-addr (5) key is a three element CBOR array. The first
element of the array is the address family encoded as an object type, 2 for
IPv6 addresses and 3 for IPv4 addresses. The second element is the prefix
length encoded as an integer, 0-128 for IPv6 and 0-32 for IPv4. The third
element is the address, encoded as in <xref target="cbor-object"/>. Subject addresses with
the maximum prefix length for the address family are subject host addresses,
and are nameable; subject addresses with less than the maximum prefix length
are subject network addresses, and are delegatable.</t>

<t>The value of the context (6) key, if present, is a UTF-8 string
containing the name of the context in which the Address Assertion is valid. If
not present, the context of the Address Assertion is inherited from the
containing Address Zone. See <xref target="context-in-address-assertions"/>.</t>

<t>The value of the objects (7) key is an array of objects, as defined in
<xref target="cbor-object"/>. Only object types redirection, delegation, and registrant are
available for subject network addresses, and only object type name is
available for subject host addresses.</t>

</section>
<section anchor="cbor-revzone" title="Address Zone Message Section body">

<t>Assertions about addresses can be grouped into zones, where all the assertions
within the zone are contained within the zone’s address. These Address Zones
are similar to Zones containing assertions about names, but are keyed by
network address and restricted in their semantics.</t>

<t>An Address Zone body is a map. Zones MUST contain the content (23), signatures (0),
subject-addr (5), and context (6) keys.</t>

<t>Signatures on the Zone are to be verified against the appropriate key for the
Zone in the given context, as described in <xref target="signatures-in-assertions"/>.</t>

<t>The value of the subject-addr (5) key is a three element CBOR array. The first
element of the array is the address family encoded as an object type, 2 for
IPv6 addresses and 3 for IPv4 addresses. The second element is the prefix
length encoded as an integer, 0-127 for IPv6 and 0-31 for IPv4. The third
element is the address, encoded as in <xref target="cbor-object"/>. Only subject network
addresses are acceptable for Address Zones.</t>

<t>The value of the content (23) key is an array of Address Assertion bodies as
defined in {#cbor-revassert}. The Address Assertions within the content array
MUST fall completely within the network designated by the subject-addr value.</t>

<t>The value of the context (6) key is a UTF-8 encoded string
containing the name of the context for which the Zone is valid.</t>

</section>
<section anchor="cbor-revquery" title="Address Query Message Section body">

<t>Queries for assertions about addresses are similar to queries for assertions
about names, but have semantic restrictions similar to those for Address
Assertions and Address Zones. An address query may have only one context.</t>

<t>An Address Query body is a map. Queries MUST contain the the token (2), subject-addr (5),
context (6), and query-types (10) keys. Queries MAY contain query-opts
(13) and query-expires (12) keys.</t>

<t>The value of the token (2) key, is a byte array of maximum length
32. Future messages or notifications containing answers to this query MUST
contain this token, if present. See <xref target="cbor-tokens"/>.</t>

<t>The value of the subject-addr (5) key is a three-element CBOR array. The first
element of the array is the address family encoded as an object type, 2 for
IPv6 addresses and 3 for IPv4 addresses. The second element is the prefix
length encoded as an integer, 0-128 for IPv6 and 0-32 for IPv4. The third
element is the address, encoded as in <xref target="cbor-object"/>.</t>

<t>The value of the context (6) key is a UTF-8 encoded string containing the name
of the context for which the Query is valid. Unlike queries for names, queries
for Address Queries can only pertain to a single context.<vspace />
See <xref target="context-in-address-assertions"/> for more.</t>

<t>The value of the query-expires (12) key, if present, is a CBOR integer
counting seconds since the UNIX epoch UTC, identified with tag value 1 and
encoded as in section 2.4.1 of <xref target="RFC7049"/>. After the query-expires time, the
query will have been considered not answered by the original issuer.</t>

<t>The value of the query-opts (13) key, if present, is an array of integers in
priority order of the querier’s preferences in tradeoffs in answering the
query, as in <xref target="tabqopts"/>. See <xref target="cbor-query"/> for more.</t>

<t>Any Address Assertion relating to an address containing the address queried
for is considered to respond to the query, with more-specific prefixes being
preferred over less-specific.</t>

</section>
<section anchor="cbor-notification" title="Notification Message Section body">

<t>Notification Message Sections contain information about the operation of the
RAINS protocol itself. A Notification Message Section body is a map which MUST
contain the token (2) and note-type (21) keys and MAY contain the note-data
(22) key. The value of the note-type key is encoded as an integer as in the
<xref target="tabnotify"/>.</t>

<texttable title="Notification Type Codes" anchor="tabnotify">
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>100</c>
      <c>Connection heartbeat</c>
      <c>399</c>
      <c>Capability hash not understood</c>
      <c>400</c>
      <c>Malformed message received</c>
      <c>403</c>
      <c>Inconsistent message received</c>
      <c>404</c>
      <c>No assertion exists (client protocol only)</c>
      <c>413</c>
      <c>Message too large</c>
      <c>500</c>
      <c>Unspecified server error</c>
      <c>501</c>
      <c>Server not capable</c>
      <c>504</c>
      <c>No assertion available</c>
</texttable>

<t>Note that the status codes are chosen to be mnemonically similar to status
codes for HTTP <xref target="RFC7231"/>. Details of the meaning of each status code are
given in <xref target="protocol-def"/>.</t>

<t>The value of the token (2) key is a byte array of maximum length 32, which
MUST contain the token of the message or query to which the notification is a
response. See <xref target="cbor-tokens"/>.</t>

<t>The value of the note-data (22) key, if present, is a UTF-8 encoded string
with additional information about the notification, intended to be displayed
to an administrator to help debug the issue identified by the negotiation.</t>

</section>
<section anchor="cbor-object" title="Object">

<t>Objects are encoded as arrays in CBOR, where the first element is the type of
the object, encoded as an integer in the following table:</t>

<texttable title="Object type codes" anchor="tabobj">
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Name</ttcol>
      <ttcol align='left'>Description</ttcol>
      <c>1</c>
      <c>name</c>
      <c>name associated with subject</c>
      <c>2</c>
      <c>ip6-addr</c>
      <c>IPv6 address of subject</c>
      <c>3</c>
      <c>ip4-addr</c>
      <c>IPv4 address of subject</c>
      <c>4</c>
      <c>redirection</c>
      <c>name of zone authority server</c>
      <c>5</c>
      <c>delegation</c>
      <c>public key for zone delgation</c>
      <c>6</c>
      <c>nameset</c>
      <c>name set expression for zone</c>
      <c>7</c>
      <c>cert-info</c>
      <c>certificate information for name</c>
      <c>8</c>
      <c>service-info</c>
      <c>service information for srvname</c>
      <c>9</c>
      <c>registrar</c>
      <c>registrar information</c>
      <c>10</c>
      <c>registrant</c>
      <c>registrant information</c>
      <c>11</c>
      <c>infrakey</c>
      <c>public key for RAINS infrastructure</c>
</texttable>

<t>A name (1) object contains a name associated with a name as an alias. It is
represented as a three-element array. The second element is a fully-qualified
name as a UTF-8 encoded string. The third type is an array of object type
codes for which the alias is valid, with the same semantics as the query-types
(9) key in queries (see <xref target="cbor-query"/>).</t>

<t>An ip6-addr (2) object contains an IPv6 address associated with a name. It is
represented as a two element array. The second element is a byte array of
length 16 containing an IPv6 address in network byte order.</t>

<t>An ip4-addr (3) object contains an IPv4 address associated with a name. It is
represented as a two element array. The second element is a byte array of
length 4 containing an IPv4 address in network byte order.</t>

<t>A redirection (4) object contains the fully-qualified name of a RAINS
authority server for a named zone. It is represented as a two-element array.
The second element is a fully-qualified name of an RAINS authority server as a
UTF-8 encoded string.</t>

<t>A delegation (5) object contains the public key used to generate signatures
on assertions in a named zone, and by which a delegation of a name within a
zone to a subordinate zone may be verified. It is represented as an N-element
array. The second element is a signature algorithm identifier as in 
<xref target="cbor-signature"/>. Additional elements are as defined in <xref target="cbor-signature"/> 
for the given algorithm identifier.</t>

<t>A nameset (6) object contains an expression defining which names are allowed
and which names are disallowed in a given zone. It is represented as a two-
element array. The second element is a nameset expression to be applied to
each name element within the zone without an intervening delegation, as
defined in <xref target="cbor-nameset"/></t>

<t>A cert-info (7) object contains an expression binding a certificate or
certificate authority to a name, such that connections to the name must either
use the bound certificate or a certificate signed by a bound authority. It is
represented as an five-element array, as defined in <xref target="cbor-certinfo"/>.</t>

<t>A service-info (8) object gives information about a named service. Services
are named as in <xref target="RFC2782"/>. It is represented as a four-element array. The
second element is a fully-qualified name of a host providing the named service
as a UTF-8 string. The third element is a transport port number as a positive
integer in the range 0-65535. The fourth element is a priority as a positive
integer, with lower numbers having higher priority.</t>

<t>A registrar (9) object gives the name and other identifying information of the
registrar (the organization which caused the name to be added to the
namespace) for organization-level names. It is represented as a UTF-8 string
of maximum length 256 bytes containing identifying information chosen by the
registrar according to the registry’s policy.</t>

<t>A registrant (10) object gives information about the registrant of an
organization-level name. It is represented as a UTF-8 string with a maximum
length of 4096 bytes containing this information, with a format chosen by the
registrar according to the registry’s policy.</t>

<t>An infrakey (11) object contains the public key used to generate signatures on
messages by a named RAINS server, by which a RAINS message signature may be
verified by a receiver. It is identical in structure to a delegation object,
as defined in <xref target="cbor-signature"/>.</t>

<section anchor="cbor-certinfo" title="Certificate information format">

<t>A cert-info object contains information about the certificate(s) that can be
used to authenticate a transport-layer association with a named entity. It is
encoded as a file-element array. The first element is the RAINS object type
(7). The second element is the protocol family specifier, describing the
cryptographic protocol used to connect, as defined in <xref target="tabcertproto"/>. The
protocol family defines the format of certificate data to be hashed. The third
element is the certificate usage specifier as in <xref target="tabcertusage"/>, describing
the constraint imposed by the assertion. These are defined to be compatible
with Certificate Usages in the TLSA RRTYPE for DANE <xref target="RFC6698"/>. The fourth
element is the hash algorithm identifier, defining the hash algorithm used to
generate the certificate data. The fifth item is the data itself, whose format
is defined by the protocol family and hash algorithm.</t>

<texttable title="Certificate information protocol families" anchor="tabcertproto">
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Protocol family</ttcol>
      <ttcol align='left'>Certificate format</ttcol>
      <c>0</c>
      <c>Unspecified</c>
      <c>Unspecified</c>
      <c>1</c>
      <c>Transport Layer Security (TLS) <xref target="RFC5246"/></c>
      <c><xref target="RFC5280"/></c>
</texttable>

<t>Protocol family 0 leaves the protocol family unspecified; client validation
and usage of cert-info assertions, and the protocol used to connect, are up to
the client, and no information is stored in RAINS. Protocol family 1 specifies
Transport Layer Security version 1.2 <xref target="RFC5246"/> or a subsequent version,
secured with PKIX <xref target="RFC5280"/> certificates.</t>

<texttable title="Certificate information usage values" anchor="tabcertusage">
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Certificate usage</ttcol>
      <c>2</c>
      <c>Trust Anchor Certificate</c>
      <c>3</c>
      <c>End-Entity Certificate</c>
</texttable>

<t>A trust anchor certificate constraint specifies a certificate that MUST appear
as the trust anchor for the certificate presented by the subject of the
assertion on a connection attempt. An end-entity certificate constraint
specifies a certificate that MUST be presented by the subject of the assertion
on a connection attempt.</t>

<texttable title="Certificate information hash algorithms" anchor="tabcerthash">
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Hash/HMAC</ttcol>
      <ttcol align='left'>Notes</ttcol>
      <c>0</c>
      <c>None</c>
      <c>Data contains full certificate</c>
      <c>1</c>
      <c>sha-256</c>
      <c>Data contains SHA-256 hash (32 bytes)</c>
      <c>2</c>
      <c>sha-512</c>
      <c>Data contains SHA-512 hash (64 bytes)</c>
      <c>3</c>
      <c>sha-384</c>
      <c>Data contains SHA-384 hash (48 bytes)</c>
</texttable>

<t>Code 0 is used to store full certificates in RAINS assertions, while other
codes are used to store hashes for verification.</t>

<t>For example, in a cert-info object with values [ 7, 1, 3, 3, (data) ], the
data would be a 48 SHA-384 hash of the ASN.1 DER-encoded X.509v3 certificate
(see Section 4.1 of <xref target="RFC5280"/>) to be presented by the endpoint on a
connection attempt with TLS version 1.2 or later.</t>

</section>
<section anchor="cbor-nameset" title="Name expression format">

<t>The nameset expression is represented as a UTF-8 string encoding a modified POSIX
Extended Regular Expression format (see POSIX.2) to be applied to each element
of a name within the zone. A name containing an element that does not match
the valid nameset expression for a zone is not valid within the zone, and the
nameset assertion can be used to prove nonexistence.</t>

<t>The POSIX character classes :alnum:, :alpha:, :ascii:, :digit:, :lower:, and :upper: are available in these regular expressions, where:</t>

<t><list style="symbols">
  <t>:lower: matches all codepoints within the Unicode general category “Letter, lowercase”</t>
  <t>:upper: matches all codepoints within the Unicode general category “Letter, uppercase”</t>
  <t>:alpha: matches all codepoints within the Unicode general category “Letter”.</t>
  <t>:digit: matches all codepoints within the Unicode general category “Number, decimal digit”</t>
  <t>:alnum: is the union of :alpha: and :digit:</t>
  <t>:ascii: matches all codepoints in the range 0x20-0x7f</t>
</list></t>

<t>In addition, each Unicode block is available as a character class, with the syntax :ublkXXXX: where XXXX is a 4 or 5 digit, zero-prefixed hex encoding of the first codepoint in the block. For example, the Cyrillic block is available as :ublk0400:.</t>

<t>Unicode escapes are supported in these regular expressions; the sequence
\uXXXX where XXXX is a 4 or 5 digit, possibly zero-prefixed hex encoding of
the codepoint, is substituted with that codepoint.</t>

<t>Set operations (intersection and subtraction) are available on character
classes. Two character class or range expressions in a bracket expression
joined by the sequence &amp;&amp; are equivalent to the intersection of the two
character classes or ranges. Two character class or range expressions in a
bracket expression joined by the sequence – are equivalent to the subtraction
of the second character class or range from the first.</t>

<t>For example, the nameset expression:</t>

<t>[[:ublk0400:]&amp;&amp;[:lower:][:digit:]]+</t>

<t>matches any name made up of one or more lowercase Cyrillic letters and digits. The same expression can be implemented with a range instead of a character class:</t>

<t>[\u0400-\u04ff&amp;&amp;[:lower:][:digit:]]+</t>

</section>
</section>
<section anchor="cbor-tokens" title="Tokens in queries and messages">

<t>Messages, queries, and notifications all contain an opaque token (2) key,
whose content is a byte array of maximum length 32, and is used to link
Messages to the Queries they respond to, and Notifications to the Messages
they respond to. Tokens MUST be treated as opaque values by RAINS servers.</t>

<t>A Message sent in response to a Query MUST contain the token in that Query.
Otherwise, the Message SHOULD contain a token selected by the server
originating it, so that future Notifications can be linked to the message
causing it. Likewise, a Notification sent in response to a Message MUST
contain the token from the Message causing it.</t>

<t>When a server creates a new query to forward to another server in response to
a query it received, it MUST NOT use the same token on the delegated query
as on the received query, unless option 6 Enable Tracing is present in the
received, in which case it MUST use the same token.</t>

</section>
<section anchor="cbor-signature" title="Signatures, delegation keys, and RAINS infrastructure keys">

<t>RAINS supports multiple signature algorithms and hash functions for signing
assertions for cryptographic algorithm agility <xref target="RFC7696"/>. A RAINS signature
algorithm identifier specifies the signature algorithm; a hash function for
generating the HMAC and the format of the encodings of the signature
values in Assertions, Shards, Zones, and Messages, as well as of public key
values in delegation objects.</t>

<t>RAINS signatures have three common elements: the algorithm identifier, a
valid-since timestamp, and a valid-until timestamp.
Signatures are represented as an array of these three values followed by
additional elements containing the signature data itself, according to the
algorithm identifier.</t>

<t>Valid-since and valid-until timestamps are represented as CBOR integers
counting seconds since the UNIX epoch UTC, identified with tag value 1 and
encoded as in section 2.4.1 of <xref target="RFC7049"/>. A signature MUST have a
valid-until timestamp. If a signature has no specified valid-since time (i.e.,
is valid from the beginning of time until its valid-until timestamp), the
valid-since time MAY be null (as in Table 2 in Section 2.3 of <xref target="RFC7049"/>).</t>

<t>Signatures in RAINS are generated over a normalized serialized CBOR object (a
Message; or an Assertion, Shard, or Zone section body). To normalize and
serialize an object for signing:</t>

<t><list style="symbols">
  <t>Serialize the object with a stub for the signature to be generated:  <list style="symbols">
      <t>Strip all other signatures during serialization by omitting all signatures
(0) keys and their values. When signing a shard or zone, the signatures on
contained assertions, if present, must be omitted too. When signing a
message, the signatures on contained assertions, shards, and zones must be
omitted.</t>
      <t>Add subject zone and context to contained shards and assertions if not
present, inheriting them from their containing shard or zone.</t>
      <t>Create a stub signature within an array within a signatures (0) key at the
appropriate place in the object, containing the algorithm ID, timestamps
and hash chain token, if present, but a null value in the place of the
signature content.</t>
      <t>Normalize the serialized object by emitting all keys in CBOR maps in
ascending numerical order. Note that when serializing anything with a 
Content array, the order of the content array is preserved.</t>
      <t>If the serialized object is a Message, it should be tagged with the RAINS
tag.</t>
    </list></t>
  <t>Generate a signature on the resulting byte stream according to the algorithm
selected.</t>
  <t>Add the full signature to the signatures array at the appropriate point in
the object.</t>
</list></t>

<t>To verify a signature, generate the byte stream as for signing, then verify
the signature according to the algorithm selected.</t>

<t>The following algorithms are supported:</t>

<texttable title="Defined signature algorithms" anchor="tabsig">
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Signatures</ttcol>
      <ttcol align='left'>Hash/HMAC</ttcol>
      <ttcol align='left'>Format</ttcol>
      <c>2</c>
      <c>ecdsa-256</c>
      <c>sha-256</c>
      <c>See <xref target="ecdsa-format"/></c>
      <c>3</c>
      <c>ecdsa-384</c>
      <c>sha-384</c>
      <c>See <xref target="ecdsa-format"/></c>
</texttable>

<section anchor="ecdsa-format" title="ECDSA signature and public key format">

<t>ECDSA public keys consist of a single value, called “Q” in <xref target="FIPS-186-3"/>. Q
is a simple bit string that represents the uncompressed form of a curve point,
concatenated together as “x | y”. The third element in a RAINS delegation
object is the Q bit string encoded as a CBOR byte array. RAINS delegation
objects for ECDSA-256 public keys are therefore represented as the array 
[5, 2, Q]; and for ECDSA-384 public keys as [5, 3, Q].</t>

<t>ECDSA signatures are a combination of two non-negative integers, called “r”
and “s” in <xref target="FIPS-186-3"/>. A Signature using ECDSA is represented using a
four-element CBOR array, with the fourth element being “r | s” such that r is
represented as a byte array as described in Section C.2 of <xref target="FIPS-186-3"/>, and
s represented as a byte array as described in Section C.2 of <xref target="FIPS-186-3"/>.
For ECDSA-256 signatures, each integer MUST be represented as a 32-byte array.
For ECDSA-384 signatures, each integer MUST be represented as a 48-byte array.
RAINS signatures using ECDSA-256 are therefore the array [2, valid-from,
valid-until, r|s]; and for ECDSA-384 the array [3, valid-from, valid-until,
r|s].</t>

<t>ECDSA-256 signatures and public keys use the P-256 curve as defined in <xref target="FIPS-186-3"/>.
ECDSA-384 signatures and public keys use the P-384 curve as defined in <xref target="FIPS-186-3"/>.</t>

<t>All RAINS servers MUST implement ECDSA-256 and ECDSA-384.</t>

</section>
</section>
<section anchor="cbor-capabilities" title="Capabilities">

<t>When a RAINS server or client sends the first message in a stream to a peer,
it MAY expose optional capabilities to its peer using the capabilities (1)
key. This key contains either:</t>

<t><list style="symbols">
  <t>an array of uniform resource names specifying capabilities supported by the
sending server, taken from the table below, with each name encoded as a
UTF-8 string.</t>
  <t>a SHA-256 hash of the CBOR byte stream derived from normalizing such an
array by sorting it in lexicographically increasing order, then serializing
it.</t>
</list></t>

<t>This mechanism is inspired by <xref target="XEP0115"/>, and is intended to be used to
reduce the overhead in exposing common sets of capabilities. Each RAINS server
can cache a set of recently-seen or common hashes, and only request the full
URN set (using notification code 399) on a cache miss.</t>

<t>The following URNs are presently defined; other URNs will specify future
optional features, support for alternate transport protocols and new signature
algorithms, etc.</t>

<texttable>
      <ttcol align='left'>URN</ttcol>
      <ttcol align='left'>Meaning</ttcol>
      <c>urn:x-rains:tlssrv</c>
      <c>Listens for connections on TLS over TCP from other RAINS servers.</c>
</texttable>

<t>Since there are only two defined capabilities at this time, RAINS servers can
be implemented with two hard-coded hashes to determine whether a peer is
listening or not. The hash presented by a server supporting urn:x-rains:tlssrv
is e5365a09be554ae55b855f15264dbc837b04f5831daeb321359e18cdabab5745; the hash
presented by a server supporting no capabilities is
76be8b528d0075f7aae98d6fa57a6d3c83ae480a8469e668d7b0af968995ac71.</t>

<t>A RAINS server MUST NOT assume that a peer server supports a given capability
unless it has received a message containing that capability from that server.
An exception are the capabilities indicating that a server listens for
connections using a given transport protocol; servers and clients can also
learn this information from RAINS itself (given a redirection assertion for a
named zone) or from external configuration values.</t>

</section>
</section>
<section anchor="protocol-def" title="RAINS Protocol Definition">

<t>As noted in <xref target="cbor"/>, RAINS is a message-exchange protocol that uses CBOR
<xref target="RFC7049"/> as its framing. Since CBOR is self-framing – a CBOR parser can
determine when a CBOR object is complete at the point at which it has read its
final byte – RAINS requires no external framing. It can therefore run over
any streaming, multistreaming, or message-oriented transport protocol. In
order to protect query confidentiality, and support rapid deployment over a
ubiquitously implemented transport, RAINS is defined in this document to run
over persistent TLS 1.2 connections <xref target="RFC5246"/> over TCP <xref target="RFC0793"/> with
mutual authentication between servers, and authentication of servers by
clients. The TLS certificates of RAINS server peers can be verified as
specified in the cert-info assertions for those servers.</t>

<t>RAINS servers MUST support this transport; future transports can be negotiated
using the capabilities mechanism after bootstrapping using TLS 1.2. As RAINS
is an experimental protocol, RAINS servers listen on port 1022 <xref target="RFC4727"/> for
connections from other RAINS servers and clients. RAINS servers should strive
to keep connections open to peer servers, unless it is clear that no future
messages will be exchanged with those peers, or in the face of resource
limitations at either peer. If a RAINS server needs to send a message to
another RAINS server to which it does not have an open connection, it attempts
to open a connection with that server.</t>

<t>This section describes the operation of the protocol as used among RAINS
servers. A simplified version of the protocol for client access is described
in <xref target="protocol-client"/>.</t>

<section anchor="protocol-processing" title="Message processing">

<t>Once a transport is established, any server may validly send a message with
any content to any other server. A client may send messages containing queries
to servers, and a server may sent messages containing anything other than
queries to clients.</t>

<t>Upon receipt of a message, a server or client parses it, and:</t>

<t><list style="symbols">
  <t>notes the token on the message. This token MUST be present on any
messages sent in reply to this message.</t>
  <t>processes any capabilities present, replacing the set of capabilities known
for the peer with the set present in the message. If the present
capabilities are represented by a hash that the server does not have in its
cache, it prepares a notification of type 399 “Capability hash not
understood” to send to its peer.</t>
  <t>splits the contents into its constituent message sections, processing them
independently.</t>
</list></t>

<t>On receipt of an assertion, shard, or zone message section, a server:</t>

<t><list style="symbols">
  <t>verifies its consistency (see <xref target="runtime-consistency-checking"/>). If the
section is not consistent, it prepares to send a notification of type 403
Inconsistent Message to the peer, and discards the section. Otherwise, it:</t>
  <t>determines whether it answers an outstanding query; if so, it prepares to
forward the section to the server that issued the query.</t>
  <t>determines whether it is likely to answer a future query, according to its 
configuration, policy, and query history; if so, it caches the section.</t>
</list></t>

<t>On receipt of an assertion, shard, or zone message section, a client:</t>

<t><list style="symbols">
  <t>determines whether it answers an outstanding query; if so, it considers the query answered. It then:</t>
  <t>determines whether it is likely to answer a future query, according to its 
configuration, policy, and query history; if so, it caches the section.</t>
</list></t>

<t>On receipt of a query, a server:</t>

<t><list style="symbols">
  <t>determines whether it has expired by checking the query-expires value. 
If so, it drops the query silently. If not, it:</t>
  <t>determines whether it has a stored assertion, shard, and/or zone message
section which answers the query. If so, it prepares to return the most
specific such section with the signature of the longest remaining validity to the
peer that issued the query. If not, it:</t>
  <t>checks to see whether the query specifies option 4 (cached answers only). If
so, and if option 5 (expired assertions acceptable) is also specified, it
then checks to see if it has any cached sections that answer the query on
which signatures are expired; otherwise, processing stops. If the query does
not specify option 4, delegation proceeds as follows: the server:</t>
  <t>determines whether it has other non-authoritative servers it can forward the
query to, according to its configuration and policy, and in compliance with
any query options (see <xref target="cbor-query"/>). If so, it prepares to forward the
query to those servers, noting the reply for the received query depends on
the replies for the forwarded query. If not, it:</t>
  <t>determines the responsible authority servers for the zone containing the
query name in the query for contexts requested, and forwards the query to
those authority servers, noting the reply for the received query depends on
the reply for the forwarded query.</t>
</list></t>

<t>If query delegation fails to return an answer within a configured timeout for
a delegated query, the server prepares to send a 504 No assertion available
response to the peer from which it received the query.</t>

<t>When a server creates a new query to forward to another server in response to
a query it received, it SHOULD NOT use the same token on the delegated query
as on the received query, unless option 6 Enable Tracing is present in the
received, in which case it MUST use the same token. The Enable Tracing option
is designed to allow debugging of query processing across multiple servers, It
SHOULD only be enabled by clients designed explicitly for debugging RAINS
itself, and MUST NOT be enabled by default by client resolvers.</t>

<t>When a server creates a new query to forward to another server in response to
a query it received, and the received query contains a query-expires time, the
delegated query MUST contain the same query-expires time. If the received
query contains no query-expires time, the delegated query MAY contain a query-
expires time of the server’s choosing, according to its configuration.</t>

<t>On receipt of a notification, a server’s behavior depends on the notification type:</t>

<t><list style="symbols">
  <t>For type 100 “Connection Heartbeat”, the server does nothing: these null
messages are used to keep long-lived connections open in the presence of
network behaviors that may drop state for idle connections.</t>
  <t>For type 399 “Capability hash not understood”, the server prepares to send a
full capabilities list on the next message it sends to the peer.</t>
  <t>For type 504 “No assertion available”, the server checks the token on the
message, and prepares to forward the assertion to the associated query.</t>
  <t>For type 413 “Message too large” the server notes that large messages may 
not be sent to a peer and tries again (see <xref target="protocol-limits"/>), or logs
the error along with the note-data content.</t>
  <t>For type 400 “Malformed message”, type 403 “Inconsistent message”, type 500
“Server error”, or type 501 “Server not capable”, the server logs the error
along with the note-data content, as these notifications generally represent
implementation or configuration error conditions which will require human
intervention to mitigate.</t>
</list></t>

<t>On receipt of a notification, a client’s behavior depends on the notification type:</t>

<t><list style="symbols">
  <t>For type 100 “Connection Heartbeat”, the client does nothing, as above.</t>
  <t>For type 399 “Capability hash not understood”, the client prepares to send a
full capabilities list on the next message it sends to the peer.</t>
  <t>For type 404 “No assertion exists”, the client takes the query to be
unanswerable. It may reissue the query with query option 7 to do the
verification of nonexistence again, if the server from which it received the
notification is untrusted.</t>
  <t>For type 413 “Message too large” the client notes that large messages may 
not be sent to a peer and tries again (see <xref target="protocol-limits"/>), or logs
the error along with the note-data content.</t>
  <t>For type 400 “Malformed message”, type 403 “Inconsistent message”, type 500
“Server error”, or type 501 “Server not capable”, the client logs the error
along with the note-data content, as these notifications generally represent
implementation or configuration error conditions which will require human
intervention to mitigate.</t>
</list></t>

<t>The first message a server or client sends to a peer after a new connection is
established SHOULD contain a capabilities section, if the server or client
supports any optional capabilities. See <xref target="cbor-capabilities"/>.</t>

<t>If the server is configured to keep long-running connections open, due to the
presence of network behaviors that may drop state for idle connections, it
SHOULD send a message containing a type 100 Connection Heartbeat notification
after a configured idle time without any messages containing other content
being sent.</t>

</section>
<section anchor="message-transmission" title="Message Transmission">

<t>As noted in <xref target="protocol-processing"/> many messages are sent in reply to messages
received from peers. Servers may also originate messages on their own, based
on their configuration and policy:</t>

<t><list style="symbols">
  <t>Proactive queries to retrieve assertions, shards, and zones for which all
signatures have expired or will soon expire, for cache management purposes.</t>
  <t>Proactive push of assertions, shards, and zones to other servers, based on
query history or other information indicating those servers may query for
the assertions they contain.</t>
</list></t>

</section>
<section anchor="protocol-limits" title="Message Limits">

<t>RAINS servers MUST accept messages up to 65536 bytes in length, but MAY accept
messages of greater length, subject to resource limitations of the server. A
server with resource limitations MUST respond to a message rejected due to
length restrictions with a notification of type 413 (Message Too Large). A
server that receives a type 413 notification must note that the peer sending
the message only accepts messages smaller than the largest message it’s
successfully sent that peer, or cap messages to that peer to 65536 bytes in
length.</t>

<t>Since a bare assertion with a single ECDSA signature requires on the order of
180 bytes, it is clear that many full zones won’t fit into a single minimum
maximum-size message. Authorities are therefore encouraged to publish zones
grouped into shards that will fit into 65536-byte messages, to allow servers
to reply using these shards when full-zone transfers are not possible due to
message size limitations.</t>

</section>
<section anchor="runtime-consistency-checking" title="Runtime Consistency Checking">

<t>The data model used by the RAINS protocol allows inconsistent information to
be asserted, all resulting from misconfigured or misbehaving authority
servers. The following types of inconsistency are possible:</t>

<t><list style="symbols">
  <t>A lexically complete shard may omit an assertion within its shard-range
which is valid at the same time as the shard.</t>
  <t>A zone may omit an assertion within its zone which is valid at the same time
as the zone.</t>
  <t>An assertion prohibited by its zone’s nameset may be valid at the same time
as the zone’s nameset assertion.</t>
</list></t>

<t>RAINS relies on runtime consistency checking to mitigate inconsistency: each
server receiving an assertion, shard, or zone SHOULD, subject to resource
constraints, ensure that it is consistent with other information it has, and
if not, discard all assertions, shards, and zones in its cache, log the error,
and send a 403 Inconsistent Message to the source of the message.</t>

</section>
<section anchor="integrity-and-confidentiality-protection" title="Integrity and Confidentiality Protection">

<t>Assertions are not valid unless they contain at least one signature that can
be verified from the chain of authorities specified by the name and context on
the assertion; integrity protection is built into the information model. The
infrastructure key object type allows keys to be associated with RAINS
servers in addition to zone authorities, which allows a client to
delegate integrity verification of assertions to a trusted query service (see
<xref target="protocol-client"/>).</t>

<t>Since the job of an Internet naming service is to provide publicly-available
information mapping names to information needed to connect to the services
they name, confidentiality protection for assertions is not a goal of the
system. Specifically, the information model and the mechanism for proving
non-existence of an assertion is not designed to provide resistance against
zone enumeration.</t>

<t>On the other hand, confidentiality protection of query information in crucial.
Linking naming queries to a specific user can be nearly as useful to build a
profile of that user for surveillance purposes as full access to the clear
text of that client’s communications <xref target="RFC7624"/>. In this revision, RAINS uses
TLS to protect communications between servers and between servers and clients,
with certificate information for RAINS infrastructure stored in RAINS itself.
Together with hop-by-hop confidentiality protection, query options, proactive
caching, default use of non-persistent tokens, and redirection among servers
can be used to mix queries and reduce the linkability of query information to
specific clients.</t>

</section>
</section>
<section anchor="protocol-client" title="RAINS Client Protocol">

<t>The protocol used by clients to issue queries to and receive responses from an
query service is a subset of the full RAINS protocol, with the following
differences:</t>

<t><list style="symbols">
  <t>Clients only process assertion, shard, zone, and notification sections;
sending a query to a client results in a 400 Malformed Message notification.</t>
  <t>Clients never listen for connections; a client must initiate and maintain a
transport session to the query server(s) it uses for name resolution.</t>
  <t>Servers only process query and notification sections when connected to
clients; a client sending assertions to a server results in a 400 Malformed
Message notification.</t>
</list></t>

<t>Since signature verification is resource-intensive, clients delegate signature
verification to query servers by default. The query server signs the message
containing results for a query using its own key (published as an infrakey
object associated with the query server’s name), and a validity time
corresponding to the signature it verified with the longest lifetime,
stripping other signatures from the reply. This behavior can be disabled by a
client by specifying query option 7, allowing the client to do its own
verification.</t>

</section>
<section anchor="deployment-considerations" title="Deployment Considerations">

<t>The following subsections discuss issues that must be considered in any
deployment of RAINS at scale.</t>

<section anchor="assertion-lifetime-management" title="Assertion Lifetime Management">

<t>An assertion can contain multiple signatures, each with a different lifetime.
Signature lifetimes are equivalent to a time to live in the present DNS:
authorities should compute a new signature for each validity period, and make
these new signatures available when old ones are expiring.</t>

<t>Since assertion lifetime management is based on a real-time clock expressed in
UTC, RAINS servers MUST use a clock synchronization protocol such as NTP
<xref target="RFC5905"/>.</t>

</section>
<section anchor="secret-key-management" title="Secret Key Management">

<t>The secret keys associated with public keys for each RAINS server (via
infrakey objects) must be available on that server, whether through a hardware
or software security device, so they can sign messages on demand; this is
particularly important for query servers. In addition, the secret keys
associated with TLS certificates for each server (published via certinfo
objects) must be available as well in order to establish TLS sessions.</t>

<t>However, storing zone secret keys (associated via delegation objects) on RAINS
servers would represent a more serious operational risk. To keep this from
being necessary, authority servers have an additional signer interface, from
which they will accept and cache any assertion, shard, or zone for which they
are authority servers until at least the end of validity of the last
signature, provided the signature is verifiable.</t>

</section>
<section anchor="unsigned-contained-assertions" title="Unsigned Contained Assertions">

<t>Although RAINS supports Shards and Zones containing unsigned assertions,
protecting the integrity of those Assertions by the signature on the Shard or
Zone, it is RECOMMENDED that authorities sign each Assertion, even those
contained within a Shard or Zone, in order to minimize the size of positive
answers to queries.</t>

</section>
<section anchor="query-service-discovery" title="Query Service Discovery">

<t>A client that will not do its own verification must be able to discover the
oracle server(s) it should trust for resolution. Integration with e.g. DHCP or
selection of a local multicast discovery method are left to a future revision
of this document.</t>

<t>In any case, clients MUST provide a configuration interface to allow a user to
specify (by address or name) and/or constrain (by certificate property) a
preferred/trusted oracle. This would allow client on an untrusted network to
use an untrusted locally-available oracle to discover a preferred oracle
(doing key verification on its own for bootstrapping), before connecting to
that oracle for normal name resolution.</t>

</section>
<section anchor="transition-using-translation-between-rains-and-dns-information-models" title="Transition using translation between RAINS and DNS information models">

<t>Full adoption of RAINS would require changes to every client device (replacing
DNS stub resolvers with RAINS clients) and name server on the Internet. In
addition, most client software would need to change, as well, to get the full
benefits of explicit context in name resolution. This is a wholly unrealistic goal.</t>

<t>RAINS servers can, however, coexist with Domain Name System servers and
clients during an indefinite transition period. RAINS assertions can be
algorithmically translated into DNS answers, and RAINS queries can be
algorithmically translated into DNS queries, by RAINS to DNS gateways, given
the mostly compatible information models used by the two.</t>

<t>While DNSSEC and RAINS keys for equivalent ciphersuites are compatible with
each other, there is no equivalent to query option 7 for gateways, since the
RAINS signatures are generated over the RAINS bytestream for an assertion, not
the DNS bytestream. Therefore, RAINS to DNS gateways must provide verification
services for DNS clients. DNS over TLS <xref target="RFC7858"/> SHOULD be used between the
DNS client and gateway to ensure confidentiality and integrity for queries and
answers.</t>

<t>Object type mappings are as follows:</t>

<t><list style="symbols">
  <t>Objects of type name can (largely) be represented as CNAME RRs.</t>
  <t>Objects of type ip6-addr can be represented as AAAA RRs.</t>
  <t>Objects of type ip4-addr can be represented as A RRs.</t>
  <t>Objects of type redirection can be represented as NS RRs.</t>
  <t>Objects of type cert-info can be represented as TLSA RRs</t>
  <t>Objects of type service-info can be represented as SRV RRs.</t>
</list></t>

<t>There are a few object types without mappings:</t>

<t><list style="symbols">
  <t>Objects of type delegation can be represented as DS RRs, and signatures as
RRSIG RRs, but since these keys are verified by the gateway, there is no need
to represent this information to the client.</t>
  <t>Objects of type infrakey cannot be represented in DNS, but are irrelevant for
DNS translation of RAINS messages, since DNS does not support server signing
of responses.</t>
  <t>Objects of type registrar and registrant cannot be represented in DNS; clients
can use WHOIS instead. In addition, RRTYPEs could be added for them in the
future if RAINS sees significant deployment with DNS as a front-end protocol.</t>
  <t>Objects of type nameset cannot be represented in DNS; the current equivalent
are the IDNA parameters maintained by IANA (for the DNS root zone only) at
https://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml.</t>
</list></t>

<t>When translating a DNS query from a client to a RAINS query for that client,
client options can be set on a per-server, per-client, or per-query basis
using some out of band configuration options.</t>

<t>When translating a RAINS assertion to a DNS answer, the gateway can use the
time to expiry for the verified signature as the TTL.</t>

<t>There is no method for exposing context information in a DNS query or answer.
Therefore, queries and answers at a RAINS gateway are only supported for the
global context “.”.</t>

</section>
</section>
<section anchor="experimental-design-and-evaluation" title="Experimental Design and Evaluation">

<t>The protocol described in this document is intended primarily as a prototype
for discussion, though the goal of the document is to specify RAINS completely
enough to allow independent, interoperable implementation of clients an
servers. The massive inertia behind the deployment of the present domain name
system makes full deployment as a replacement for DNS unlikely. Despite this,
there are some criteria by which the success of the RAINS experiment may be
judged:</t>

<t>First, deployment in simulated or closed networks, or in alternate Internet
architectures such as SCION, allows implementation experience with the
features of RAINS which DNS lacks (signatures as a first-order delegation
primitive, support for explicit contexts, explicit tradeoffs in queries,
runtime availability of registrar/registrant data, and nameset support),
which in turn may inform the specification and deployment of these features
on the present DNS.</t>

<t>Second, deployment of RAINS “islands” in the present Internet alongside DNS on
a per-domain basis would allow for comparison between operational and
implementation complexity and efficiency and benefits derived from RAINS’
features, as information for future development of the DNS protocol.</t>

</section>
<section anchor="iana-considerations" title="IANA Considerations">

<t>The present revision of this document has no actions for IANA.</t>

<t>The authors have registered the CBOR tag 15309736 to identify RAINS messages
in the CBOR tag registry at 
https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml.</t>

<t>RAINS servers currently listen for connections from other servers on Port
1022. Future revisions of this document may specify a different port,
registered with IANA via Expert Review <xref target="RFC5226"/>.</t>

<t>The symbol table in this document in <xref target="cbor-symtab"/>, the notification code
table in <xref target="cbor-notification"/>, and the signature algorithm table in 
<xref target="cbor-signature"/> may be candidates for IANA registries in future revisions 
of this document.</t>

<t>The urn:x-rains namespace used by the RAINS capability mechanism in 
<xref target="cbor-capabilities"/> may be a candidate for replacement with an IANA-registered
namespace in a future revision of this document.</t>

</section>
<section anchor="security-considerations" title="Security Considerations">

<t>This document specifies a new, experimental protocol for Internet name
resolution, with mandatory integrity protection for assertions about names
built into the information model, and confidentiality for query information
protected on a hop-by-hop basis. See especially <xref target="signatures-in-assertions"/>,
<xref target="integrity-and-confidentiality-protection"/>, <xref target="cbor-signature"/>, 
<xref target="cbor-certinfo"/>, and <xref target="secret-key-management"/> for security-relevant 
details.</t>

</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>Thanks to Daniele Asoni, Laurent Chuat, Markus Deshon, Ted Hardie, Joe
Hildebrand, Tobias Klausmann, Steve Matsumoto, Adrian Perrig, Raphael
Reischuk, Stephen Shirley, Andrew Sullivan, and Suzanne Woolf for the
discussions leading to the design of this protocol.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>





<reference anchor='I-D.trammell-inip-pins'>
<front>
<title>Properties of an Ideal Naming Service</title>

<author initials='B' surname='Trammell' fullname='Brian Trammell'>
    <organization />
</author>

<date month='September' day='6' year='2016' />

<abstract><t>This document specifies a set of necessary functions and desirable properties of an ideal system for resolving names to addresses and associated information for establishing communication associations in the Internet.  For each property, it briefly explains the rationale behind it, and how the property is or could be met with the present Domain Name System.  It is intended to start a discussion within the IAB's Names and Identifiers program about gaps between the present reality of DNS and the naming service the Internet needs by returning to first principles.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-trammell-inip-pins-02' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-trammell-inip-pins-02.txt' />
</reference>



<reference  anchor='RFC0793' target='http://www.rfc-editor.org/info/rfc793'>
<front>
<title>Transmission Control Protocol</title>
<author initials='J.' surname='Postel' fullname='J. Postel'><organization /></author>
<date year='1981' month='September' />
</front>
<seriesInfo name='STD' value='7'/>
<seriesInfo name='RFC' value='793'/>
<seriesInfo name='DOI' value='10.17487/RFC0793'/>
</reference>



<reference  anchor='RFC1918' target='http://www.rfc-editor.org/info/rfc1918'>
<front>
<title>Address Allocation for Private Internets</title>
<author initials='Y.' surname='Rekhter' fullname='Y. Rekhter'><organization /></author>
<author initials='B.' surname='Moskowitz' fullname='B. Moskowitz'><organization /></author>
<author initials='D.' surname='Karrenberg' fullname='D. Karrenberg'><organization /></author>
<author initials='G. J.' surname='de Groot' fullname='G. J. de Groot'><organization /></author>
<author initials='E.' surname='Lear' fullname='E. Lear'><organization /></author>
<date year='1996' month='February' />
<abstract><t>This document describes address allocation for private internets.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='5'/>
<seriesInfo name='RFC' value='1918'/>
<seriesInfo name='DOI' value='10.17487/RFC1918'/>
</reference>



<reference  anchor='RFC2119' target='http://www.rfc-editor.org/info/rfc2119'>
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials='S.' surname='Bradner' fullname='S. Bradner'><organization /></author>
<date year='1997' month='March' />
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='14'/>
<seriesInfo name='RFC' value='2119'/>
<seriesInfo name='DOI' value='10.17487/RFC2119'/>
</reference>



<reference  anchor='RFC2782' target='http://www.rfc-editor.org/info/rfc2782'>
<front>
<title>A DNS RR for specifying the location of services (DNS SRV)</title>
<author initials='A.' surname='Gulbrandsen' fullname='A. Gulbrandsen'><organization /></author>
<author initials='P.' surname='Vixie' fullname='P. Vixie'><organization /></author>
<author initials='L.' surname='Esibov' fullname='L. Esibov'><organization /></author>
<date year='2000' month='February' />
<abstract><t>This document describes a DNS RR which specifies the location of the server(s) for a specific protocol and domain.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='2782'/>
<seriesInfo name='DOI' value='10.17487/RFC2782'/>
</reference>



<reference  anchor='RFC3629' target='http://www.rfc-editor.org/info/rfc3629'>
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials='F.' surname='Yergeau' fullname='F. Yergeau'><organization /></author>
<date year='2003' month='November' />
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name='STD' value='63'/>
<seriesInfo name='RFC' value='3629'/>
<seriesInfo name='DOI' value='10.17487/RFC3629'/>
</reference>



<reference  anchor='RFC4193' target='http://www.rfc-editor.org/info/rfc4193'>
<front>
<title>Unique Local IPv6 Unicast Addresses</title>
<author initials='R.' surname='Hinden' fullname='R. Hinden'><organization /></author>
<author initials='B.' surname='Haberman' fullname='B. Haberman'><organization /></author>
<date year='2005' month='October' />
<abstract><t>This document defines an IPv6 unicast address format that is globally unique and is intended for local communications, usually inside of a site. These addresses are not expected to be routable on the global Internet.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4193'/>
<seriesInfo name='DOI' value='10.17487/RFC4193'/>
</reference>



<reference  anchor='RFC4727' target='http://www.rfc-editor.org/info/rfc4727'>
<front>
<title>Experimental Values In IPv4, IPv6, ICMPv4, ICMPv6, UDP, and TCP Headers</title>
<author initials='B.' surname='Fenner' fullname='B. Fenner'><organization /></author>
<date year='2006' month='November' />
<abstract><t>When experimenting with or extending protocols, it is often necessary to use some sort of protocol number or constant in order to actually test or experiment with the new function, even when testing in a closed environment.  This document reserves some ranges of numbers for experimentation purposes in specific protocols where the need to support experimentation has been identified, and it describes the numbers that have already been reserved by other documents.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4727'/>
<seriesInfo name='DOI' value='10.17487/RFC4727'/>
</reference>



<reference  anchor='RFC5246' target='http://www.rfc-editor.org/info/rfc5246'>
<front>
<title>The Transport Layer Security (TLS) Protocol Version 1.2</title>
<author initials='T.' surname='Dierks' fullname='T. Dierks'><organization /></author>
<author initials='E.' surname='Rescorla' fullname='E. Rescorla'><organization /></author>
<date year='2008' month='August' />
<abstract><t>This document specifies Version 1.2 of the Transport Layer Security (TLS) protocol.  The TLS protocol provides communications security over the Internet.  The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5246'/>
<seriesInfo name='DOI' value='10.17487/RFC5246'/>
</reference>



<reference  anchor='RFC5280' target='http://www.rfc-editor.org/info/rfc5280'>
<front>
<title>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</title>
<author initials='D.' surname='Cooper' fullname='D. Cooper'><organization /></author>
<author initials='S.' surname='Santesson' fullname='S. Santesson'><organization /></author>
<author initials='S.' surname='Farrell' fullname='S. Farrell'><organization /></author>
<author initials='S.' surname='Boeyen' fullname='S. Boeyen'><organization /></author>
<author initials='R.' surname='Housley' fullname='R. Housley'><organization /></author>
<author initials='W.' surname='Polk' fullname='W. Polk'><organization /></author>
<date year='2008' month='May' />
<abstract><t>This memo profiles the X.509 v3 certificate and X.509 v2 certificate revocation list (CRL) for use in the Internet.  An overview of this approach and model is provided as an introduction.  The X.509 v3 certificate format is described in detail, with additional information regarding the format and semantics of Internet name forms.  Standard certificate extensions are described and two Internet-specific extensions are defined.  A set of required certificate extensions is specified.  The X.509 v2 CRL format is described in detail along with standard and Internet-specific extensions.  An algorithm for X.509 certification path validation is described.  An ASN.1 module and examples are provided in the appendices.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5280'/>
<seriesInfo name='DOI' value='10.17487/RFC5280'/>
</reference>



<reference  anchor='RFC7049' target='http://www.rfc-editor.org/info/rfc7049'>
<front>
<title>Concise Binary Object Representation (CBOR)</title>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<date year='2013' month='October' />
<abstract><t>The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation.  These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.</t></abstract>
</front>
<seriesInfo name='RFC' value='7049'/>
<seriesInfo name='DOI' value='10.17487/RFC7049'/>
</reference>


<reference anchor="FIPS-186-3" >
  <front>
    <title>Digital Signature Standard FIPS 186-3</title>
    <author initials="." surname="NIST">
      <organization></organization>
    </author>
    <date year="2009" month="June"/>
  </front>
</reference>


    </references>

    <references title='Informative References'>





<reference  anchor='RFC1035' target='http://www.rfc-editor.org/info/rfc1035'>
<front>
<title>Domain names - implementation and specification</title>
<author initials='P.V.' surname='Mockapetris' fullname='P.V. Mockapetris'><organization /></author>
<date year='1987' month='November' />
<abstract><t>This RFC is the revised specification of the protocol and format used in the implementation of the Domain Name System.  It obsoletes RFC-883. This memo documents the details of the domain name client - server communication.</t></abstract>
</front>
<seriesInfo name='STD' value='13'/>
<seriesInfo name='RFC' value='1035'/>
<seriesInfo name='DOI' value='10.17487/RFC1035'/>
</reference>



<reference  anchor='RFC4291' target='http://www.rfc-editor.org/info/rfc4291'>
<front>
<title>IP Version 6 Addressing Architecture</title>
<author initials='R.' surname='Hinden' fullname='R. Hinden'><organization /></author>
<author initials='S.' surname='Deering' fullname='S. Deering'><organization /></author>
<date year='2006' month='February' />
<abstract><t>This specification defines the addressing architecture of the IP Version 6 (IPv6) protocol.  The document includes the IPv6 addressing model, text representations of IPv6 addresses, definition of IPv6 unicast addresses, anycast addresses, and multicast addresses, and an IPv6 node's required addresses.</t><t>This document obsoletes RFC 3513, &quot;IP Version 6 Addressing Architecture&quot;.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='4291'/>
<seriesInfo name='DOI' value='10.17487/RFC4291'/>
</reference>



<reference  anchor='RFC4632' target='http://www.rfc-editor.org/info/rfc4632'>
<front>
<title>Classless Inter-domain Routing (CIDR): The Internet Address Assignment and Aggregation Plan</title>
<author initials='V.' surname='Fuller' fullname='V. Fuller'><organization /></author>
<author initials='T.' surname='Li' fullname='T. Li'><organization /></author>
<date year='2006' month='August' />
<abstract><t>This memo discusses the strategy for address assignment of the existing 32-bit IPv4 address space with a view toward conserving the address space and limiting the growth rate of global routing state. This document obsoletes the original Classless Inter-domain Routing (CIDR) spec in RFC 1519, with changes made both to clarify the concepts it introduced and, after more than twelve years, to update the Internet community on the results of deploying the technology described.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='122'/>
<seriesInfo name='RFC' value='4632'/>
<seriesInfo name='DOI' value='10.17487/RFC4632'/>
</reference>



<reference  anchor='RFC5226' target='http://www.rfc-editor.org/info/rfc5226'>
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials='T.' surname='Narten' fullname='T. Narten'><organization /></author>
<author initials='H.' surname='Alvestrand' fullname='H. Alvestrand'><organization /></author>
<date year='2008' month='May' />
<abstract><t>Many protocols make use of identifiers consisting of constants and other well-known values.  Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec).  To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority.  For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).</t><t>In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made.  If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role.  This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.</t><t>This document obsoletes RFC 2434.  This document specifies an Internet Best  Current Practices for the Internet Community, and requests discussion and  suggestions for improvements.</t></abstract>
</front>
<seriesInfo name='BCP' value='26'/>
<seriesInfo name='RFC' value='5226'/>
<seriesInfo name='DOI' value='10.17487/RFC5226'/>
</reference>



<reference  anchor='RFC5905' target='http://www.rfc-editor.org/info/rfc5905'>
<front>
<title>Network Time Protocol Version 4: Protocol and Algorithms Specification</title>
<author initials='D.' surname='Mills' fullname='D. Mills'><organization /></author>
<author initials='J.' surname='Martin' fullname='J. Martin' role='editor'><organization /></author>
<author initials='J.' surname='Burbank' fullname='J. Burbank'><organization /></author>
<author initials='W.' surname='Kasch' fullname='W. Kasch'><organization /></author>
<date year='2010' month='June' />
<abstract><t>The Network Time Protocol (NTP) is widely used to synchronize computer clocks in the Internet.  This document describes NTP version 4 (NTPv4), which is backwards compatible with NTP version 3 (NTPv3), described in RFC 1305, as well as previous versions of the protocol. NTPv4 includes a modified protocol header to accommodate the Internet Protocol version 6 address family.  NTPv4 includes fundamental improvements in the mitigation and discipline algorithms that extend the potential accuracy to the tens of microseconds with modern workstations and fast LANs.  It includes a dynamic server discovery scheme, so that in many cases, specific server configuration is not required.  It corrects certain errors in the NTPv3 design and implementation and includes an optional extension mechanism.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='5905'/>
<seriesInfo name='DOI' value='10.17487/RFC5905'/>
</reference>



<reference  anchor='RFC6605' target='http://www.rfc-editor.org/info/rfc6605'>
<front>
<title>Elliptic Curve Digital Signature Algorithm (DSA) for DNSSEC</title>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<author initials='W.C.A.' surname='Wijngaards' fullname='W.C.A. Wijngaards'><organization /></author>
<date year='2012' month='April' />
<abstract><t>This document describes how to specify Elliptic Curve Digital Signature Algorithm (DSA) keys and signatures in DNS Security (DNSSEC).  It lists curves of different sizes and uses the SHA-2 family of hashes for signatures.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6605'/>
<seriesInfo name='DOI' value='10.17487/RFC6605'/>
</reference>



<reference  anchor='RFC6698' target='http://www.rfc-editor.org/info/rfc6698'>
<front>
<title>The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA</title>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<author initials='J.' surname='Schlyter' fullname='J. Schlyter'><organization /></author>
<date year='2012' month='August' />
<abstract><t>Encrypted communication on the Internet often uses Transport Layer Security (TLS), which depends on third parties to certify the keys used.  This document improves on that situation by enabling the administrators of domain names to specify the keys used in that domain's TLS servers.  This requires matching improvements in TLS client software, but no change in TLS server software.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name='RFC' value='6698'/>
<seriesInfo name='DOI' value='10.17487/RFC6698'/>
</reference>



<reference  anchor='RFC7231' target='http://www.rfc-editor.org/info/rfc7231'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name='RFC' value='7231'/>
<seriesInfo name='DOI' value='10.17487/RFC7231'/>
</reference>



<reference  anchor='RFC7624' target='http://www.rfc-editor.org/info/rfc7624'>
<front>
<title>Confidentiality in the Face of Pervasive Surveillance: A Threat Model and Problem Statement</title>
<author initials='R.' surname='Barnes' fullname='R. Barnes'><organization /></author>
<author initials='B.' surname='Schneier' fullname='B. Schneier'><organization /></author>
<author initials='C.' surname='Jennings' fullname='C. Jennings'><organization /></author>
<author initials='T.' surname='Hardie' fullname='T. Hardie'><organization /></author>
<author initials='B.' surname='Trammell' fullname='B. Trammell'><organization /></author>
<author initials='C.' surname='Huitema' fullname='C. Huitema'><organization /></author>
<author initials='D.' surname='Borkmann' fullname='D. Borkmann'><organization /></author>
<date year='2015' month='August' />
<abstract><t>Since the initial revelations of pervasive surveillance in 2013, several classes of attacks on Internet communications have been discovered.  In this document, we develop a threat model that describes these attacks on Internet confidentiality.  We assume an attacker that is interested in undetected, indiscriminate eavesdropping.  The threat model is based on published, verified attacks.</t></abstract>
</front>
<seriesInfo name='RFC' value='7624'/>
<seriesInfo name='DOI' value='10.17487/RFC7624'/>
</reference>



<reference  anchor='RFC7696' target='http://www.rfc-editor.org/info/rfc7696'>
<front>
<title>Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms</title>
<author initials='R.' surname='Housley' fullname='R. Housley'><organization /></author>
<date year='2015' month='November' />
<abstract><t>Many IETF protocols use cryptographic algorithms to provide confidentiality, integrity, authentication, or digital signature.  Communicating peers must support a common set of cryptographic algorithms for these mechanisms to work properly.  This memo provides guidelines to ensure that protocols have the ability to migrate from one mandatory-to-implement algorithm suite to another over time.</t></abstract>
</front>
<seriesInfo name='BCP' value='201'/>
<seriesInfo name='RFC' value='7696'/>
<seriesInfo name='DOI' value='10.17487/RFC7696'/>
</reference>



<reference  anchor='RFC7858' target='http://www.rfc-editor.org/info/rfc7858'>
<front>
<title>Specification for DNS over Transport Layer Security (TLS)</title>
<author initials='Z.' surname='Hu' fullname='Z. Hu'><organization /></author>
<author initials='L.' surname='Zhu' fullname='L. Zhu'><organization /></author>
<author initials='J.' surname='Heidemann' fullname='J. Heidemann'><organization /></author>
<author initials='A.' surname='Mankin' fullname='A. Mankin'><organization /></author>
<author initials='D.' surname='Wessels' fullname='D. Wessels'><organization /></author>
<author initials='P.' surname='Hoffman' fullname='P. Hoffman'><organization /></author>
<date year='2016' month='May' />
<abstract><t>This document describes the use of Transport Layer Security (TLS) to provide privacy for DNS.  Encryption provided by TLS eliminates opportunities for eavesdropping and on-path tampering with DNS queries in the network, such as discussed in RFC 7626.  In addition, this document specifies two usage profiles for DNS over TLS and provides advice on performance considerations to minimize overhead from using TCP and TLS with DNS.</t><t>This document focuses on securing stub-to-recursive traffic, as per the charter of the DPRIVE Working Group.  It does not prevent future applications of the protocol to recursive-to-authoritative traffic.</t></abstract>
</front>
<seriesInfo name='RFC' value='7858'/>
<seriesInfo name='DOI' value='10.17487/RFC7858'/>
</reference>



<reference  anchor='RFC7871' target='http://www.rfc-editor.org/info/rfc7871'>
<front>
<title>Client Subnet in DNS Queries</title>
<author initials='C.' surname='Contavalli' fullname='C. Contavalli'><organization /></author>
<author initials='W.' surname='van der Gaast' fullname='W. van der Gaast'><organization /></author>
<author initials='D.' surname='Lawrence' fullname='D. Lawrence'><organization /></author>
<author initials='W.' surname='Kumari' fullname='W. Kumari'><organization /></author>
<date year='2016' month='May' />
<abstract><t>This document describes an Extension Mechanisms for DNS (EDNS0) option that is in active use to carry information about the network that originated a DNS query and the network for which the subsequent response can be cached.  Since it has some known operational and privacy shortcomings, a revision will be worked through the IETF for improvement.</t></abstract>
</front>
<seriesInfo name='RFC' value='7871'/>
<seriesInfo name='DOI' value='10.17487/RFC7871'/>
</reference>


<reference anchor="XEP0115" >
  <front>
    <title>XEP-0115 Entity Capababilities</title>
    <author initials="J." surname="Hildebrand">
      <organization></organization>
    </author>
    <author initials="P." surname="Saint-Andre">
      <organization></organization>
    </author>
    <author initials="R." surname="Troncon">
      <organization></organization>
    </author>
    <author initials="J." surname="Konieczny">
      <organization></organization>
    </author>
    <date year="2008" month="February" day="26"/>
  </front>
</reference>
<reference anchor="SCION" >
  <front>
    <title>SCION Five Years Later - Revisiting Scalability, Control, and Isolation Next-Generation Networks (arXiv:1508.01651v1)</title>
    <author initials="D." surname="Barrera">
      <organization></organization>
    </author>
    <author initials="R." surname="Reischuk">
      <organization></organization>
    </author>
    <author initials="P." surname="Szalachowski">
      <organization></organization>
    </author>
    <author initials="A." surname="Perrig">
      <organization></organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>
<reference anchor="PARSER-BUGS" >
  <front>
    <title>The Bugs We Have To Kill (USENIX login)</title>
    <author initials="S." surname="Bratus">
      <organization></organization>
    </author>
    <author initials="M." surname="Patterson">
      <organization></organization>
    </author>
    <author initials="A." surname="Shubina">
      <organization></organization>
    </author>
    <date year="2015" month="August"/>
  </front>
</reference>


    </references>


<section anchor="directions-for-future-experimentation" title="Directions for future experimentation">

<t>The following features were suggested during the design of RAINS, but have
been left out of the current revision of the specification to allow additional
experimentation with them before they are completely specified.</t>

<section anchor="hash-chain-rev" title="Revocation based on hash chains">

<t>RAINS assertions are scoped in temporal validity by the lifetimes on their
signatures. This is operationally equivalent to TTL in the current DNS. An
assertion which becomes invalid can simply not be renewed by its authority.
However, very dynamic infrastructures may require impractical numbers of
signatures, and could benefit from longer validity times. Allowing an
assertion to be revoked would make this possible.</t>

<t>Hash-chain based revocation allows a signature (and the Assertion, Shard, or
Zone it protects) to be replaced before it expires. To use hash-chain based
revocation, a signing entity generates a hash chain from a known seed using
the hash function specified by the signature algorithm in use, and places the
Nth value derived therefrom in the hash chain revocation token on a signature.
When used, this token appears as a byte array after the signature data in the
signature array.</t>

<t>A revocation can be issued by generating a new section and signing it,
revealing the N-1st value from the hash chain in the revocation token. To
allow a recipient of a revoked section to verify the revocation, the following
restrictions on what can replace what apply:</t>

<t><list style="symbols">
  <t>An Assertion can only be replaced by another Assertion with the same 
Subject within the same Context and Zone, containing an Objects array 
of the same length containing the same types of Objects. To delete Object 
values, those values can be replaced with Null in the replacing Assertion.</t>
  <t>A Shard can only be replaced by another Shard with an identical shard-range 
key, within the same Context and Zone. Incomplete Shards cannot be replaced.</t>
  <t>A Zone can only be replaced by another Zone with an identical name within 
the same Context.</t>
</list></t>

<t>Two codepoints have been reserved to support experimentation with this mechanism, as shown in <xref target="tabsigrev"/>.</t>

<texttable title="Defined signature algorithms" anchor="tabsigrev">
      <ttcol align='right'>Code</ttcol>
      <ttcol align='left'>Signatures</ttcol>
      <ttcol align='left'>Hash/HMAC</ttcol>
      <ttcol align='left'>Format</ttcol>
      <ttcol align='left'>Revocation</ttcol>
      <c>23</c>
      <c>ecdsa-256</c>
      <c>sha-256</c>
      <c>See <xref target="ecdsa-format"/></c>
      <c>hash-chain</c>
      <c>24</c>
      <c>ecdsa-384</c>
      <c>sha-384</c>
      <c>See <xref target="ecdsa-format"/></c>
      <c>hash-chain</c>
</texttable>

<t>The main open question for experimentation is how to ensure that a revocation
is properly propagated through a RAINS infrastructure; this may require
protocol changes to work reliably.</t>

<t>To support this experiment, a server must additionally evaluate an assertion
it receives to determine whether it replaces any information presently in its
cache. If so, it discards the old information, and caches the new section.</t>

</section>
</section>
<section anchor="open-issues" title="Open Issues">

<t><list style="symbols">
  <t>A method for clients to discover local oracles needs to be specified.</t>
  <t>Reverse DNS must be added. Instead of in-addr.arpa., the RAINS facility
should treat reverse lookups as first-order, with subject-addr instead of
subject-name in assertions and queries.</t>
  <t>Consider making negative answers less expensive by allowing a hash of a
shard with a negative answer proof to be sent back, and checked with a “no
hashed negative answers” query option. This would increase complexity
somewhat, because it would require the (re-)addition of an Answer section,
which could contain such a beast.</t>
  <t>Consider adding semantics to note-data for automated reaction to an error.
Specifically, notification codes 400, 403, and 413 could use additional data.</t>
</list></t>

</section>


  </back>
</rfc>

