<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>RAINS (Another Internet Naming Service) Protocol Specification</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract p {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre {
  font: 15px Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
/*]]>*/</style>
<meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 About This Document">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 An Ideal Internet Naming Service">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Interfaces">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Properties">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 Meaningfulness">
<link href="#rfc.section.3.2.2" rel="Chapter" title="3.2.2 Distinguishability">
<link href="#rfc.section.3.2.3" rel="Chapter" title="3.2.3 Minimal Structure">
<link href="#rfc.section.3.2.4" rel="Chapter" title="3.2.4 Federation of Authority">
<link href="#rfc.section.3.2.5" rel="Chapter" title="3.2.5 Uniqueness of Authority">
<link href="#rfc.section.3.2.6" rel="Chapter" title="3.2.6 Transparency of Authority">
<link href="#rfc.section.3.2.7" rel="Chapter" title="3.2.7 Revocability of Authority">
<link href="#rfc.section.3.2.8" rel="Chapter" title="3.2.8 Consensus on Root of Authority">
<link href="#rfc.section.3.2.9" rel="Chapter" title="3.2.9 Authenticity of Delegation">
<link href="#rfc.section.3.2.10" rel="Chapter" title="3.2.10 Authenticity of Response">
<link href="#rfc.section.3.2.11" rel="Chapter" title="3.2.11 Authenticity of Negative Response">
<link href="#rfc.section.3.2.12" rel="Chapter" title="3.2.12 Dynamic Consistency">
<link href="#rfc.section.3.2.13" rel="Chapter" title="3.2.13 Explicit Inconsistency">
<link href="#rfc.section.3.2.14" rel="Chapter" title="3.2.14 Global Invariance">
<link href="#rfc.section.3.2.15" rel="Chapter" title="3.2.15 Availability">
<link href="#rfc.section.3.2.16" rel="Chapter" title="3.2.16 Lookup Latency">
<link href="#rfc.section.3.2.17" rel="Chapter" title="3.2.17 Bandwidth Efficiency">
<link href="#rfc.section.3.2.18" rel="Chapter" title="3.2.18 Query Linkability">
<link href="#rfc.section.3.2.19" rel="Chapter" title="3.2.19 Explicit Tradeoff">
<link href="#rfc.section.3.2.20" rel="Chapter" title="3.2.20 Trust in Infrastructure">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Observations">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Delegation and redirection are separate operations">
<link href="#rfc.section.3.3.2" rel="Chapter" title="3.3.2 Unicode alone may not be sufficient for distinguishable names">
<link href="#rfc.section.3.3.3" rel="Chapter" title="3.3.3 Implicit inconsistency makes global invariance challenging to verify">
<link href="#rfc.section.4" rel="Chapter" title="4 Architecture">
<link href="#rfc.section.5" rel="Chapter" title="5 Information Model">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Assertion">
<link href="#rfc.section.5.1.1" rel="Chapter" title="5.1.1 Context in Assertions">
<link href="#rfc.section.5.1.2" rel="Chapter" title="5.1.2 Signatures in Assertions">
<link href="#rfc.section.5.1.3" rel="Chapter" title="5.1.3 Semantic of nonexistence proofs">
<link href="#rfc.section.5.1.4" rel="Chapter" title="5.1.4 Shards and Probabilistic Shards (P-Shards)">
<link href="#rfc.section.6" rel="Chapter" title="6 Zone">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Zone-Reflexive Assertions">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Query">
<link href="#rfc.section.6.2.1" rel="Chapter" title="6.2.1 Context in Queries">
<link href="#rfc.section.6.2.2" rel="Chapter" title="6.2.2 Answers to Queries">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Assertion Update Query">
<link href="#rfc.section.6.3.1" rel="Chapter" title="6.3.1 Answers to Assertion Update Queries">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Nonexistence Update Query">
<link href="#rfc.section.6.4.1" rel="Chapter" title="6.4.1 Answers to Nonexistence Update Queries">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Address to Object Mapping">
<link href="#rfc.section.6.5.1" rel="Chapter" title="6.5.1 Context in Address Assertions">
<link href="#rfc.section.7" rel="Chapter" title="7 CBOR Data Model">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Symbol Table">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Message">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Message Section header">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Assertion body">
<link href="#rfc.section.7.4.1" rel="Chapter" title="7.4.1 Sorting Assertions">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Shard body">
<link href="#rfc.section.7.5.1" rel="Chapter" title="7.5.1 Sorting Shards">
<link href="#rfc.section.7.6" rel="Chapter" title="7.6 P-Shard body">
<link href="#rfc.section.7.6.1" rel="Chapter" title="7.6.1 Sorting P-Shard">
<link href="#rfc.section.7.7" rel="Chapter" title="7.7 Zone body">
<link href="#rfc.section.7.8" rel="Chapter" title="7.8 Query body">
<link href="#rfc.section.7.9" rel="Chapter" title="7.9 Assertion Update Query body">
<link href="#rfc.section.7.10" rel="Chapter" title="7.10 Nonexistence Update Query body">
<link href="#rfc.section.7.11" rel="Chapter" title="7.11 Address Assertion body">
<link href="#rfc.section.7.12" rel="Chapter" title="7.12 Address Query body">
<link href="#rfc.section.7.13" rel="Chapter" title="7.13 Notification body">
<link href="#rfc.section.7.14" rel="Chapter" title="7.14 Object">
<link href="#rfc.section.7.14.1" rel="Chapter" title="7.14.1 Certificate information format">
<link href="#rfc.section.7.14.2" rel="Chapter" title="7.14.2 Name expression format">
<link href="#rfc.section.7.15" rel="Chapter" title="7.15 Data structures">
<link href="#rfc.section.7.15.1" rel="Chapter" title="7.15.1 Bloom Filter Bit String">
<link href="#rfc.section.7.16" rel="Chapter" title="7.16 Tokens in queries and messages">
<link href="#rfc.section.7.17" rel="Chapter" title="7.17 Signatures, delegation keys, and RAINS infrastructure keys">
<link href="#rfc.section.7.17.1" rel="Chapter" title="7.17.1 EdDSA signature and public key format">
<link href="#rfc.section.7.17.2" rel="Chapter" title="7.17.2 ECDSA signature and public key format">
<link href="#rfc.section.7.18" rel="Chapter" title="7.18 Capabilities">
<link href="#rfc.section.8" rel="Chapter" title="8 Canonical signing format">
<link href="#rfc.section.9" rel="Chapter" title="9 RAINS Protocol Definition">
<link href="#rfc.section.9.1" rel="Chapter" title="9.1 Bootstrapping">
<link href="#rfc.section.9.2" rel="Chapter" title="9.2 Allowed Inconsistencies">
<link href="#rfc.section.9.3" rel="Chapter" title="9.3 Message processing">
<link href="#rfc.section.9.4" rel="Chapter" title="9.4 Message Transmission">
<link href="#rfc.section.9.5" rel="Chapter" title="9.5 Message Limits">
<link href="#rfc.section.9.6" rel="Chapter" title="9.6 Runtime Consistency Checking">
<link href="#rfc.section.9.7" rel="Chapter" title="9.7 Integrity and Confidentiality Protection">
<link href="#rfc.section.9.8" rel="Chapter" title="9.8 Cooperative Delegation Distribution">
<link href="#rfc.section.10" rel="Chapter" title="10 RAINS Client Protocol">
<link href="#rfc.section.11" rel="Chapter" title="11 RAINS Publication Protocol">
<link href="#rfc.section.12" rel="Chapter" title="12 Deployment Considerations">
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 Assertion Lifetime Management">
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Secret Key Management">
<link href="#rfc.section.12.3" rel="Chapter" title="12.3 Public Key Management">
<link href="#rfc.section.12.3.1" rel="Chapter" title="12.3.1 Key Phase and Key Rotation">
<link href="#rfc.section.12.3.2" rel="Chapter" title="12.3.2 Next Key Assertions">
<link href="#rfc.section.12.4" rel="Chapter" title="12.4 Unsigned Contained Assertions">
<link href="#rfc.section.12.5" rel="Chapter" title="12.5 Query Service Discovery">
<link href="#rfc.section.12.6" rel="Chapter" title="12.6 Transition using translation between RAINS and DNS information models">
<link href="#rfc.section.13" rel="Chapter" title="13 Experimental Design and Evaluation">
<link href="#rfc.section.14" rel="Chapter" title="14 IANA Considerations">
<link href="#rfc.section.15" rel="Chapter" title="15 Security Considerations">
<link href="#rfc.section.15.1" rel="Chapter" title="15.1 Server state exhaustion">
<link href="#rfc.section.15.2" rel="Chapter" title="15.2 Query relay attacks">
<link href="#rfc.section.16" rel="Chapter" title="16 Acknowledgments">
<link href="#rfc.references" rel="Chapter" title="17 References">
<link href="#rfc.references.1" rel="Chapter" title="17.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="17.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.10.3 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Trammell, B. and C. Fehlmann" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-trammell-rains-protocol-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-10-01" />
  <meta name="dct.abstract" content="This document defines an alternate protocol for Internet name resolution, designed as a prototype to facilitate conversation about the evolution or replacement of the Domain Name System protocol. It attempts to answer the question: &#8220;how would we design DNS knowing what we do now,&#8221; on the background of a set of properties of an idealized Internet naming service." />
  <meta name="description" content="This document defines an alternate protocol for Internet name resolution, designed as a prototype to facilitate conversation about the evolution or replacement of the Domain Name System protocol. It attempts to answer the question: &#8220;how would we design DNS knowing what we do now,&#8221; on the background of a set of properties of an idealized Internet naming service." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">B. Trammell</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">C. Fehlmann</td>
</tr>
<tr>
<td class="left">Intended status: Experimental</td>
<td class="right">ETH Zurich</td>
</tr>
<tr>
<td class="left">Expires: April 4, 2019</td>
<td class="right">October 01, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">RAINS (Another Internet Naming Service) Protocol Specification<br />
  <span class="filename">draft-trammell-rains-protocol-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines an alternate protocol for Internet name resolution, designed as a prototype to facilitate conversation about the evolution or replacement of the Domain Name System protocol. It attempts to answer the question: &#8220;how would we design DNS knowing what we do now,&#8221; on the background of a set of properties of an idealized Internet naming service.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on April 4, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">About This Document</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">An Ideal Internet Naming Service</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Interfaces</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Properties</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">Meaningfulness</a>
</li>
<li>3.2.2.   <a href="#rfc.section.3.2.2">Distinguishability</a>
</li>
<li>3.2.3.   <a href="#rfc.section.3.2.3">Minimal Structure</a>
</li>
<li>3.2.4.   <a href="#rfc.section.3.2.4">Federation of Authority</a>
</li>
<li>3.2.5.   <a href="#rfc.section.3.2.5">Uniqueness of Authority</a>
</li>
<li>3.2.6.   <a href="#rfc.section.3.2.6">Transparency of Authority</a>
</li>
<li>3.2.7.   <a href="#rfc.section.3.2.7">Revocability of Authority</a>
</li>
<li>3.2.8.   <a href="#rfc.section.3.2.8">Consensus on Root of Authority</a>
</li>
<li>3.2.9.   <a href="#rfc.section.3.2.9">Authenticity of Delegation</a>
</li>
<li>3.2.10.   <a href="#rfc.section.3.2.10">Authenticity of Response</a>
</li>
<li>3.2.11.   <a href="#rfc.section.3.2.11">Authenticity of Negative Response</a>
</li>
<li>3.2.12.   <a href="#rfc.section.3.2.12">Dynamic Consistency</a>
</li>
<li>3.2.13.   <a href="#rfc.section.3.2.13">Explicit Inconsistency</a>
</li>
<li>3.2.14.   <a href="#rfc.section.3.2.14">Global Invariance</a>
</li>
<li>3.2.15.   <a href="#rfc.section.3.2.15">Availability</a>
</li>
<li>3.2.16.   <a href="#rfc.section.3.2.16">Lookup Latency</a>
</li>
<li>3.2.17.   <a href="#rfc.section.3.2.17">Bandwidth Efficiency</a>
</li>
<li>3.2.18.   <a href="#rfc.section.3.2.18">Query Linkability</a>
</li>
<li>3.2.19.   <a href="#rfc.section.3.2.19">Explicit Tradeoff</a>
</li>
<li>3.2.20.   <a href="#rfc.section.3.2.20">Trust in Infrastructure</a>
</li>
</ul><li>3.3.   <a href="#rfc.section.3.3">Observations</a>
</li>
<ul><li>3.3.1.   <a href="#rfc.section.3.3.1">Delegation and redirection are separate operations</a>
</li>
<li>3.3.2.   <a href="#rfc.section.3.3.2">Unicode alone may not be sufficient for distinguishable names</a>
</li>
<li>3.3.3.   <a href="#rfc.section.3.3.3">Implicit inconsistency makes global invariance challenging to verify</a>
</li>
</ul></ul><li>4.   <a href="#rfc.section.4">Architecture</a>
</li>
<li>5.   <a href="#rfc.section.5">Information Model</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Assertion</a>
</li>
<ul><li>5.1.1.   <a href="#rfc.section.5.1.1">Context in Assertions</a>
</li>
<li>5.1.2.   <a href="#rfc.section.5.1.2">Signatures in Assertions</a>
</li>
<li>5.1.3.   <a href="#rfc.section.5.1.3">Semantic of nonexistence proofs</a>
</li>
<li>5.1.4.   <a href="#rfc.section.5.1.4">Shards and Probabilistic Shards (P-Shards)</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Zone</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Zone-Reflexive Assertions</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Query</a>
</li>
<ul><li>6.2.1.   <a href="#rfc.section.6.2.1">Context in Queries</a>
</li>
<li>6.2.2.   <a href="#rfc.section.6.2.2">Answers to Queries</a>
</li>
</ul><li>6.3.   <a href="#rfc.section.6.3">Assertion Update Query</a>
</li>
<ul><li>6.3.1.   <a href="#rfc.section.6.3.1">Answers to Assertion Update Queries</a>
</li>
</ul><li>6.4.   <a href="#rfc.section.6.4">Nonexistence Update Query</a>
</li>
<ul><li>6.4.1.   <a href="#rfc.section.6.4.1">Answers to Nonexistence Update Queries</a>
</li>
</ul><li>6.5.   <a href="#rfc.section.6.5">Address to Object Mapping</a>
</li>
<ul><li>6.5.1.   <a href="#rfc.section.6.5.1">Context in Address Assertions</a>
</li>
</ul></ul><li>7.   <a href="#rfc.section.7">CBOR Data Model</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Symbol Table</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Message</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Message Section header</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Assertion body</a>
</li>
<ul><li>7.4.1.   <a href="#rfc.section.7.4.1">Sorting Assertions</a>
</li>
</ul><li>7.5.   <a href="#rfc.section.7.5">Shard body</a>
</li>
<ul><li>7.5.1.   <a href="#rfc.section.7.5.1">Sorting Shards</a>
</li>
</ul><li>7.6.   <a href="#rfc.section.7.6">P-Shard body</a>
</li>
<ul><li>7.6.1.   <a href="#rfc.section.7.6.1">Sorting P-Shard</a>
</li>
</ul><li>7.7.   <a href="#rfc.section.7.7">Zone body</a>
</li>
<li>7.8.   <a href="#rfc.section.7.8">Query body</a>
</li>
<li>7.9.   <a href="#rfc.section.7.9">Assertion Update Query body</a>
</li>
<li>7.10.   <a href="#rfc.section.7.10">Nonexistence Update Query body</a>
</li>
<li>7.11.   <a href="#rfc.section.7.11">Address Assertion body</a>
</li>
<li>7.12.   <a href="#rfc.section.7.12">Address Query body</a>
</li>
<li>7.13.   <a href="#rfc.section.7.13">Notification body</a>
</li>
<li>7.14.   <a href="#rfc.section.7.14">Object</a>
</li>
<ul><li>7.14.1.   <a href="#rfc.section.7.14.1">Certificate information format</a>
</li>
<li>7.14.2.   <a href="#rfc.section.7.14.2">Name expression format</a>
</li>
</ul><li>7.15.   <a href="#rfc.section.7.15">Data structures</a>
</li>
<ul><li>7.15.1.   <a href="#rfc.section.7.15.1">Bloom Filter Bit String</a>
</li>
</ul><li>7.16.   <a href="#rfc.section.7.16">Tokens in queries and messages</a>
</li>
<li>7.17.   <a href="#rfc.section.7.17">Signatures, delegation keys, and RAINS infrastructure keys</a>
</li>
<ul><li>7.17.1.   <a href="#rfc.section.7.17.1">EdDSA signature and public key format</a>
</li>
<li>7.17.2.   <a href="#rfc.section.7.17.2">ECDSA signature and public key format</a>
</li>
</ul><li>7.18.   <a href="#rfc.section.7.18">Capabilities</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Canonical signing format</a>
</li>
<li>9.   <a href="#rfc.section.9">RAINS Protocol Definition</a>
</li>
<ul><li>9.1.   <a href="#rfc.section.9.1">Bootstrapping</a>
</li>
<li>9.2.   <a href="#rfc.section.9.2">Allowed Inconsistencies</a>
</li>
<li>9.3.   <a href="#rfc.section.9.3">Message processing</a>
</li>
<li>9.4.   <a href="#rfc.section.9.4">Message Transmission</a>
</li>
<li>9.5.   <a href="#rfc.section.9.5">Message Limits</a>
</li>
<li>9.6.   <a href="#rfc.section.9.6">Runtime Consistency Checking</a>
</li>
<li>9.7.   <a href="#rfc.section.9.7">Integrity and Confidentiality Protection</a>
</li>
<li>9.8.   <a href="#rfc.section.9.8">Cooperative Delegation Distribution</a>
</li>
</ul><li>10.   <a href="#rfc.section.10">RAINS Client Protocol</a>
</li>
<li>11.   <a href="#rfc.section.11">RAINS Publication Protocol</a>
</li>
<li>12.   <a href="#rfc.section.12">Deployment Considerations</a>
</li>
<ul><li>12.1.   <a href="#rfc.section.12.1">Assertion Lifetime Management</a>
</li>
<li>12.2.   <a href="#rfc.section.12.2">Secret Key Management</a>
</li>
<li>12.3.   <a href="#rfc.section.12.3">Public Key Management</a>
</li>
<ul><li>12.3.1.   <a href="#rfc.section.12.3.1">Key Phase and Key Rotation</a>
</li>
<li>12.3.2.   <a href="#rfc.section.12.3.2">Next Key Assertions</a>
</li>
</ul><li>12.4.   <a href="#rfc.section.12.4">Unsigned Contained Assertions</a>
</li>
<li>12.5.   <a href="#rfc.section.12.5">Query Service Discovery</a>
</li>
<li>12.6.   <a href="#rfc.section.12.6">Transition using translation between RAINS and DNS information models</a>
</li>
</ul><li>13.   <a href="#rfc.section.13">Experimental Design and Evaluation</a>
</li>
<li>14.   <a href="#rfc.section.14">IANA Considerations</a>
</li>
<li>15.   <a href="#rfc.section.15">Security Considerations</a>
</li>
<ul><li>15.1.   <a href="#rfc.section.15.1">Server state exhaustion</a>
</li>
<li>15.2.   <a href="#rfc.section.15.2">Query relay attacks</a>
</li>
</ul><li>16.   <a href="#rfc.section.16">Acknowledgments</a>
</li>
<li>17.   <a href="#rfc.references">References</a>
</li>
<ul><li>17.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>17.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">This document defines an experimental protocol for providing Internet name resolution services, as a replacement for DNS, called RAINS (RAINS, Another Internet Naming Service). It is designed as a prototype to facilitate conversation about the evolution or replacement of the Domain Name System protocol, and was developed as a name resolution system for the SCION (&#8220;Scalability, Control, and Isolation on Next-Generation Networks&#8221;) future Internet architecture <a href="#SCION" class="xref">[SCION]</a>. It attempts to answer the question: &#8220;how would we design the DNS knowing what we do now,&#8221; on the background of the properties of an ideal naming service defined in <a href="#pins" class="xref">Section 3</a>.</p>
<p id="rfc.section.1.p.2">Its architecture (<a href="#architecture" class="xref">Section 4</a>) and information model (<a href="#information-model" class="xref">Section 5</a>) are largely compatible with the existing Domain Name System. However, it does take several radical departures from DNS as presently defined and implemented:</p>
<p></p>

<ul>
<li>Delegation from a superordinate zone to a subordinate zone is done solely with cryptography: a superordinate defines the key(s) that are valid for signing assertions in the subordinate during a particular time interval.  Assertions about names can therefore safely be served from any infrastructure.</li>
<li>All time references in RAINS are absolute: instead of a time to live, each assertion&#8217;s temporal validity is defined by the temporal validity of the signature(s) on it.</li>
<li>All assertions have validity within a specific context. A context determines the rules for chaining signatures to verify validity of an assertion. The global context is a special case of context, which uses chains from the global naming root key. The use of context explicitly separates global usage of the DNS from local usage thereof, and allows other application-specific naming constraints to be bound to names; see <a href="#context-in-assertions" class="xref">Section 5.1.1</a>.  Queries are valid in one or more contexts, with specific rules for determining which assertions answer which queries; see <a href="#context-in-queries" class="xref">Section 6.2.1</a>.</li>
<li>There is an explicit separation between registrant-level names and sub-registrant-level names, and explicit information about registrars and registrants available in the naming system at runtime.</li>
<li>Sets of valid characters and rules for valid names are defined on a per-zone basis, and can be verified at runtime.</li>
<li>Reverse lookups are done using a completely separate tree, supporting delegations of any prefix length, in accordance with CIDR <a href="#RFC4632" class="xref">[RFC4632]</a> and the IPv6 addressing architecture <a href="#RFC4291" class="xref">[RFC4291]</a>.</li>
</ul>
<p id="rfc.section.1.p.4">Instead of using a custom binary framing as DNS, RAINS uses Concise Binary Object Representation <a href="#RFC7049" class="xref">[RFC7049]</a>, partially in an effort to make implementations easier to verify and less likely to contain potentially dangerous parser bugs <a href="#PARSER-BUGS" class="xref">[PARSER-BUGS]</a>. As with DNS, CBOR messages can be carried atop any number of substrate protocols. RAINS is presently defined to use TLS over persistent TCP connections (see <a href="#protocol-def" class="xref">Section 9</a>).</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#about-this-document" id="about-this-document">About This Document</a>
</h1>
<p id="rfc.section.1.1.p.1">The source of this document is available in the repository https://github.com/britram/rains-prototype, and a rendered working copy is available at https://britram.github.io/rains-prototype. Open issues can be seen and discussed at https://github.com/britram/rains-prototype/issues.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.2.p.1">The terms MUST, MUST NOT, SHOULD, SHOULD NOT, and MAY, when they appear in all-capitals, are to be interpreted as defined in <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<p id="rfc.section.2.p.2">In addition, the following terms are used in this document as defined:</p>
<p></p>

<ul>
<li>Subject: A name or address about which Assertions can be made.</li>
<li>Object: A type/value pair of information about a name within an Assertion.</li>
<li>Assertion: A mapping between a Subject and an Object, signed by the Authority for the namespace containing that Subject. See <a href="#assertion" class="xref">Section 5.1</a>.</li>
<li>Authority: An entity that has the right to determine which Assertions exist within its Zone</li>
<li>Delegation: An Assertion that an Authority has given the right to make assertions about the Assertions within the part of a namespace identified by a Subject to a subordinate Authority, by virtue of holding a secret key which can generate signatures verifiable using a public key associated with a delegation to the Zone.</li>
<li>Zone: A portion of a namespace rooted at a given point in the namespace hierarchy. A Zone contains all the Assertions about Subjects tha exist within its part of the namespace.</li>
<li>Query: An expression of interest in certain types of objects pertaining to a Subject name in one or more contexts. See <a href="#query" class="xref">Section 6.2</a>.</li>
<li>Context: Additional information about the scope in which an Assertion or Query is valid. See <a href="#context-in-assertions" class="xref">Section 5.1.1</a> and <a href="#context-in-queries" class="xref">Section 6.2.1</a>.</li>
<li>Shard: A group of assertions common to a zone and valid at a given point in time, scoped to a lexicographic range of Subject names with in the Zone, for purposes of proving non-existence of an Assertion. Shards may be encoded to provide either absolute proof or probabalistic assurance of non-existence. See <a href="#shards-and-p-shards" class="xref">Section 5.1.4</a>.</li>
<li>Assertion Update Query: An expression of interest about the current validity status of an unexpired assertion one already has.</li>
<li>Nonexistence Update Query: An expression of interest about the current validity status of an unexpired shard or zone one already has.</li>
<li>RAINS Message: Unit of exchange in the RAINS protocol, containing assertions, shards, zones, queries, and notifications. See <a href="#cbor-message" class="xref">Section 7.2</a>.</li>
<li>Notification: A RAINS-internal message section carrying information about the operation of the protocol itself. See <a href="#cbor-notification" class="xref">Section 7.13</a>.</li>
<li>Authority Service: A service provided by a RAINS Server for publishing assertions by an authority. See <a href="#architecture" class="xref">Section 4</a>.</li>
<li>Query Service: A service provided by a RAINS Server for answering queries on behalf of a RAINS Client. See <a href="#architecture" class="xref">Section 4</a>.</li>
<li>Intermediary Service: A service provided by a RAINS Server for answering queries and providing temporary storage for assertions on behalf of other RAINS Servers. See <a href="#architecture" class="xref">Section 4</a>.</li>
<li>RAINS Server: A server that speaks the RAINS Protocol, and provides on or more services on behalf of other RAINS Servers and/or RAINS Clients. See <a href="#architecture" class="xref">Section 4</a>.</li>
<li>RAINS Client: A client that uses the Query Service of one or more RAINS Servers to retrieve assertions on behalf of applications that wish to connect to named services in the Internet.</li>
</ul>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#pins" id="pins">An Ideal Internet Naming Service</a>
</h1>
<p id="rfc.section.3.p.1">We begin by returning to first principles, to determine the dimensions of the design space of desirable properties of an Internet-scale naming service. We recognize that the choices made in the evolution of the DNS since its initial design are only one path through the design space of Internet-scale naming services. Many other naming services have been proposed, though none has been remotely as successful for general-purpose use in the Internet. The following subsections outline the space more generally. It is, of course, informed by decades of experience with the DNS, but identifies a few key gaps which we then aim to address directly with the design of RAINS.</p>
<p><a href="#pins-interfaces" class="xref">Section 3.1</a> defines the set of operations a naming service should provide for queriers and authorities, <a href="#pins-properties" class="xref">Section 3.2</a> defines a set of desirable properties of the provision of this service, and <a href="#pins-observations" class="xref">Section 3.3</a> examines implications of these properties.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#pins-interfaces" id="pins-interfaces">Interfaces</a>
</h1>
<p id="rfc.section.3.1.p.1">At its core, a naming service must provide a few basic functions for queriers, associating a Subject of a query with information about that subject. The information available from a naming service is that which is necessary for a querier to establish a connection with some other entity in the Internet, given a name identifying it.</p>
<p></p>

<ul>
<li>Name to Address: given a Subject name, the naming service returns a set of addresses associated with that name, if such an association exists, where the association is determined by the authority for that name. Names may be associated with addresses in one or more address families (e.g. IP version 4, IP version 6). A querier may specify which address families it is interested in receiving addresses for, and the naming system treats all address families equally. This mapping is implemented in the DNS protocol via the A and AAAA RRTYPES.</li>
<li>Address to Name: given an Subject address, the naming service returns a set of names associated with that address, if such an association exists, where the association is determined by the authority for that address. This mapping is implemented in the DNS protocol via the PTR RRTYPE. IPv4 mappings exist within the in-addr.arpa. zone, and IPv6 mappings in the ip6.arpa. zone. These mappings imply a limited set of boundaries on which delegations may be made (octet boundaries for IPv4, nybble boundaries for IPv6).</li>
<li>Name to Name: given a Subject name, the naming service returns a set of object names associated with that name, if such an association exists, where the association is determined by the authority for the subject name. This mapping is implemented in the DNS protocol via the CNAME RRTYPE. CNAME does not allow the association of multiple object names with a single subject, and CNAME may not combine with other RRTYPEs (e.g. NS, MX) arbitrarily.</li>
<li>Name to Auxiliary Information: given a Subject name, the naming service returns other auxiliary information associated with that name that is useful for establishing communication over the Internet with the entities associated with that name. Most of the other RRTYPES in the DNS protocol implement these sort of mappings.</li>
</ul>
<p id="rfc.section.3.1.p.3">The query interface is not the only interface to the naming service: the interface a naming service presents to an Authority allows updates to the set of Assertions and Delegations in that Authority&#8217;s namespace. Updates consist of additions of, changes to, and deletions of Assertions and Delegations. In the present DNS, this interface consists of the publication of a new zone file with an incremented version number, but other authority interfaces are possible.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#pins-properties" id="pins-properties">Properties</a>
</h1>
<p id="rfc.section.3.2.p.1">The following properties are desirable in a naming service providing the functions in <a href="#pins-interfaces" class="xref">Section 3.1</a>.</p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#meaningfulness" id="meaningfulness">Meaningfulness</a>
</h1>
<p id="rfc.section.3.2.1.p.1">A naming service must provide the ability to name objects that its human users find more meaningful than the objects themselves.</p>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#pins-distinguishability" id="pins-distinguishability">Distinguishability</a>
</h1>
<p id="rfc.section.3.2.2.p.1">A naming service must make it possible to guarantee that two different names are easily distinguishable from each other by its human users.</p>
<h1 id="rfc.section.3.2.3">
<a href="#rfc.section.3.2.3">3.2.3.</a> <a href="#minimal-structure" id="minimal-structure">Minimal Structure</a>
</h1>
<p id="rfc.section.3.2.3.p.1">A naming service should impose as little structure on the names it supports as practical in order to be universally applicable. Naming services that impose a given organizational structure on the names expressible using the service will not translate well to societies where that organizational structure is not prevalent.</p>
<h1 id="rfc.section.3.2.4">
<a href="#rfc.section.3.2.4">3.2.4.</a> <a href="#federation-of-authority" id="federation-of-authority">Federation of Authority</a>
</h1>
<p id="rfc.section.3.2.4.p.1">An Authority can delegate some part of its namespace to some other subordinate Authority. This property allows the naming service to scale to the size of the Internet, and leads to a tree-structured namespace, where each Delegation is itself identified with a Subject at a given level in the namespace.</p>
<p id="rfc.section.3.2.4.p.2">In the DNS protocol, this federation of authority is implemented through delegation using the NS RRTYPE, redirecting queries to subordinate authorities recursively to the final authority. When DNSSEC is used, the DS RRTYPE is used to verify this delegation.</p>
<h1 id="rfc.section.3.2.5">
<a href="#rfc.section.3.2.5">3.2.5.</a> <a href="#uniqueness-of-authority" id="uniqueness-of-authority">Uniqueness of Authority</a>
</h1>
<p id="rfc.section.3.2.5.p.1">For a given Subject, there is a single Authority that has the right to determine the Assertions and/or Delegations for that subject. The unitary authority for the root of the namespace tree may be special, though; see <a href="#consensus-on-root-of-authority" class="xref">Section 3.2.8</a>.</p>
<p id="rfc.section.3.2.5.p.2">In the DNS protocol as deployed, unitary authority is approximated by the entity identified by the SOA RRTYPE. The existence of registrars, which use the Extensible Provisioning Protocol (EPP) <a href="#RFC5730" class="xref">[RFC5730]</a> to modify entries in the zones under the authority of a top-level domain registry, complicates this somewhat.</p>
<h1 id="rfc.section.3.2.6">
<a href="#rfc.section.3.2.6">3.2.6.</a> <a href="#transparency-of-authority" id="transparency-of-authority">Transparency of Authority</a>
</h1>
<p id="rfc.section.3.2.6.p.1">A querier can determine the identity of the Authority for a given Assertion.  An Authority cannot delegate its rights or responsibilities with respect to a subject without that Delegation being exposed to the querier.</p>
<p id="rfc.section.3.2.6.p.2">In DNS, the authoritative name server(s) to which a query is delegated via the NS RRTYPE are known. However, we note that in the case of authorities which delegate the ability to write to the zone to other entities (i.e., the registry-registrar relationship), the current DNS provides no facility for a querier to understand on whose behalf an authoritative assertion is being made; this information is instead available via WHOIS. To our knowledge, no present DNS name servers use WHOIS information retrieved out of band to make policy decisions.</p>
<h1 id="rfc.section.3.2.7">
<a href="#rfc.section.3.2.7">3.2.7.</a> <a href="#revocability-of-authority" id="revocability-of-authority">Revocability of Authority</a>
</h1>
<p id="rfc.section.3.2.7.p.1">An ideal naming service allows the revocation and replacement of an authority at any level in the namespace, and supports the revocation and replacement of authorities with minimal operational disruption.</p>
<p id="rfc.section.3.2.7.p.2">The current DNS allows the replacement of any level of delegation except the root through changes to the appropriate NS and DS records. Authority revocation in this case is as consistent as any other change to the DNS.</p>
<h1 id="rfc.section.3.2.8">
<a href="#rfc.section.3.2.8">3.2.8.</a> <a href="#consensus-on-root-of-authority" id="consensus-on-root-of-authority">Consensus on Root of Authority</a>
</h1>
<p id="rfc.section.3.2.8.p.1">Authority at the top level of the namespace tree is delegated according to a process such that there is universal agreement throughout the Internet as to the subordinates of those Delegations.</p>
<h1 id="rfc.section.3.2.9">
<a href="#rfc.section.3.2.9">3.2.9.</a> <a href="#authenticity-of-delegation" id="authenticity-of-delegation">Authenticity of Delegation</a>
</h1>
<p id="rfc.section.3.2.9.p.1">Given a Delegation from a superordinate to a subordinate Authority, a querier can verify that the superordinate Authority authorized the Delegation.</p>
<p id="rfc.section.3.2.9.p.2">Authenticity of delegation in DNS is provided by DNSSEC <a href="#RFC4033" class="xref">[RFC4033]</a>.</p>
<h1 id="rfc.section.3.2.10">
<a href="#rfc.section.3.2.10">3.2.10.</a> <a href="#authenticity-of-response" id="authenticity-of-response">Authenticity of Response</a>
</h1>
<p id="rfc.section.3.2.10.p.1">The authenticity of every answer is verifiable by the querier. The querier can confirm that the Assertion returned in the answer is correct according to the Authority for the Subject of the query.</p>
<p id="rfc.section.3.2.10.p.2">Authenticity of response in DNS is provided by DNSSEC.</p>
<h1 id="rfc.section.3.2.11">
<a href="#rfc.section.3.2.11">3.2.11.</a> <a href="#authenticity-of-negative-response" id="authenticity-of-negative-response">Authenticity of Negative Response</a>
</h1>
<p id="rfc.section.3.2.11.p.1">Some queries will yield no answer, because no such Assertion exists. In this case, the querier can confirm that the Authority for the Subject of the query asserts this lack of Assertion.</p>
<p id="rfc.section.3.2.11.p.2">Authenticity of negative response in DNS is provided by DNSSEC.</p>
<h1 id="rfc.section.3.2.12">
<a href="#rfc.section.3.2.12">3.2.12.</a> <a href="#dynamic-consistency" id="dynamic-consistency">Dynamic Consistency</a>
</h1>
<p id="rfc.section.3.2.12.p.1">Consistency in a naming service is important. The naming service should provide the most globally consistent view possible of the set of Assertions that exist at a given point in time, within the limits of latency and bandwidth tradeoffs.</p>
<p id="rfc.section.3.2.12.p.2">When an Authority makes changes to an Assertion, every query for a given Subject returns either the new valid result or a previously valid result, with known and/or predictable bounds on &#8220;how previously&#8221;. Given that additions of, changes to, and deletions of Asseretion may have different operational causes, different bounds may apply to different operations.</p>
<p id="rfc.section.3.2.12.p.3">The time-to-live (TTL) on a resource record in DNS provides a mechanism for expiring old resource records. We note that this mechanism makes additions to the system propagate faster than changes and deletions, which may not be a desirable property. However, as no context information is explicitly available in DNS, the DNS cannot be said to be dynamically consistent, as different implicitly inconsistent views of an Assertion may be persistent.</p>
<h1 id="rfc.section.3.2.13">
<a href="#rfc.section.3.2.13">3.2.13.</a> <a href="#explicit-inconsistency" id="explicit-inconsistency">Explicit Inconsistency</a>
</h1>
<p id="rfc.section.3.2.13.p.1">Some techniques require giving different answers to different queries, even in the absence of changes: the stable state of the namespace is not globally consistent. This inconsistency should be explicit: a querier can know that an answer might be dependent on its identity, network location, or other factors.</p>
<p id="rfc.section.3.2.13.p.2">One example of such desirable inconsistency is the common practice of &#8220;split horizon&#8221; DNS, where an organization makes internal names available on its own network, but only the names of externally-visible subjects available to the Internet at large.</p>
<p id="rfc.section.3.2.13.p.3">Another is the common practice of DNS-based content distribution, in which an authoritative name server gives different answers for the same query depending on the network location from which the query was received, or depending on the subnet in which the end client originating a query is located (via the EDNS Client Subnet extension {RFC7871}}). Such inconsistency based on client identity or network address may increase query linkability (see <a href="#query-linkability" class="xref">Section 3.2.18</a>).</p>
<p id="rfc.section.3.2.13.p.4">These forms of inconsistency are implicit, not explicit, in the current DNS. We note that while DNS can be deployed to allow essentially unlimited kinds of inconsistency in its responses, there is no protocol support for a query to express the kind of consistency it desires, or for a response to explicitly note that it is inconsistent. <a href="#RFC7871" class="xref">[RFC7871]</a> does allow a querier to note that it would specifically like the view of the state of the namespace offered to a certain part of the network, and as such can be seen as inchoate support for this property.</p>
<h1 id="rfc.section.3.2.14">
<a href="#rfc.section.3.2.14">3.2.14.</a> <a href="#global-invariance" id="global-invariance">Global Invariance</a>
</h1>
<p id="rfc.section.3.2.14.p.1">An Assertion which is not intended to be explicitly inconsistent by the Authority issuing it must return the same result for every Query for it, regardless of the identity or location of the querier.</p>
<p id="rfc.section.3.2.14.p.2">This property is not provided by DNS, as it depends on the robust support on the Explicit Inconsistency property above. Examples of global invariance failures include geofencing and DNS-based censorship ordered by a local jurisdiction.</p>
<h1 id="rfc.section.3.2.15">
<a href="#rfc.section.3.2.15">3.2.15.</a> <a href="#availability" id="availability">Availability</a>
</h1>
<p id="rfc.section.3.2.15.p.1">The naming service as a whole is resilient to failures of individual nodes providing the naming service, as well as to failures of links among them. Intentional prevention of successful, authenticated query by an adversary should be as hard as practical.</p>
<p id="rfc.section.3.2.15.p.2">The DNS protocol was designed to be highly available through the use of secondary nameservers. Operational practices (e.g. anycast deployment) also increase the availability of DNS as currently deployed.</p>
<h1 id="rfc.section.3.2.16">
<a href="#rfc.section.3.2.16">3.2.16.</a> <a href="#lookup-latency" id="lookup-latency">Lookup Latency</a>
</h1>
<p id="rfc.section.3.2.16.p.1">The time for the entire process of looking up a name and other necessary associated data from the point of view of the querier, amortized over all queries for all connections, should not significantly impact connection setup or resumption latency.</p>
<h1 id="rfc.section.3.2.17">
<a href="#rfc.section.3.2.17">3.2.17.</a> <a href="#bandwidth-efficiency" id="bandwidth-efficiency">Bandwidth Efficiency</a>
</h1>
<p id="rfc.section.3.2.17.p.1">The bandwidth cost for looking up a name and other associated data necessary for establishing communication with a given Subject, from the point of view of the querier, amortized over all queries for all connections, should not significantly impact total bandwidth demand for an application.</p>
<h1 id="rfc.section.3.2.18">
<a href="#rfc.section.3.2.18">3.2.18.</a> <a href="#query-linkability" id="query-linkability">Query Linkability</a>
</h1>
<p id="rfc.section.3.2.18.p.1">It should be costly for an adversary to monitor the infrastructure in order to link specific queries to specific queriers.</p>
<p id="rfc.section.3.2.18.p.2">DNS over TLS <a href="#RFC7858" class="xref">[RFC7858]</a> and DNS over DTLS <a href="#RFC8094" class="xref">[RFC8094]</a> provide this property between a querier and a recursive resolver; mixing by the recursive helps with mitigating upstream linkability.</p>
<h1 id="rfc.section.3.2.19">
<a href="#rfc.section.3.2.19">3.2.19.</a> <a href="#explicit-tradeoff" id="explicit-tradeoff">Explicit Tradeoff</a>
</h1>
<p id="rfc.section.3.2.19.p.1">A querier should be able to indicate the desire for a benefit with respect to one performance property by accepting a tradeoff in another, including:</p>
<p></p>

<ul>
<li>Reduced latency for reduced dynamic consistency</li>
<li>Increased dynamic consistency for increased latency</li>
<li>Reduced request linkability for increased latency and/or reduced dynamic consistency</li>
<li>Reduced aggregate bandwidth use for increased latency and/or reduced dynamic consistency</li>
</ul>
<p id="rfc.section.3.2.19.p.3">There is no support for explicit tradeoffs in performance properties available to clients in the present DNS.</p>
<h1 id="rfc.section.3.2.20">
<a href="#rfc.section.3.2.20">3.2.20.</a> <a href="#trust-in-infrastructure" id="trust-in-infrastructure">Trust in Infrastructure</a>
</h1>
<p id="rfc.section.3.2.20.p.1">A querier should not need to trust any entity other than the authority as to the correctness of association information provided by the naming service.  Specifically, the querier should not need to trust any intermediary of infrastructure between itself and the authority, other than that under its own control.</p>
<p id="rfc.section.3.2.20.p.2">DNS provides this property with DNSSEC. However, the lack of mandatory DNSSEC, and the lack of a viable transition strategy to mandatory DNSSEC (see <a href="#I-D.trammell-optional-security-not" class="xref">[I-D.trammell-optional-security-not]</a>), means that trust in infrastructure will remain necessary for DNS even with large scale DNSSEC deployment.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#pins-observations" id="pins-observations">Observations</a>
</h1>
<p id="rfc.section.3.3.p.1">On a cursory examination, many of the properties of our ideal name service can be met, or could be met, by the present DNS protocol or extensions thereto. We note that there are further possibilities for the future evolution of naming services meeting these properties. This section contains random observations that might inform future work.</p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#delegation-and-redirection-are-separate-operations" id="delegation-and-redirection-are-separate-operations">Delegation and redirection are separate operations</a>
</h1>
<p id="rfc.section.3.3.1.p.1">Any system which can provide the authenticity properties enumerated above is freed from one of the design characteristics of the present domain name system: the requirement to bind a zone of authority to a specific set of authoritative servers. Since the authenticity of delegation must be a protected by a chain of signatures back to the root of authority, the location within the infrastructure where an authoritative mapping &#8220;lives&#8221; is no longer bound to a specific name server. While the present design of DNS does have its own scalability advantages, this implication allows a much larger design space to be explored for future name service work, as a Delegation need not always be implemented via redirection to another name server.</p>
<h1 id="rfc.section.3.3.2">
<a href="#rfc.section.3.3.2">3.3.2.</a> <a href="#unicode-alone-may-not-be-sufficient-for-distinguishable-names" id="unicode-alone-may-not-be-sufficient-for-distinguishable-names">Unicode alone may not be sufficient for distinguishable names</a>
</h1>
<p id="rfc.section.3.3.2.p.1">Allowing names to be encoded in Unicode goes a long way toward meeting the meaningfulness property (see <a href="#meaningfulness" class="xref">Section 3.2.1</a>) for the majority of speakers of human languages. However, as noted by the Internet Architecture Board (see <a href="#IAB-UNICODE7" class="xref">[IAB-UNICODE7]</a>) and discussed at the Locale-free Unicode Identifiers (LUCID) BoF at IETF 92 in Dallas in March 2015 (see <a href="#LUCID" class="xref">[LUCID]</a>), it is not in the general case sufficient for distinguishability (see <a href="#pins-distinguishability" class="xref">Section 3.2.2</a>).  An ideal naming service may therefore have to supplement Unicode by providing runtime support for disambiguation of queries and assertions where the results may be indistinguishable.</p>
<h1 id="rfc.section.3.3.3">
<a href="#rfc.section.3.3.3">3.3.3.</a> <a href="#implicit-inconsistency-makes-global-invariance-challenging-to-verify" id="implicit-inconsistency-makes-global-invariance-challenging-to-verify">Implicit inconsistency makes global invariance challenging to verify</a>
</h1>
<p id="rfc.section.3.3.3.p.1">DNS does not provide a generalized form of explicit inconsistency, so efforts to verify global invariance, or rather, to discover Assertions for which global invariance does not hold, are necessarily effort-intensive and dynamic. For example, the Open Observatory of Network Interference performs DNS consistency checking from multiple volunteer vantage points for a set of targeted (i.e., likely to be globally variant) domain names; see https://ooni.torproject.org/nettest/dns-consistency/.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#architecture" id="architecture">Architecture</a>
</h1>
<p id="rfc.section.4.p.1">The RAINS architecture is simple, and resembles the architecture of DNS. A RAINS Server is an entity that provides transient and/or permanent storage for assertions about names, and a lookup function that finds assertions for a given query about a name, either by searching local storage or by delegating to another RAINS server. RAINS servers can take on any or all of three roles:</p>
<p></p>

<ul>
<li>authority service, acting on behalf of an authority to ensure properly signed assertions are made available to the system (equivalent to an authoritative server in DNS);</li>
<li>query service, acting on behalf of a client to answer queries with relevant assertions (equivalent to a recursive resolver in DNS), and to validate assertions on the client&#8217;s behalf; and/or</li>
<li>intermediary service, acting on behalf of neither but providing storage and lookup for assertions with certain properties for query and authority servers (partially replacing, but not really equivalent to, caching resolvers in DNS).</li>
</ul>
<p id="rfc.section.4.p.3">RAINS Servers use the RAINS Protocol defined in this document to exchange queries and assertions. RAINS Clients use a subset variant of the RAINS Protocol (called the RAINS Client Protocol) to interact with RAINS Servers providing query services on their behalf.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#information-model" id="information-model">Information Model</a>
</h1>
<p id="rfc.section.5.p.1">The RAINS Protocol is based on an information model built around two kinds of information: Assertions and Queries. An Assertion contains some information about a name or address, and a Query contains a request for information about a name or address. The information model in this section omits information elements required by the resolution mechanism itself; these are defined in more detail in <a href="#cbor" class="xref">Section 7</a> and <a href="#protocol-def" class="xref">Section 9</a>.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#assertion" id="assertion">Assertion</a>
</h1>
<p id="rfc.section.5.1.p.1">An Assertion is a signed statement about a mapping from a subject name to one or several object values of the same type, and consists of the following elements:</p>
<p></p>

<ul>
<li>Context: name of the context in which the assertion is valid; see <a href="#context-in-assertions" class="xref">Section 5.1.1</a> below.</li>
<li>Subject: name about which the assertion is made.</li>
<li>Zone: name of the zone in which the assertion is made. The fully qualified name of the subject is made by appending the zone name to the subject name with a domain name separator (&#8216;.&#8217;).</li>
<li>Type: the type of information about the Subject contained in the assertion.  Each Assertion is about a single type of data.</li>
<li>Object: the data of the indicated type associated with the Subject</li>
<li>Signatures: one or more signatures generated by the authority for the Assertion. Signatures contain a time interval during which they are considered valid. See <a href="#signatures-in-assertions" class="xref">Section 5.1.2</a> below.</li>
</ul>
<p id="rfc.section.5.1.p.3">The Types supported for each assertion are:</p>
<p></p>

<ul>
<li>Delegation: the authority associated with the zone identified by the name (roughly equivalent to the DNSSEC DS RRTYPE). The Object contains a public key by which the authority can be identified.</li>
<li>Redirection: The name(s) of one or more RAINS servers providing authority service for the authority associated with the zone (roughly equivalent to the DNSSEC NS RRTYPE, but not always consulted directly during resolution).  The Object contains a set of names.</li>
<li>Address: one or more addresses associated with the name (replaces DNS A and AAAA RTYPEs). The Object contains a set of Addresses. An Address is an {address-family, value} tuple.</li>
<li>Service-Info: one or more layer 4 ports and hostnames associated with a service name (replaces DNS SRV RRTYPE). The object contains a {hostname, port-number, priority} tuple.</li>
<li>Name: one or more names associated with the name (roughly equivalent to DNS CNAME). The Object contains a set of names.</li>
<li>Certificate: a certificate which must appear at a specified location in the certificate chain presented on a connection attempt with the named entity (roughly equivalent to DNS TLSA).</li>
<li>Zone-Nameset: an expression of the set of names allowed within a zone; e.g.  Unicode scripts or codepages in which names in the zone may be issued. This allows a zone to set policy on names in support of the distinguishability property (<a href="#pins-distinguishability" class="xref">Section 3.2.2</a>) that can be checked by RAINS servers at runtime. An assertion about a Subject within a Zone whose name is not allowed by a valid signed Zone-Nameset expression is taken to be invalid, even if it has a valid signature.</li>
<li>Zone-Registrar: Information about the organization that caused a Subject name to exist, for registrant-level names.</li>
<li>Zone-Registrant: Information about the organization responsible for a Subject name, for registrant-level names.</li>
<li>Infrastructure Key: Information about public keys used for object security within the RAINS infrastructure itself. The Object contains a public key by which a named RAINS server can be identified.</li>
<li>External Key: Information about public keys used for additional signatures on assertions. The external key is usually discovered outside RAINS, and can be verified by comparison with the key stored in a RAINS assertion. The Object contains an external public key.</li>
<li>Subsequent Key: Assertions about delegations are made by a zone&#8217;s superordinate. A zone may request that its superordinate delegate to a new public key by publishing a subsequent key assertion (replacing the mechanism implemented by CDS/CDNSKEY in DNS).</li>
</ul>
<p id="rfc.section.5.1.p.5">For a given {subject, type} tuple, multiple assertions can be valid at a given point in time; the union of the object values of all of these assertions is considered to be the set of valid values at that point in time.</p>
<h1 id="rfc.section.5.1.1">
<a href="#rfc.section.5.1.1">5.1.1.</a> <a href="#context-in-assertions" id="context-in-assertions">Context in Assertions</a>
</h1>
<p id="rfc.section.5.1.1.p.1">Assertion contexts are used to determine the validity of the signature by the declared authority as follows:</p>
<p></p>

<ul>
<li>The global context is identified by the special context name &#8216;.&#8217;. Assertions in the global context are signed by the authority for the subject name. For example, assertions about the name &#8216;ethz.ch.&#8217; in the global context are only valid if signed by the relevant authority which is either &#8216;ethz.ch.&#8217;, &#8216;ch.&#8217;, or &#8216;.&#8217; depending on the value of the subject name of the assertion.</li>
<li>A local context is associated with a given authority. The authority-part and the context-part of a local context name are divided by a context marker (&#8216;cx&#8211;&#8217;). The authority-part directly identifies the authority whose key was used to sign the assertion; assertions within a local context are only valid if signed by the identified authority. Authorities have complete control over how the contexts under their namespaces are arranged, and over the names within those contexts. Both the authority-part and the context-part must end with a &#8216;.&#8217;.</li>
</ul>
<p id="rfc.section.5.1.1.p.3">Assertion context is the mechanism by which RAINS provides explicit inconsistency ({{explicit-inconsistency}). Some examples illustrate how context works:</p>
<p></p>

<ul>
<li>For the common split-DNS case, an enterprise could place names for machines on its local networks within a separate context. E.g., a workstation could be named &#8216;simplon.cab.inf.ethz.ch.&#8217; within the context &#8216;staff-workstations.cx&#8211;inf.ethz.ch.&#8217; Assertions about this name would be signed by the authority for &#8216;inf.ethz.ch.&#8217;. Here, the context serves simply as a marker, without enabling an alternate signature chain: note that the name &#8216;simplon.cab.inf.ethz.ch&#8217; could at the same time be validly signed in the global context by the authority over that name to allow external users access this workstation. The local context simply marks this assertion as internal.  This allows a client making requests of local names to know they are local, and for local resolvers to manage visibility of assertions outside the enterprise: explicit context makes accidental leakage of both queries and assertions easier to detect and avoid.</li>
<li>Contexts make captive-portal interactions more explicit: a captive portal resolver could respond to a query for a common website (e.g. www.google.ch) with a signed response directed at the captive portal, but within a context identifying the location as well as the ISP (e.g.  sihlquai.zurich.ch.cx&#8211;starbucks.access.some-isp.net.). This response will be signed by the authority for &#8216;starbucks.access.some-isp.net.&#8217;. This signature achieves two things: first, the client knows the result for www.google.ch is not globally valid; second, it can present the user with some indication as to the identity of the captive portal it is connected to.</li>
</ul>
<p id="rfc.section.5.1.1.p.5">Further examples showing how context can be used in queries as well are given in <a href="#context-in-queries" class="xref">Section 6.2.1</a> below.</p>
<p id="rfc.section.5.1.1.p.6">Developing conventions for assertion contexts for different situations will require implementation and deployment experience, and is a subject for future work.</p>
<h1 id="rfc.section.5.1.2">
<a href="#rfc.section.5.1.2">5.1.2.</a> <a href="#signatures-in-assertions" id="signatures-in-assertions">Signatures in Assertions</a>
</h1>
<p id="rfc.section.5.1.2.p.1">A signature over an assertion contains the following information elements:</p>
<p></p>

<ul>
<li>Algorithm: identifier of the algorithm used to generate the signature.</li>
<li>Keyspace: identifier of the key space used to generate the signature, i.e. how the key to verify the signature should be retrieved. RAINS supports an internal keyspace, but allows signatures using externally obtained keys to appear on assertions for additional security.</li>
<li>Keyphase: phase of the key used to generate the signature. Since multiple keys may be valid for a given authority at a given point in time, this allows the correct key to be retrieved directly.</li>
<li>Valid-Since: a timestamp of the start of validity of this signature.</li>
<li>Valid-Until: a timestamp of the end of validity of this signature.</li>
<li>Signature: the cryptographic signature itself, whose format is determined by the algorithm used.</li>
</ul>
<p id="rfc.section.5.1.2.p.3">The signature protects all the information in an assertion as well as its own algorithm identifier, keyspace identifier, key phase, valid-since, and valid-until values; it does not protect other signatures on the assertion.</p>
<h1 id="rfc.section.5.1.3">
<a href="#rfc.section.5.1.3">5.1.3.</a> <a href="#semantic-of-nonexistence-proofs" id="semantic-of-nonexistence-proofs">Semantic of nonexistence proofs</a>
</h1>
<p id="rfc.section.5.1.3.p.1">Shards, P-Shards and zones can all be used to prove nonexistence during their validity. But to allow change to happen frequently and to have a dynamic system, an assertion might be created, altered, expired or revoked during the validity period of a shard, P-Shard or zone, leading to an inconsistency. Thus, a section proving nonexistence only captures the state at the point in time when it was signed. To make sure that the content of a shard, P-Shard or zone is still accurate, a nonexistence update query <a href="#nonexistence-update-query" class="xref">Section 6.4</a> must be sent to the server having authority over that name.</p>
<h1 id="rfc.section.5.1.4">
<a href="#rfc.section.5.1.4">5.1.4.</a> <a href="#shards-and-p-shards" id="shards-and-p-shards">Shards and Probabilistic Shards (P-Shards)</a>
</h1>
<p id="rfc.section.5.1.4.p.1">A shard is exclusively used to prove non-existence of a name and type in a given context and range. It allows zone authorities with many names to make nonexistence proofs when their zone&#8217;s content is too large to fit in a message, see <a href="#protocol-limits" class="xref">Section 9.5</a>. A shard is a sorted set of assertions within the same zone and context, protected by one or more signatures over all assertions within the shard. Shards have an exclusive lexicographic range, and contain all assertions for names within a zone within that range. This lexicographic completeness leads to the property that given a subject and an authenticated shard, it can be shown that either an assertion with a given name, type and object value exists within the shard or does not exist at all.</p>
<p id="rfc.section.5.1.4.p.2">A shard has the following information elements:</p>
<p></p>

<ul>
<li>Context: name of the context in which the assertions in the shard are valid; see <a href="#context-in-assertions" class="xref">Section 5.1.1</a> above.</li>
<li>Zone: name of the zone in which the assertions are made.</li>
<li>Range: an exclusive lexicographic range within which the contained assertions&#8217; names must be.</li>
<li>Content: a lexicographically sorted set of assertions sharing the context and zone.</li>
<li>Signatures: one or more signatures generated by the authority for the shard; see <a href="#signatures-in-assertions" class="xref">Section 5.1.2</a>.</li>
</ul>
<p id="rfc.section.5.1.4.p.4">For efficiency&#8217;s sake, information elements within a shard common to all assertions (zone, context) within the shard must be omitted from the assertions themselves. Signatures on contained assertions may be omitted.</p>
<p id="rfc.section.5.1.4.p.5">A P-Shard represents a space-efficient probabilistic data structure stored as a bit string to proof nonexistence. The data structure is used to prove membership of an element in a set. The set could either be the entire zone or an exclusive lexicographic range of that zone (like the range of a shard). All assertions within the same zone and context, and whose names are within the range are elements of the set. A P-Shard is protected by one or more signatures. A membership query to the P-Shard responds either with &#8216;an assertion with a given name and type might be part of the set&#8217; or &#8216;an assertion with a given name and type is definitely not part of the set&#8217;. The second response can be used to proof nonexistence of an assertion with a given name and type. There is a tradeoff between the size of the bit string, membership query time, and the false positive error rate. The zone authority can determine how to weight them.</p>
<p id="rfc.section.5.1.4.p.6">A P-Shard has the following information elements:</p>
<p></p>

<ul>
<li>Context: name of the context in which the assertions in the P-Shard are valid; see <a href="#context-in-assertions" class="xref">Section 5.1.1</a>.</li>
<li>Zone: name of the zone in which the assertions are made.</li>
<li>Range: an exclusive lexicographic range within which the contained assertions&#8217; names must be.</li>
<li>Type: the type of the probabilistic data structure contained in the P-Shard.</li>
<li>Data structure: meta data about the data structure of the indicated type and a bit string representing the data structure itself.</li>
<li>Signatures: one or more signatures generated by the authority for the shard; see <a href="#signatures-in-assertions" class="xref">Section 5.1.2</a>.</li>
</ul>
<p id="rfc.section.5.1.4.p.8">The Types supported for each P-Shard are:</p>
<p></p>

<ul><li>Bloom filter: A space-efficient probabilistic data structure using a configurable amount of hash functions from a specified hash family to generate a bit string encoding all contained assertions.</li></ul>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#zone" id="zone">Zone</a>
</h1>
<p id="rfc.section.6.p.1">A zone is the entire set of shards, P-Shards, and assertions subject to a given authority within a given context. The majority of zones will be tiny. Thus, a zone can be used for both positive and negative answers as it contains all information about the zone while still being small.</p>
<p id="rfc.section.6.p.2">A zone has the following information elements:</p>
<p></p>

<ul>
<li>Context: name of the context in which the assertions in the zone are valid; see <a href="#context-in-assertions" class="xref">Section 5.1.1</a> above.</li>
<li>Zone: name of the zone.</li>
<li>Content: a set of assertions, P-Shards and/or shards sharing the context and zone.</li>
<li>Signatures: one or more signatures generated by the authority for the zone; see <a href="#signatures-in-assertions" class="xref">Section 5.1.2</a>.</li>
</ul>
<p id="rfc.section.6.p.4">For efficiency&#8217;s sake, information elements within a zone common to all assertions, shards, and P-Shards (zone, context) within the zone must be omitted from the assertions, shards, and P-Shards themselves. Signatures on contained assertions, shards, and P-Shards may be omitted.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#zone-reflexive-assertions" id="zone-reflexive-assertions">Zone-Reflexive Assertions</a>
</h1>
<p id="rfc.section.6.1.p.1">A zone may make an assertion about itself by using the string &#8220;@&#8221; as a subject name. This facility can be used for any assertion type, but is especially useful for self-signing root zones, and for a zone to make a subsequent key assertion about itself. If an assertion of a given type about a zone is available both in the zone itself and in the superordinate zone, the assertion in the superordinate zone will take precedence.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#query" id="query">Query</a>
</h1>
<p id="rfc.section.6.2.p.1">A query is a request for a set of assertions supporting a conclusion about a given subject-object mapping. It consists of the following information elements:</p>
<p></p>

<ul>
<li>Context: the context(s) in which assertions answering the query will be accepted; see <a href="#context-in-queries" class="xref">Section 6.2.1</a> below.</li>
<li>Qualified-Subject: the name about which the query is made. The subject name in a query must be fully-qualified.</li>
<li>Types: a set of assertion types the querier is interested in.</li>
<li>Key phases: the key phases of the delegation assertions the querier is interested in.</li>
<li>Valid-Until: an optional client-generated timestamp for the query after which it expires and should not be answered.</li>
<li>Query Token: a client-generated token for the query, which can be used in the answer to refer to the query.</li>
<li>Options: a set of options by which a client may specify tradeoffs (e.g.  privacy for performance).</li>
</ul>
<p id="rfc.section.6.2.p.3">A query expresses interest about all the given types of assertion in all the specified contexts; more complex expressions of which types in which contexts must be asked using multiple queries. Preferences for tradeoffs (freshness, bandwidth efficiency, latency, privacy preservation) in servicing a query may be bound to the query using query options.</p>
<h1 id="rfc.section.6.2.1">
<a href="#rfc.section.6.2.1">6.2.1.</a> <a href="#context-in-queries" id="context-in-queries">Context in Queries</a>
</h1>
<p id="rfc.section.6.2.1.p.1">Context is used in queries as it is in assertions (see <a href="#context-in-assertions" class="xref">Section 5.1.1</a>). Assertion contexts in an answer to a query have to match the context in the query in order to respond to a query. The Context section of a query contains the context of desired assertions; a special &#8220;any&#8221; context (represented by the empty string) indicates that assertions in any context will be accepted.</p>
<p id="rfc.section.6.2.1.p.2">Query contexts can also be used to provide additional information to RAINS servers about the query. For example, context can provide a method for explicit selection of a CDN server not based on either the client&#8217;s or the resolver&#8217;s address (see <a href="#RFC7871" class="xref">[RFC7871]</a>). Here, the CDN creates a context for each of its content zones, and an external service selects appropriate contexts for the client based not just on client source address but passive and active measurement of performance. Queries for names at which content resides can then be made within these contexts, with the priority order of the contexts reflecting the goodness of the zone for the client. Here, a context might be &#8216;zrh.cx&#8211;cdn-zones.some-cdn.com.&#8217; for names of servers hosting content in a CDN&#8217;s Zurich data center. A client could represent its desire to find content nearby by making queries in the zrh.cx&#8211;, fra.cx&#8211; (Frankfurt), and ams.cx&#8211; (Amsterdam) contexts of the &#8216;cdn-zones.some-cdn.com.&#8217; authority. In all cases, the assertions themselves will be signed by the authority for &#8216;cdn-zones.some-cdn.com.&#8217;, accurately representing that it is the CDN, not the owner of the related name in the global context, that is making the assertion.</p>
<p id="rfc.section.6.2.1.p.3">As with assertion contexts, developing conventions for query contexts for different situations will require implementation and deployment experience, and is a subject for future work.</p>
<h1 id="rfc.section.6.2.2">
<a href="#rfc.section.6.2.2">6.2.2.</a> <a href="#answers-to-queries" id="answers-to-queries">Answers to Queries</a>
</h1>
<p id="rfc.section.6.2.2.p.1">An answer consists of a set of assertions, shards, and/or zones which respond to a query. If the query contained a token, it is bound to that query via the token.</p>
<p id="rfc.section.6.2.2.p.2">The content of an answer depends on whether the answer is positive or negative.  A positive answer contains the information requested in the smallest atomic container that can be found, usually a single assertion. A negative answer contains the information used to verify it; either a Shard, an entire Zone, or a Zone-Nameset assertion showing the name is illegal within the zone.</p>
<p id="rfc.section.6.2.2.p.3">A query is taken to have an inconclusive answer when no answer returns to the querier before the query&#8217;s Valid-Until time.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#assertion-update-query" id="assertion-update-query">Assertion Update Query</a>
</h1>
<p id="rfc.section.6.3.p.1">An assertion update query is a request for an updated version of a specified assertion. It consists of the following information elements:</p>
<p></p>

<ul>
<li>Qualified-Subject: the fully-qualified name of the assertion.</li>
<li>Hash function: the hash function used to hash the assertion.</li>
<li>Hashed Assertion: The hash value obtained by hashing the assertion.</li>
<li>Valid-Until: an optional client-generated timestamp for the query after which it expires and should not be answered.</li>
<li>Query Token: a client-generated token for the query, which must be used in the answer to refer to the query.</li>
</ul>
<h1 id="rfc.section.6.3.1">
<a href="#rfc.section.6.3.1">6.3.1.</a> <a href="#answers-to-assertion-update-queries" id="answers-to-assertion-update-queries">Answers to Assertion Update Queries</a>
</h1>
<p id="rfc.section.6.3.1.p.1">An answer consists of an assertion, a shard, a zone, or a notification which responds to an assertion update query. If the update query contained a token, it is bound to that query via the token.</p>
<p id="rfc.section.6.3.1.p.2">The content of an answer depends on whether there is a newer version of the assertion that is already valid. If the hashed assertion is still the most recent one, a 200 notification message is returned. In case there is an assertion for the same name, type and object value with a higher validUntil value, the one with the highest value is returned. Otherwise a shard, zone or 210 notification is returned. A shard or zone is preferred over the notification answer.</p>
<p id="rfc.section.6.3.1.p.3">An update query is taken to have an inconclusive answer when no answer returns to the querier before the update query&#8217;s Valid-Until time.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#nonexistence-update-query" id="nonexistence-update-query">Nonexistence Update Query</a>
</h1>
<p id="rfc.section.6.4.p.1">A nonexistence update query is a request for an updated version of a previously non-existent name proven through a shard or zone. It consists of the following information elements:</p>
<p></p>

<ul>
<li>Context: the context(s) in which sections answering the update query will be accepted; see <a href="#context-in-queries" class="xref">Section 6.2.1</a> above.</li>
<li>Qualified-Subject: the fully-qualified name within the range of the shard or the zone for which a nonexistence proof is requested.</li>
<li>Type: the assertion type the querier is interested in.</li>
<li>Hash function: the hash function used to hash the shard or the zone.</li>
<li>Hashed Section: the hash value obtained by hashing the shard or the zone.</li>
<li>Valid-Until: an optional client-generated timestamp for the query after which it expires and should not be answered.</li>
<li>Query Token: a client-generated token for the query, which must be used in the answer to refer to the query.</li>
</ul>
<h1 id="rfc.section.6.4.1">
<a href="#rfc.section.6.4.1">6.4.1.</a> <a href="#answers-to-nonexistence-update-queries" id="answers-to-nonexistence-update-queries">Answers to Nonexistence Update Queries</a>
</h1>
<p id="rfc.section.6.4.1.p.1">An answer consists of an assertion, a shard, a zone, or a notification which responds to an update query. If the update query contained a token, it is bound to that query via the token.</p>
<p id="rfc.section.6.4.1.p.2">The content of an answer depends on whether there is a new assertion for the queried context, subject-name and type or a newer version of the hashed shard or zone which is already valid. If a new assertion exists, it is returned. In case there is no matching assertion and there is a currently valid zone or a shard in the range of the fully-qualified name in a matching context with a higher validUntil value, the section with the highest validUntil value is returned. Otherwise, the shard or zone is still the most recent one and a 200 notification message is returned.</p>
<p id="rfc.section.6.4.1.p.3">An update query is taken to have an inconclusive answer when no answer returns to the querier before the query&#8217;s Valid-Until time.</p>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> <a href="#address-to-object-mapping" id="address-to-object-mapping">Address to Object Mapping</a>
</h1>
<p id="rfc.section.6.5.p.1">In contrast to the current domain name system, information about addresses is stored in a completely separate tree, keyed by address and prefix. An address assertion consists of the following elements:</p>
<p></p>

<ul>
<li>Context: name of the context in which the assertion is valid; see <a href="#context-in-address-assertions" class="xref">Section 6.5.1</a>.</li>
<li>Subject: address about which the assertion is made, consisting of an address family, address, and prefix length. A subject may be a network address (where the prefix length is less than the address length for the given address family) or a host address (where the prefix length is equal to the address length for the given address family)</li>
<li>Type: the type of information about the Subject contained in the assertion.  Each Assertion is about a single type of data.</li>
<li>Object: the data of the indicated type associated with the Subject</li>
<li>Signatures: one or more signatures generated by the authority for the Assertion. Signatures contain a time interval during which they are considered valid, as in <a href="#signatures-in-assertions" class="xref">Section 5.1.2</a>.</li>
</ul>
<p id="rfc.section.6.5.p.3">The following object types are available:</p>
<p></p>

<ul>
<li>Delegation: the authority associated with the subject network address. The Object contains a public key by which the authority can be identified. Only available for network address subjects.</li>
<li>Redirection: The name(s) of one or more RAINS servers providing authority service for the authority associated with the subject network address. The Object contains a set of names. Only available for network address subjects.</li>
<li>Name: one or more names associated with the subject network address.  The Object contains a set of names. Only available for host address subjects.</li>
<li>Zone-Registrant: Information about the organization responsible for a network.  Only available for network address subjects.</li>
</ul>
<p id="rfc.section.6.5.p.5">Queries for addresses are similar to those for names, and consist of the following information elements:</p>
<p></p>

<ul>
<li>Context: Context in which the query is made; this must match the assertion context as in <a href="#context-in-address-assertions" class="xref">Section 6.5.1</a>.</li>
<li>Subject: the address about which the query is made, consisting of an address family, address, and prefix length.</li>
<li>Types: a set of assertion types the querier is interested in, as above.</li>
<li>Valid-Until: an optional client-generated timestamp for the query after which it expires and should not be answered.</li>
<li>Query Token: a client-generated token for the query, which can be used in the answer to refer to the query.</li>
</ul>
<h1 id="rfc.section.6.5.1">
<a href="#rfc.section.6.5.1">6.5.1.</a> <a href="#context-in-address-assertions" id="context-in-address-assertions">Context in Address Assertions</a>
</h1>
<p id="rfc.section.6.5.1.p.1">Just as in forward Assertions, Assertion contexts are used in address assertions to determine the scope of an address assertion, and the signature chain used to verify it.</p>
<p></p>

<ul>
<li>The global addressing context for each address family is identified by the special context name &#8216;.&#8217;. For both IPv4 and IPv6 addresses, this is rooted at IANA, which delegates to the RIRs, which then delegates to LIRs and to address-holding registries.</li>
<li>Local contexts associated with a given authority in a forward tree can also make assertions about addresses. As with contexts in forward assertions, the authority-part and the context-part of a local context name are divided by a context marker (&#8216;cx&#8211;&#8217;). The authority-part directly identifies the authority whose key was used to sign the address assertion; address assertions within a local context are only valid if signed by the identified authority.  Authorities have complete control over how the contexts under their numberspaces are arranged, and over the addresses within those contexts.</li>
</ul>
<p id="rfc.section.6.5.1.p.3">Each local context may have a root address space zone (0/0), but these root address spaces may only delegate addresses that are reserved for local use <a href="#RFC1918" class="xref">[RFC1918]</a> <a href="#RFC4193" class="xref">[RFC4193]</a>. Local context assertions for other addresses are invalid.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#cbor" id="cbor">CBOR Data Model</a>
</h1>
<p id="rfc.section.7.p.1">The RAINS data model is a relatively straightforward mapping of the information model in <a href="#information-model" class="xref">Section 5</a> to the Concise Binary Object Representation (CBOR) <a href="#RFC7049" class="xref">[RFC7049]</a>, with an outer message type providing a mechanism for future capabilities-based versioning and recognition of a message as a RAINS message.</p>
<p id="rfc.section.7.p.2">Messages, assertions, shards, P-Shards, zones, queries, and notifications are each represented as a CBOR map of integer keys to values, which allows each of these types to be extended in the future, as well as the addition of non- standard, application-specific information to RAINS messages and data items. A common registry of map keys is given in <a href="#tabmkey" class="xref">Table 1</a>. RAINS implementations MUST ignore map keys they do not understand. Integer map keys in the range -22 to +23 are reserved for the use of future versions or extensions to the RAINS protocol.</p>
<p id="rfc.section.7.p.3">Message contents, signatures and object values are implemented as type- prefixed CBOR arrays with fixed meanings of each array element; the structure of these lower-level elements can therefore not be extended. Message section types are given in <a href="#tabsection" class="xref">Table 2</a>, object types in <a href="#tabobj" class="xref">Table 5</a>, and signature algorithms in <a href="#tabsig" class="xref">Table 11</a>.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#cbor-symtab" id="cbor-symtab">Symbol Table</a>
</h1>
<p id="rfc.section.7.1.p.1">The meaning of each of the integer keys in message, zone, shard, assertion, and notification maps is given in the symbol table below:</p>
<div id="rfc.table.1"></div>
<div id="tabmkey"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>CBOR Map Keys used in RAINS</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Name</th>
<th class="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td class="right">0</td>
<td class="left">signatures</td>
<td class="left">Signatures on a message or section</td>
</tr>
<tr>
<td class="right">1</td>
<td class="left">capabilities</td>
<td class="left">Capabilities of server sending message</td>
</tr>
<tr>
<td class="right">2</td>
<td class="left">token</td>
<td class="left">Token for referring to a data item</td>
</tr>
<tr>
<td class="right">3</td>
<td class="left">subject-name</td>
<td class="left">Subject name in an assertion, shard, P-Shard or zone</td>
</tr>
<tr>
<td class="right">4</td>
<td class="left">subject-zone</td>
<td class="left">Zone name in an assertion, shard, P-Shard or zone</td>
</tr>
<tr>
<td class="right">5</td>
<td class="left">subject-addr</td>
<td class="left">Subject address in address assertion</td>
</tr>
<tr>
<td class="right">6</td>
<td class="left">context</td>
<td class="left">Context of an assertion, shard, P-Shard, zone or query</td>
</tr>
<tr>
<td class="right">7</td>
<td class="left">objects</td>
<td class="left">Objects of an assertion</td>
</tr>
<tr>
<td class="right">8</td>
<td class="left">query-name</td>
<td class="left">Fully qualified name for a query</td>
</tr>
<tr>
<td class="right">10</td>
<td class="left">query-types</td>
<td class="left">Acceptable object types for a query</td>
</tr>
<tr>
<td class="right">11</td>
<td class="left">range</td>
<td class="left">Lexical range of Assertions in shard or P-Shard</td>
</tr>
<tr>
<td class="right">12</td>
<td class="left">query-expires</td>
<td class="left">Absolute timestamp for query expiration</td>
</tr>
<tr>
<td class="right">13</td>
<td class="left">query-opts</td>
<td class="left">Set of query options requested</td>
</tr>
<tr>
<td class="right">14</td>
<td class="left">hash-type</td>
<td class="left">Hash function used in an update query</td>
</tr>
<tr>
<td class="right">15</td>
<td class="left">hash-value</td>
<td class="left">Value of a hashed assertion, shard, P-Shard or zone</td>
</tr>
<tr>
<td class="right">17</td>
<td class="left">key-phases</td>
<td class="left">All requested key phases of a query</td>
</tr>
<tr>
<td class="right">18</td>
<td class="left">data-structure</td>
<td class="left">Data structure of a P-Shard</td>
</tr>
<tr>
<td class="right">21</td>
<td class="left">note-type</td>
<td class="left">Notification type</td>
</tr>
<tr>
<td class="right">22</td>
<td class="left">note-data</td>
<td class="left">Additional notification data</td>
</tr>
<tr>
<td class="right">23</td>
<td class="left">content</td>
<td class="left">Content of a message, shard, P-Shard or zone</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#cbor-message" id="cbor-message">Message</a>
</h1>
<p id="rfc.section.7.2.p.1">All interactions in RAINS take place in an outer envelope called a Message, which is a CBOR map tagged with the RAINS Message tag (hex 0xE99BA8, decimal 15309736).</p>
<p id="rfc.section.7.2.p.2">A Message map MAY contain a signatures (0) key, whose value is an array of Signatures over the entire message as defined in <a href="#cbor-signature" class="xref">Section 7.17</a>, to be verified against the infrastructure key for the RAINS Server originating the message.</p>
<p id="rfc.section.7.2.p.3">A Message map MAY contain a capabilities (1) key, whose value is described in <a href="#cbor-capabilities" class="xref">Section 7.18</a>.</p>
<p id="rfc.section.7.2.p.4">A Message map MUST contain a token (2) key, whose value is a 16-byte array.  See <a href="#cbor-tokens" class="xref">Section 7.16</a> for details.</p>
<p id="rfc.section.7.2.p.5">A Message map MUST contain a content (23) key, whose value is an array of Message Sections; a Message Section is either an Assertion, Shard, Zone, Query, or Notification.</p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#message-section-header" id="message-section-header">Message Section header</a>
</h1>
<p id="rfc.section.7.3.p.1">Each Message Section in the Message&#8217;s content value MUST be a two-element array.  The first element in the array is the message section type, encoded as an integer as in <a href="#tabsection" class="xref">Table 2</a>. The second element in the array is a message section body, a CBOR map defined as in the subsections <a href="#cbor-assertion" class="xref">Section 7.4</a>-<a href="#cbor-notification" class="xref">Section 7.13</a></p>
<div id="rfc.table.2"></div>
<div id="tabsection"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Message Section Type Codes</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Name</th>
<th class="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">assertion</td>
<td class="left">Assertion (see <a href="#cbor-assertion" class="xref">Section 7.4</a>)</td>
</tr>
<tr>
<td class="right">-1</td>
<td class="left">revassertion</td>
<td class="left">Address Assertion (see <a href="#cbor-revassert" class="xref">Section 7.11</a>)</td>
</tr>
<tr>
<td class="right">2</td>
<td class="left">shard</td>
<td class="left">Shard (see <a href="#cbor-shard" class="xref">Section 7.5</a>)</td>
</tr>
<tr>
<td class="right">3</td>
<td class="left">zone</td>
<td class="left">Zone (see <a href="#cbor-zone" class="xref">Section 7.7</a>)</td>
</tr>
<tr>
<td class="right">4</td>
<td class="left">query</td>
<td class="left">Query (see <a href="#cbor-query" class="xref">Section 7.8</a>)</td>
</tr>
<tr>
<td class="right">-4</td>
<td class="left">revquery</td>
<td class="left">Address Query (see <a href="#cbor-revquery" class="xref">Section 7.12</a>)</td>
</tr>
<tr>
<td class="right">5</td>
<td class="left">auquery</td>
<td class="left">Assertion update query (see <a href="#cbor-auquery" class="xref">Section 7.9</a>)</td>
</tr>
<tr>
<td class="right">6</td>
<td class="left">nuquery</td>
<td class="left">Nonexistence update query (see <a href="#cbor-nuquery" class="xref">Section 7.10</a>)</td>
</tr>
<tr>
<td class="right">7</td>
<td class="left">P-Shard</td>
<td class="left">P-Shard (see <a href="#cbor-P-Shard" class="xref">Section 7.6</a>)</td>
</tr>
<tr>
<td class="right">23</td>
<td class="left">notification</td>
<td class="left">Notification (see <a href="#cbor-notification" class="xref">Section 7.13</a>)</td>
</tr>
</tbody>
</table>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#cbor-assertion" id="cbor-assertion">Assertion body</a>
</h1>
<p id="rfc.section.7.4.p.1">An Assertion body is a map. The keys present in this map depend on whether the Assertion is contained in a Message, Shard or Zone.</p>
<p id="rfc.section.7.4.p.2">Assertions contained in a Message&#8217;s content value are &#8220;bare Assertions&#8221;. Since they cannot inherit any values from their containers, they MUST contain the signatures (0), subject-name (3), subject-zone (4), context (6), and objects (7) keys.</p>
<p id="rfc.section.7.4.p.3">Assertions within a Shard or Zone are &#8220;contained Assertions&#8221;, and can inherit values from their containers. A contained Assertion MUST contain the subject- name (3) and objects (7) keys. The subject-zone (4) and context (6) keys MUST NOT be present. They are assumed to have the same value as the corresponding values in the containing Shard or Zone for signature generation and signature verification purposes; see <a href="#cbor-signature" class="xref">Section 7.17</a>.</p>
<p id="rfc.section.7.4.p.4">A contained Assertion SHOULD contain the signatures (0) key, since an unsigned contained Assertion cannot be used by a RAINS server to answer a query; it must be returned in a signed Shard or Zone.</p>
<p id="rfc.section.7.4.p.5">The value of the signatures (0) key, if present, is an array of one or more Signatures as defined in <a href="#cbor-signature" class="xref">Section 7.17</a>. If not present, the containing Shard or Zone MUST be signed. Signatures on a contained Assertion are generated as if the inherited subject-zone and context values are present in the Assertion, whether actually present or not. The signatures on the Assertion are to be verified against the appropriate key for the Zone containing the Assertion in the given context, as described in <a href="#signatures-in-assertions" class="xref">Section 5.1.2</a>.</p>
<p id="rfc.section.7.4.p.6">The value of the subject-name (3) key is a UTF-8 encoded <a href="#RFC3629" class="xref">[RFC3629]</a> string containing the name of the subject of the assertion. The subject name MAY contain dot(s) &#8216;.&#8217;. The subject name never contains the zone in which the subject name is registered; the fully-qualified name is obtained by joining the subject-name to the subject-zone with a &#8216;.&#8217; character. The subject-name must be valid according to the nameset expression for the zone, if any.</p>
<p id="rfc.section.7.4.p.7">The value of the subject-zone (4) key, if present, is a UTF-8 encoded string containing the name of the zone in which the assertion is made and MUST end with &#8216;.&#8217; (the root zone). If not present, the zone of the assertion is inherited from the containing Shard or Zone.</p>
<p id="rfc.section.7.4.p.8">The value of the context (6) key, if present, is a UTF-8 encoded string containing the name of the context in which the assertion is valid. Both the authority-part and the context-part MUST end with a &#8216;.&#8217;. If not present, the context of the assertion is inherited from the containing Shard or Zone.</p>
<p id="rfc.section.7.4.p.9">The value of the objects (7) key is an array of objects, as defined in <a href="#cbor-object" class="xref">Section 7.14</a>.</p>
<h1 id="rfc.section.7.4.1">
<a href="#rfc.section.7.4.1">7.4.1.</a> <a href="#cbor-assertion-sorting" id="cbor-assertion-sorting">Sorting Assertions</a>
</h1>
<p id="rfc.section.7.4.1.p.1">Assertions are sorted lexicographically by their cbor encoded byte string in ascending order. That means, they are sorted by the following elements in the mentioned order: fully qualified name, context, type, object value(s), signature meta data.</p>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> <a href="#cbor-shard" id="cbor-shard">Shard body</a>
</h1>
<p id="rfc.section.7.5.p.1">A Shard body is a map. The keys present in the map depend on whether the Shard is contained in a Message or in a Zone.</p>
<p id="rfc.section.7.5.p.2">Shards contained in a Message&#8217;s content value are &#8220;bare Shards&#8221;. Since they cannot inherit any values from their contained Zone, they MUST contain the content (23), signatures (0), subject-zone (4), context (6), and range (11) keys.</p>
<p id="rfc.section.7.5.p.3">Shards within a Zone are &#8220;contained Shards&#8221;, and can inherit values from their containing Zone. A contained Shard MUST contain the range(11) and content (23) keys. The subject-zone (4) and context (6) keys MUST NOT be present. They are assumed to have the same value as the corresponding values in the containing Zone for signature generation and signature verification purposes; see <a href="#cbor-signature" class="xref">Section 7.17</a>.</p>
<p id="rfc.section.7.5.p.4">A contained Shard SHOULD contain the signatures (0) key, since an unsigned contained Shard cannot be used by a RAINS server to answer a query for nonexistence; it must be returned in a signed Zone.</p>
<p id="rfc.section.7.5.p.5">The value of the content (23) key is an array of Assertion bodies as defined in <a href="#cbor-assertion" class="xref">Section 7.4</a>. Assertions within a Shard MUST be sorted according to <a href="#cbor-assertion-sorting" class="xref">Section 7.4.1</a>.</p>
<p id="rfc.section.7.5.p.6">The value of the signatures (0) key, if present, is an array of one or more Signatures as defined in <a href="#cbor-signature" class="xref">Section 7.17</a>. If not present, the containing Zone MUST be signed. Signatures on a contained Shard are generated as if the inherited subject-zone and context values are present in the Shard, whether actually present or not. The signatures on the Shard are to be verified against the appropriate key for the Zone containing the Shard in the given context, as described in <a href="#signatures-in-assertions" class="xref">Section 5.1.2</a>.</p>
<p id="rfc.section.7.5.p.7">The value of the subject-zone (4) key, if present, is a UTF-8 encoded string containing the name of the zone in which the Assertions within the Shard is made and MUST end with &#8216;.&#8217; (the root zone). If not present, the zone of the assertion is inherited from the containing Zone.</p>
<p id="rfc.section.7.5.p.8">The value of the context (6) key, if present, is a UTF-8 encoded string containing the name of the context in which the Assertions within the Shard are valid. Both the authority-part and the context-part MUST end with a &#8216;.&#8217;. If not present, the context of the assertion is inherited from the containing Zone.</p>
<p id="rfc.section.7.5.p.9">The value of the range (11) key MUST be a two element array of strings or nulls (subject-name A, subject-name B). A must lexicographically sort before B, but neither subject name need be present in the shard&#8217;s contents. If A is null, the shard begins at the beginning of the zone. If B is null, the shard ends at the end of the zone. The shard MUST NOT contain any assertions whose subject names sort before A or after B.</p>
<p id="rfc.section.7.5.p.10">Shards are lexicographically complete within the range described in the range value: a subject-name within the range that is not contained in the shard is asserted to not exist.</p>
<h1 id="rfc.section.7.5.1">
<a href="#rfc.section.7.5.1">7.5.1.</a> <a href="#cbor-shard-sorting" id="cbor-shard-sorting">Sorting Shards</a>
</h1>
<p id="rfc.section.7.5.1.p.1">Shards are sorted lexicographically by their cbor encoded byte string in ascending order. That means, they are sorted by the following elements in the mentioned order: zone name, context, range begin, range end, content, signature meta data.</p>
<h1 id="rfc.section.7.6">
<a href="#rfc.section.7.6">7.6.</a> <a href="#cbor-P-Shard" id="cbor-P-Shard">P-Shard body</a>
</h1>
<p id="rfc.section.7.6.p.1">A P-Shard body is a map. The keys present in the map depend on whether the P-Shard is contained in a Message or in a Zone.</p>
<p id="rfc.section.7.6.p.2">P-Shards contained in a Message&#8217;s content value are &#8220;bare P-Shards&#8221;. Since they cannot inherit any values from their contained Zone, they MUST contain the signatures (0), subject-zone (4), context (6), range (11), and data-structure (18) keys.</p>
<p id="rfc.section.7.6.p.3">P-Shards within a Zone are &#8220;contained P-Shards&#8221;, and can inherit values from their containing Zone. A contained P-Shards MUST contain the the range(11) and data-structure (18) keys. The subject-zone (4) and context (6) keys MUST NOT be present. They are assumed to have the same value as the corresponding values in the containing Zone for signature generation and signature verification purposes; see <a href="#cbor-signature" class="xref">Section 7.17</a>.</p>
<p id="rfc.section.7.6.p.4">A contained P-Shard SHOULD contain the signatures (0) key, since an unsigned contained P-Shard cannot be used by a RAINS server to answer a query for nonexistence; it must be returned in a signed Zone.</p>
<p id="rfc.section.7.6.p.5">The value of the signatures (0) key, if present, is an array of one or more Signatures as defined in <a href="#cbor-signature" class="xref">Section 7.17</a>. If not present, the containing Zone MUST be signed. Signatures on a contained P-Shard are generated as if the inherited subject-zone and context values are present in the P-Shard, whether actually present or not. The signatures on the P-Shard are to be verified against the appropriate key for the Zone containing the P-Shard in the given context, as described in <a href="#signatures-in-assertions" class="xref">Section 5.1.2</a>.</p>
<p id="rfc.section.7.6.p.6">The value of the subject-zone (4) key, if present, is a UTF-8 encoded string containing the name of the zone in which the Assertions in the P-Shard is made and MUST end with &#8216;.&#8217; (the root zone). If not present, the zone of the assertion is inherited from the containing Zone.</p>
<p id="rfc.section.7.6.p.7">The value of the context (6) key, if present, is a UTF-8 encoded string containing the name of the context in which the Assertions in the P-Shard are valid. Both the authority-part and the context-part MUST end with a &#8216;.&#8217;.  If not present, the context of the assertion is inherited from the containing Zone.</p>
<p id="rfc.section.7.6.p.8">The value of the range (11) key MUST be a two element array of strings or nulls (subject-name A, subject-name B). A must lexicographically sort before B, but neither subject name need be present in the P-Shard&#8217;s contents. If A is null, the P-Shard begins at the beginning of the zone. If B is null, the P-Shard ends at the end of the zone. The P-Shard MUST NOT contain any assertions whose subject names sort before A or after B.</p>
<p id="rfc.section.7.6.p.9">The value of the data-structure (18) key is an array of elements, as defined in <a href="#cbor-data-structure" class="xref">Section 7.15</a>.</p>
<p id="rfc.section.7.6.p.10">P-Shards are lexicographically complete within the range described in the range value: a subject-name and type within the range of a P-Shard giving a negative answer is asserted to not exist.</p>
<h1 id="rfc.section.7.6.1">
<a href="#rfc.section.7.6.1">7.6.1.</a> <a href="#cbor-P-Shard-sorting" id="cbor-P-Shard-sorting">Sorting P-Shard</a>
</h1>
<p id="rfc.section.7.6.1.p.1">P-Shards are sorted lexicographically by their cbor encoded byte string in ascending order. That means, they are sorted by the following elements in the mentioned order: zone name, context, range begin, range end, hash family, number of hash functions, filter, signature meta data.</p>
<h1 id="rfc.section.7.7">
<a href="#rfc.section.7.7">7.7.</a> <a href="#cbor-zone" id="cbor-zone">Zone body</a>
</h1>
<p id="rfc.section.7.7.p.1">A Zone body is a map. Zones MUST contain the content (23), signatures (0), subject-zone (4), and context (6) keys.</p>
<p id="rfc.section.7.7.p.2">Signatures on the Zone are to be verified against the appropriate key for the Zone in the given context, as described in <a href="#signatures-in-assertions" class="xref">Section 5.1.2</a>.</p>
<p id="rfc.section.7.7.p.3">The value of the content (23) key is an array of Shard bodies as defined in <a href="#cbor-shard" class="xref">Section 7.5</a>, P-Shard bodies as defined in <a href="#cbor-P-Shard" class="xref">Section 7.6</a> and/or Assertion bodies as defined in <a href="#cbor-assertion" class="xref">Section 7.4</a>. Assertions, P-Shards and Shards in the content array MUST be sorted. Assertions are sorted before P-Shards, which in turn are sorted before Shards. Groups of the same section type are sorted according to <a href="#cbor-assertion-sorting" class="xref">Section 7.4.1</a>, <a href="#cbor-P-Shard-sorting" class="xref">Section 7.6.1</a>, and <a href="#cbor-shard-sorting" class="xref">Section 7.5.1</a>.</p>
<p id="rfc.section.7.7.p.4">The value of the subject-zone (4) key is a UTF-8 encoded string containing the name of the Zone which MUST end with &#8216;.&#8217; (the root zone).</p>
<p id="rfc.section.7.7.p.5">The value of the context (6) key is a UTF-8 encoded string containing the name of the context for which the Zone is valid. Both the authority-part and the context-part MUST end with a &#8216;.&#8217;.</p>
<h1 id="rfc.section.7.8">
<a href="#rfc.section.7.8">7.8.</a> <a href="#cbor-query" id="cbor-query">Query body</a>
</h1>
<p id="rfc.section.7.8.p.1">A Query body is a map. Queries MUST contain the query-name (8), context (6), query-types (10), and query-expires (12) keys. Queries MAY contain the query-opts (13), and the key-phases (17) keys.</p>
<p id="rfc.section.7.8.p.2">The value of the query-name (8) key is a UTF-8 encoded string containing the name for which the query is issued and MUST end with a &#8216;.&#8217; (the root zone).</p>
<p id="rfc.section.7.8.p.3">The value of the context (6) key is a UTF-8 encoded string containing the name of the context to which a query pertains. A zero-length string indicates that assertions will be accepted in any context.</p>
<p id="rfc.section.7.8.p.4">The value of the query-types (10) key is an array of integers encoding the type(s) of objects (as in <a href="#cbor-object" class="xref">Section 7.14</a>) acceptable in answers to the query.  All values in the query-type array are treated at equal priority: [2,3] means the querier is equally interested in both IPv4 and IPv6 addresses for the query-name. An empty query-types array indicates that objects of any type are acceptable in answers to the query.</p>
<p id="rfc.section.7.8.p.5">The value of the key-phases (17) key is an array of integers representing all key phases (see <a href="#cbor-signature" class="xref">Section 7.17</a>) expected in delegation assertion answers to the query. The value of the key-phases (17) key MUST NOT be empty when the query asks for delegation assertion(s). Otherwise, it MUST be empty.</p>
<p id="rfc.section.7.8.p.6">The value of the query-expires (12) key, is a CBOR integer counting seconds since the UNIX epoch UTC, identified with tag value 1 and encoded as in section 2.4.1 of <a href="#RFC7049" class="xref">[RFC7049]</a>. After the query-expires time, the query will have been considered not answered by the original issuer.</p>
<p id="rfc.section.7.8.p.7">The value of the query-opts (13) key, if present, is an array of integers in priority order of the querier&#8217;s preferences in tradeoffs in answering the query, as in <a href="#tabqopts" class="xref">Table 3</a>.</p>
<div id="rfc.table.3"></div>
<div id="tabqopts"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Query Option Codes</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">Minimize end-to-end latency</td>
</tr>
<tr>
<td class="right">2</td>
<td class="left">Minimize last-hop answer size (bandwidth)</td>
</tr>
<tr>
<td class="right">3</td>
<td class="left">Minimize information leakage beyond first hop</td>
</tr>
<tr>
<td class="right">4</td>
<td class="left">No information leakage beyond first hop: cached answers only</td>
</tr>
<tr>
<td class="right">5</td>
<td class="left">Expired assertions are acceptable</td>
</tr>
<tr>
<td class="right">6</td>
<td class="left">Enable query token tracing</td>
</tr>
<tr>
<td class="right">7</td>
<td class="left">Disable verification delegation (client protocol only)</td>
</tr>
<tr>
<td class="right">8</td>
<td class="left">Suppress proactive caching of future assertions</td>
</tr>
<tr>
<td class="right">9</td>
<td class="left">Maximize freshness of result</td>
</tr>
<tr>
<td class="right">10</td>
<td class="left">P-Shard not accepted</td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.8.p.8">Options 1-5 and 9 specify performance/privacy tradeoffs. Each server is free to determine how to minimize each performance metric requested; however, servers MUST NOT generate queries to other servers if &#8220;no information leakage&#8221; is specified, and servers MUST NOT return expired assertions unless &#8220;expired assertions acceptable&#8221; is specified.</p>
<p id="rfc.section.7.8.p.9">Option 6 specifies that a given token (see <a href="#cbor-tokens" class="xref">Section 7.16</a>) should be used on all queries resulting from a given query, allowing traceability through an entire RAINS infrastructure. It is meant for debugging purposes.</p>
<p id="rfc.section.7.8.p.10">By default, a client service will perform verification of negative queries and return a 404 No Assertion Exists for queries with a consistent proof of non- existence, within a message signed by the query service&#8217;s infrakey. Option 7 disables this behavior, and causes the query service to return the shard proving nonexistence for verification by the client. It is intended to be used with untrusted query services.</p>
<p id="rfc.section.7.8.p.11">Option 8 specifies that a querier&#8217;s interest in a query is strictly ephemeral, and that future assertions related to this query SHOULD NOT be proactively pushed to the querier.</p>
<p id="rfc.section.7.8.p.12">Options 9-12 specify a client&#8217;s preference in the server&#8217;s mode of operation. A server is free to decide if it wants to follow the client&#8217;s preference according to its configuration and policy. E.g. if a server determines it is used in a DDoS attack against a naming server, it stops forwarding queries to this server and only serve cached entries. Option 9 prevents the server to make a negative cache lookup and instead directly does a recursive lookup. Option 10 directly returns the section in a negative cache hit without checking if it is still up to date. Option 11 sends a nonexistence update query to the naming server in case there is a negative cache hit. Option 12 requests a notification response before the server forwards the query if there is a negative cache hit. This is especially useful with option 11 to get feedback early, e.g. to correct a typo.</p>
<p id="rfc.section.7.8.p.13">Option 10 states if a P-Shard is accepted as a nonexistence proof. As P-Shards have false positives, a client has the possibility to request a shard or zone to be certain with this option. Depending on the servers&#8217; configurations, a false positive check can be done at the naming server, an intermediate server or at the client.</p>
<h1 id="rfc.section.7.9">
<a href="#rfc.section.7.9">7.9.</a> <a href="#cbor-auquery" id="cbor-auquery">Assertion Update Query body</a>
</h1>
<p id="rfc.section.7.9.p.1">An Assertion Update Query body is a map. Assertion Update Queries MUST contain the query-name (8), hash-type (14), hash-value (15), and query-expires (12) keys. Assertion Update Queries MAY contain the query-opts (13) keys.</p>
<p id="rfc.section.7.9.p.2">The value of the query-name (8) key is a UTF-8 encoded string containing the fully-qualified name for which the update query is issued and MUST end with a &#8216;.&#8217; (the root zone).</p>
<p id="rfc.section.7.9.p.3">The value of the hash-type (14) key is an integer specifying a hash function identifier used to generate the hash-value of the assertion, as in <a href="#tabhash" class="xref">Table 8</a>.</p>
<p id="rfc.section.7.9.p.4">The value of the hash-value (15) key is the hash of the assertion for which an update is requested. The hash is generated over a byte stream representing the assertion in a canonical signing format <a href="#cbor-signature" class="xref">Section 7.17</a> (The signature itself is not hashed). The format is defined by the hash-type.</p>
<p id="rfc.section.7.9.p.5">The value of the query-expires (12) key, is a CBOR integer counting seconds since the UNIX epoch UTC, identified with tag value 1 and encoded as in section 2.4.1 of <a href="#RFC7049" class="xref">[RFC7049]</a>. After the query-expires time, the update query will have been considered not answered by the original issuer.</p>
<p id="rfc.section.7.9.p.6">The value of the query-opts (13) key, if present, is an array of integers in priority order of the querier&#8217;s preferences in tradeoffs in answering the assertion update query, as in <a href="#tabqopts" class="xref">Table 3</a>. Only query option codes 1, 2, 3, 6, 7, 8 are allowed.</p>
<h1 id="rfc.section.7.10">
<a href="#rfc.section.7.10">7.10.</a> <a href="#cbor-nuquery" id="cbor-nuquery">Nonexistence Update Query body</a>
</h1>
<p id="rfc.section.7.10.p.1">A Nonexistence Update Query body is a map. Nonexistence Update Queries MUST contain the query-name (8), context (6), query-types (10), hash-type (14), hash-value (15), and query-expires (12) keys. Nonexistence Update Queries MAY contain the query-opts (13) keys.</p>
<p id="rfc.section.7.10.p.2">The value of the query-name (8) key is a UTF-8 encoded string containing the fully-qualified name for which the update query is issued and MUST end with a &#8216;.&#8217; (the root zone).</p>
<p id="rfc.section.7.10.p.3">The value of the context (6) key is a UTF-8 encoded string containing the name of the context to which an update query pertains. A zero-length string indicates that assertions will be accepted in any context.</p>
<p id="rfc.section.7.10.p.4">The value of the query-types (10) key is an array of integers encoding the type(s) of objects (as in <a href="#cbor-object" class="xref">Section 7.14</a>) acceptable in answers to the update query. All values in the query-type array are treated at equal priority: [2,3] means the querier is equally interested in both IPv4 and IPv6 addresses for the query-name. An empty query-types array indicates that objects of any type are acceptable in answers to the query.</p>
<p id="rfc.section.7.10.p.5">The value of the hash-type (14) key is an integer specifying a hash function identifier used to generate the hash-value of the assertion, as in <a href="#tabhash" class="xref">Table 8</a>.</p>
<p id="rfc.section.7.10.p.6">The value of the hash-value (15) key is the hash of the assertion for which an update is requested. The hash is generated over a byte stream representing the assertion in a canonical signing format <a href="#cbor-signature" class="xref">Section 7.17</a> (The signature itself is not hashed). The format is defined by the hash-type.</p>
<p id="rfc.section.7.10.p.7">The value of the query-expires (12) key, is a CBOR integer counting seconds since the UNIX epoch UTC, identified with tag value 1 and encoded as in section 2.4.1 of <a href="#RFC7049" class="xref">[RFC7049]</a>. After the query-expires time, the update query will have been considered not answered by the original issuer.</p>
<p id="rfc.section.7.10.p.8">The value of the query-opts (13) key, if present, is an array of integers in priority order of the querier&#8217;s preferences in tradeoffs in answering the nonexistence update query, as in <a href="#tabqopts" class="xref">Table 3</a>. Only query option codes 1, 2, 3, 6, 7, 8 are allowed.</p>
<h1 id="rfc.section.7.11">
<a href="#rfc.section.7.11">7.11.</a> <a href="#cbor-revassert" id="cbor-revassert">Address Assertion body</a>
</h1>
<p id="rfc.section.7.11.p.1">Assertions about addresses are similar to assertions about names, but keyed by address and restricted in terms of the objects they can contain. An Address Assertion body is a map which MUST contain the signatures (0), subject-addr (5), context (6), and objects (7) keys.</p>
<p id="rfc.section.7.11.p.2">The value of the signatures (0) key is an array of one or more Signatures as defined in <a href="#cbor-signature" class="xref">Section 7.17</a>.</p>
<p id="rfc.section.7.11.p.3">The value of the subject-addr (5) key is a three element CBOR array. The first element of the array is the address family encoded as an object type, 2 for IPv6 addresses and 3 for IPv4 addresses. The second element is the prefix length encoded as an integer, 0-128 for IPv6 and 0-32 for IPv4. The third element is the address, encoded as in <a href="#cbor-object" class="xref">Section 7.14</a>. Subject addresses with the maximum prefix length for the address family are subject host addresses, and are nameable; subject addresses with less than the maximum prefix length are subject network addresses, and are delegatable.</p>
<p id="rfc.section.7.11.p.4">The value of the context (6) key is a UTF-8 string containing the name of the context in which the Address Assertion is valid. See <a href="#context-in-address-assertions" class="xref">Section 6.5.1</a>.</p>
<p id="rfc.section.7.11.p.5">The value of the objects (7) key is an array of objects, as defined in <a href="#cbor-object" class="xref">Section 7.14</a>. Only object types redirection, delegation, and registrant are available for subject network addresses, and only object type name is available for subject host addresses.</p>
<h1 id="rfc.section.7.12">
<a href="#rfc.section.7.12">7.12.</a> <a href="#cbor-revquery" id="cbor-revquery">Address Query body</a>
</h1>
<p id="rfc.section.7.12.p.1">Queries for assertions about addresses are similar to queries for assertions about names, but have semantic restrictions similar to those for Address Assertions.</p>
<p id="rfc.section.7.12.p.2">An Address Query body is a map. Queries MUST contain the subject-addr (5), context (6), query-types (10), and query-expires (12) keys. Address Queries MAY contain query-opts (13) key.</p>
<p id="rfc.section.7.12.p.3">The value of the subject-addr (5) key is a three-element CBOR array. The first element of the array is the address family encoded as an object type, 2 for IPv6 addresses and 3 for IPv4 addresses. The second element is the prefix length encoded as an integer, 0-128 for IPv6 and 0-32 for IPv4. The third element is the address, encoded as in <a href="#cbor-object" class="xref">Section 7.14</a>.</p>
<p id="rfc.section.7.12.p.4">The value of the context (6) key is a UTF-8 encoded string containing the name of the context for which the Query is valid. Unlike queries for names, Address Queries can only pertain to a single context. See <a href="#context-in-address-assertions" class="xref">Section 6.5.1</a> for more.</p>
<p id="rfc.section.7.12.p.5">The value of the query-types (10) key is an array of integers encoding the type(s) of objects (as in <a href="#cbor-object" class="xref">Section 7.14</a>) acceptable in answers to the query.  All values in the query-type array are treated at equal priority: [4,5] means the querier is equally interested in both redirection and delegation for the subject-addr. An empty query-types array indicates that objects of any type are acceptable in answers to the query.</p>
<p id="rfc.section.7.12.p.6">The value of the query-expires (12) key is a CBOR integer counting seconds since the UNIX epoch UTC, identified with tag value 1 and encoded as in section 2.4.1 of <a href="#RFC7049" class="xref">[RFC7049]</a>. After the query-expires time, the query will have been considered not answered by the original issuer.</p>
<p id="rfc.section.7.12.p.7">The value of the query-opts (13) key, if present, is an array of integers in priority order of the querier&#8217;s preferences in tradeoffs in answering the query, as in <a href="#tabqopts" class="xref">Table 3</a>. See <a href="#cbor-query" class="xref">Section 7.8</a> for more.</p>
<p id="rfc.section.7.12.p.8">An Address Assertion with a more-specific prefix is preferred over a less-specific in response to a Address Query.</p>
<h1 id="rfc.section.7.13">
<a href="#rfc.section.7.13">7.13.</a> <a href="#cbor-notification" id="cbor-notification">Notification body</a>
</h1>
<p id="rfc.section.7.13.p.1">Notification Message Sections contain information about the operation of the RAINS protocol itself. A Notification Message Section body is a map which MUST contain the token (2) and note-type (21) keys and MAY contain the note-data (22) key. The value of the note-type key is encoded as an integer as in the <a href="#tabnotify" class="xref">Table 4</a>.</p>
<div id="rfc.table.4"></div>
<div id="tabnotify"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Notification Type Codes</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td class="right">100</td>
<td class="left">Connection heartbeat</td>
</tr>
<tr>
<td class="right">200</td>
<td class="left">The hashed section in an update query is still fine</td>
</tr>
<tr>
<td class="right">210</td>
<td class="left">The hashed assertion has been revoked and is no longer valid</td>
</tr>
<tr>
<td class="right">211</td>
<td class="left">More specific information may follow</td>
</tr>
<tr>
<td class="right">399</td>
<td class="left">Capability hash not understood</td>
</tr>
<tr>
<td class="right">400</td>
<td class="left">Bad message received</td>
</tr>
<tr>
<td class="right">403</td>
<td class="left">Inconsistent message received</td>
</tr>
<tr>
<td class="right">404</td>
<td class="left">No assertion exists (client protocol only)</td>
</tr>
<tr>
<td class="right">413</td>
<td class="left">Message too large</td>
</tr>
<tr>
<td class="right">500</td>
<td class="left">Unspecified server error</td>
</tr>
<tr>
<td class="right">501</td>
<td class="left">Server not capable</td>
</tr>
<tr>
<td class="right">504</td>
<td class="left">No assertion available</td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.13.p.2">Note that the status codes are chosen to be mnemonically similar to status codes for HTTP <a href="#RFC7231" class="xref">[RFC7231]</a>. Details of the meaning of each status code are given in <a href="#protocol-def" class="xref">Section 9</a>.</p>
<p id="rfc.section.7.13.p.3">The value of the token (2) key is a 16-byte array, which MUST contain the token of the message or query to which the notification is a response. See <a href="#cbor-tokens" class="xref">Section 7.16</a>.</p>
<p id="rfc.section.7.13.p.4">The value of the note-data (22) key, if present, is a UTF-8 encoded string with additional information about the notification, intended to be displayed to an administrator to help debug the issue identified by the negotiation.</p>
<h1 id="rfc.section.7.14">
<a href="#rfc.section.7.14">7.14.</a> <a href="#cbor-object" id="cbor-object">Object</a>
</h1>
<p id="rfc.section.7.14.p.1">Objects are encoded as arrays in CBOR, where the first element is the type of the object, encoded as an integer in the following table:</p>
<div id="rfc.table.5"></div>
<div id="tabobj"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Object type codes</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Name</th>
<th class="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">name</td>
<td class="left">name associated with subject</td>
</tr>
<tr>
<td class="right">2</td>
<td class="left">ip6-addr</td>
<td class="left">IPv6 address of subject</td>
</tr>
<tr>
<td class="right">3</td>
<td class="left">ip4-addr</td>
<td class="left">IPv4 address of subject</td>
</tr>
<tr>
<td class="right">4</td>
<td class="left">redirection</td>
<td class="left">name of zone authority server</td>
</tr>
<tr>
<td class="right">5</td>
<td class="left">delegation</td>
<td class="left">public key for zone delgation</td>
</tr>
<tr>
<td class="right">6</td>
<td class="left">nameset</td>
<td class="left">name set expression for zone</td>
</tr>
<tr>
<td class="right">7</td>
<td class="left">cert-info</td>
<td class="left">certificate information for name</td>
</tr>
<tr>
<td class="right">8</td>
<td class="left">service-info</td>
<td class="left">service information for srvname</td>
</tr>
<tr>
<td class="right">9</td>
<td class="left">registrar</td>
<td class="left">registrar information</td>
</tr>
<tr>
<td class="right">10</td>
<td class="left">registrant</td>
<td class="left">registrant information</td>
</tr>
<tr>
<td class="right">11</td>
<td class="left">infrakey</td>
<td class="left">public key for RAINS infrastructure</td>
</tr>
<tr>
<td class="right">12</td>
<td class="left">extrakey</td>
<td class="left">external public key for subject</td>
</tr>
<tr>
<td class="right">13</td>
<td class="left">nextkey</td>
<td class="left">next public key for subject</td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.14.p.2">A name (1) object contains a name associated with a name as an alias. It is represented as a three-element array. The second element is a fully-qualified name as a UTF-8 encoded string. The third type is an array of object type codes for which the alias is valid, with the same semantics as the query-types (9) key in queries (see <a href="#cbor-query" class="xref">Section 7.8</a>).</p>
<p id="rfc.section.7.14.p.3">An ip6-addr (2) object contains an IPv6 address associated with a name. It is represented as a two element array. The second element is a byte array of length 16 containing an IPv6 address in network byte order.</p>
<p id="rfc.section.7.14.p.4">An ip4-addr (3) object contains an IPv4 address associated with a name. It is represented as a two element array. The second element is a byte array of length 4 containing an IPv4 address in network byte order.</p>
<p id="rfc.section.7.14.p.5">A redirection (4) object contains the fully-qualified name of a RAINS authority server for a named zone. It is represented as a two-element array.  The second element is a fully-qualified name of an RAINS authority server as a UTF-8 encoded string.</p>
<p id="rfc.section.7.14.p.6">A delegation (5) object contains a public key used to generate signatures on assertions in a named zone, and by which a delegation of a name within a zone to a subordinate zone may be verified. It is represented as an N-element array. The second element is a signature algorithm identifier as in <a href="#cbor-signature" class="xref">Section 7.17</a>. The third element is a key phase as in <a href="#cbor-signature" class="xref">Section 7.17</a>. Additional elements are as defined in <a href="#cbor-signature" class="xref">Section 7.17</a> for the given algorithm identifier and RAINS delegation chain keyspace.</p>
<p id="rfc.section.7.14.p.7">A nameset (6) object contains an expression defining which names are allowed and which names are disallowed in a given zone. It is represented as a two- element array. The second element is a nameset expression to be applied to each name element within the zone without an intervening delegation, as defined in <a href="#cbor-nameset" class="xref">Section 7.14.2</a></p>
<p id="rfc.section.7.14.p.8">A cert-info (7) object contains an expression binding a certificate or certificate authority to a name, such that connections to the name must either use the bound certificate or a certificate signed by a bound authority. It is represented as an five-element array, as defined in <a href="#cbor-certinfo" class="xref">Section 7.14.1</a>.</p>
<p id="rfc.section.7.14.p.9">A service-info (8) object gives information about a named service. Services are named as in <a href="#RFC2782" class="xref">[RFC2782]</a>. It is represented as a four-element array. The second element is a fully-qualified name of a host providing the named service as a UTF-8 string. The third element is a transport port number as a positive integer in the range 0-65535. The fourth element is a priority as a positive integer, with lower numbers having higher priority.</p>
<p id="rfc.section.7.14.p.10">A registrar (9) object gives the name and other identifying information of the registrar (the organization which caused the name to be added to the namespace) for organization-level names. It is represented as a two element array. The second element is a UTF-8 string of maximum length 256 bytes containing identifying information chosen by the registrar according to the registry&#8217;s policy.</p>
<p id="rfc.section.7.14.p.11">A registrant (10) object gives information about the registrant of an organization-level name. It is represented as a two element array. The second element is a UTF-8 string with a maximum length of 4096 bytes containing this information, with a format chosen by the registrar according to the registry&#8217;s policy.</p>
<p id="rfc.section.7.14.p.12">An infrakey (11) object contains a public key used to generate signatures on messages by a named RAINS server, by which a RAINS message signature may be verified by a receiver. It is identical in structure to a delegation object, as defined in <a href="#cbor-signature" class="xref">Section 7.17</a>. Infrakey signatures are especially useful for clients which delegate verification to their query servers to authenticate the messages sent by the query server.</p>
<p id="rfc.section.7.14.p.13">An extrakey (12) object contains a public key used to generate signatures on assertions in a named zone outside of the normal delegation chain. It is represented as an 4-element array, where the second element is a signature algorithm identifier, and the third element is keyspace identifier, as in <a href="#cbor-signature" class="xref">Section 7.17</a>. The fourth element is the public key, as defined in <a href="#cbor-signature" class="xref">Section 7.17</a> for the given algorithm identifier. An extrakey may be matched with a public key obtained through other means for additional authentication of an assertion. Extrakeys are different from delegation keys in that they may not be used in the delegation chain: an extrakey signature is valid only on assertions of object types other than delegation.</p>
<p id="rfc.section.7.14.p.14">A nextkey (13) object contains the a public key that a zone owner would like its superordinate to delegate to in the future. It is represented as an 5-element array The second element is a signature algorithm identifier as in <a href="#cbor-signature" class="xref">Section 7.17</a>. The third element is the public key, as defined in <a href="#cbor-signature" class="xref">Section 7.17</a> for the given algorithm identifier. The fourth element is the requested-valid-since time, and the fifth element is the requested-valid-until time, formatted as for signatures as in <a href="#cbor-signature" class="xref">Section 7.17</a>. See <a href="#public-key-management" class="xref">Section 12.3</a> for more.</p>
<h1 id="rfc.section.7.14.1">
<a href="#rfc.section.7.14.1">7.14.1.</a> <a href="#cbor-certinfo" id="cbor-certinfo">Certificate information format</a>
</h1>
<p id="rfc.section.7.14.1.p.1">A cert-info object contains information about the certificate(s) that can be used to authenticate a transport-layer association with a named entity. It is encoded as a file-element array. The first element is the RAINS object type (7).  The second element is the protocol family specifier, describing the cryptographic protocol used to connect, as defined in <a href="#tabcertproto" class="xref">Table 6</a>. The protocol family defines the format of certificate data to be hashed. The third element is the certificate usage specifier as in <a href="#tabcertusage" class="xref">Table 7</a>, describing the constraint imposed by the assertion. These are defined to be compatible with Certificate Usages in the TLSA RRTYPE for DANE <a href="#RFC6698" class="xref">[RFC6698]</a>. The fourth element is the hash algorithm identifier, defining the hash algorithm used to generate the certificate data, as in <a href="#tabhash" class="xref">Table 8</a>. The fifth item is the data itself, whose format is defined by the protocol family and hash algorithm.</p>
<div id="rfc.table.6"></div>
<div id="tabcertproto"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Certificate information protocol families</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Name</th>
<th class="left">Protocol family</th>
<th class="left">Certificate format</th>
</tr></thead>
<tbody>
<tr>
<td class="right">0</td>
<td class="left">unspec</td>
<td class="left">Unspecified</td>
<td class="left">Unspecified</td>
</tr>
<tr>
<td class="right">1</td>
<td class="left">tls</td>
<td class="left">Transport Layer Security (TLS) <a href="#RFC8446" class="xref">[RFC8446]</a>
</td>
<td class="left"><a href="#RFC5280" class="xref">[RFC5280]</a></td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.14.1.p.2">Protocol family 0 leaves the protocol family unspecified; client validation and usage of cert-info assertions, and the protocol used to connect, are up to the client, and no information is stored in RAINS. Protocol family 1 specifies Transport Layer Security version 1.3 <a href="#RFC8446" class="xref">[RFC8446]</a> or a subsequent version, secured with PKIX <a href="#RFC5280" class="xref">[RFC5280]</a> certificates.</p>
<div id="rfc.table.7"></div>
<div id="tabcertusage"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Certificate information usage values</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Name</th>
<th class="left">Certificate usage</th>
</tr></thead>
<tbody>
<tr>
<td class="right">2</td>
<td class="left">ta</td>
<td class="left">Trust Anchor Certificate</td>
</tr>
<tr>
<td class="right">3</td>
<td class="left">ee</td>
<td class="left">End-Entity Certificate</td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.14.1.p.3">A trust anchor certificate constraint specifies a certificate that MUST appear as the trust anchor for the certificate presented by the subject of the assertion on a connection attempt. An end-entity certificate constraint specifies a certificate that MUST be presented by the subject of the assertion on a connection attempt.</p>
<div id="rfc.table.8"></div>
<div id="tabhash"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Hash algorithms</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Name</th>
<th class="left">Notes</th>
</tr></thead>
<tbody>
<tr>
<td class="right">0</td>
<td class="left">full</td>
<td class="left">Data contains full certificate</td>
</tr>
<tr>
<td class="right">1</td>
<td class="left">sha-256</td>
<td class="left">Data contains SHA-256 hash (32 bytes)</td>
</tr>
<tr>
<td class="right">2</td>
<td class="left">sha-512</td>
<td class="left">Data contains SHA-512 hash (64 bytes)</td>
</tr>
<tr>
<td class="right">3</td>
<td class="left">sha-384</td>
<td class="left">Data contains SHA-384 hash (48 bytes)</td>
</tr>
<tr>
<td class="right">4</td>
<td class="left">fnv-64</td>
<td class="left">Data contains FNV-64 hash (64 bytes)</td>
</tr>
<tr>
<td class="right">5</td>
<td class="left">murmur3-64</td>
<td class="left">Data contains murmur3-64 hash (64 bytes)</td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.14.1.p.4">Code 0 is used to store full certificates in RAINS assertions, while other codes are used to store hashes for verification.</p>
<p id="rfc.section.7.14.1.p.5">For example, in a cert-info object with values [ 7, 1, 3, 3, (data) ], the data would be a 48 SHA-384 hash of the ASN.1 DER-encoded X.509v3 certificate (see Section 4.1 of <a href="#RFC5280" class="xref">[RFC5280]</a>) to be presented by the endpoint on a connection attempt with TLS version 1.2 or later.</p>
<h1 id="rfc.section.7.14.2">
<a href="#rfc.section.7.14.2">7.14.2.</a> <a href="#cbor-nameset" id="cbor-nameset">Name expression format</a>
</h1>
<p id="rfc.section.7.14.2.p.1">The nameset expression is represented as a UTF-8 string encoding a modified POSIX Extended Regular Expression format (see POSIX.2) to be applied to each element of a name within the zone. A name containing an element that does not match the valid nameset expression for a zone is not valid within the zone, and the nameset assertion can be used to prove nonexistence.</p>
<p id="rfc.section.7.14.2.p.2">The POSIX character classes :alnum:, :alpha:, :ascii:, :digit:, :lower:, and :upper: are available in these regular expressions, where:</p>
<p></p>

<ul>
<li>:lower: matches all codepoints within the Unicode general category &#8220;Letter, lowercase&#8221;</li>
<li>:upper: matches all codepoints within the Unicode general category &#8220;Letter, uppercase&#8221;</li>
<li>:alpha: matches all codepoints within the Unicode general category &#8220;Letter&#8221;.</li>
<li>:digit: matches all codepoints within the Unicode general category &#8220;Number, decimal digit&#8221;</li>
<li>:alnum: is the union of :alpha: and :digit:</li>
<li>:ascii: matches all codepoints in the range 0x20-0x7f</li>
</ul>
<p id="rfc.section.7.14.2.p.4">In addition, each Unicode block is available as a character class, with the syntax :ublkXXXX: where XXXX is a 4 or 5 digit, zero-prefixed hex encoding of the first codepoint in the block. For example, the Cyrillic block is available as :ublk0400:.</p>
<p id="rfc.section.7.14.2.p.5">Unicode escapes are supported in these regular expressions; the sequence \uXXXX where XXXX is a 4 or 5 digit, possibly zero-prefixed hex encoding of the codepoint, is substituted with that codepoint.</p>
<p id="rfc.section.7.14.2.p.6">Set operations (intersection and subtraction) are available on character classes. Two character class or range expressions in a bracket expression joined by the sequence &amp;&amp; are equivalent to the intersection of the two character classes or ranges. Two character class or range expressions in a bracket expression joined by the sequence &#8211; are equivalent to the subtraction of the second character class or range from the first.</p>
<p id="rfc.section.7.14.2.p.7">For example, the nameset expression:</p>
<p id="rfc.section.7.14.2.p.8">[[:ublk0400:]&amp;&amp;[:lower:][:digit:]]+</p>
<p id="rfc.section.7.14.2.p.9">matches any name made up of one or more lowercase Cyrillic letters and digits. The same expression can be implemented with a range instead of a character class:</p>
<p id="rfc.section.7.14.2.p.10">[\u0400-\u04ff&amp;&amp;[:lower:][:digit:]]+</p>
<h1 id="rfc.section.7.15">
<a href="#rfc.section.7.15">7.15.</a> <a href="#cbor-data-structure" id="cbor-data-structure">Data structures</a>
</h1>
<p id="rfc.section.7.15.p.1">A data structure is encoded as an arrays in CBOR, where the first element is the type of the data structure, encoded as an integer in the following table:</p>
<div id="rfc.table.9"></div>
<div id="tabds"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Data structure type codes</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Name</th>
<th class="left">Description</th>
</tr></thead>
<tbody><tr>
<td class="right">1</td>
<td class="left">bloom-filter</td>
<td class="left">A bloom filter data structure</td>
</tr></tbody>
</table>
<p id="rfc.section.7.15.p.2">A bloom-filter (1) data structure is represented as a five-element array. The second element is an array of integers specifying a family of hash function(s) identifier, as in <a href="#tabhash" class="xref">Table 8</a>. The third element is an integer determining the number of hash functions used in the bloom filter from the specified family of hash functions. The fourth element is an integer specifying the mode of operation identifier, as in <a href="#tabbfopmode" class="xref">Table 10</a> The fifth element is a bit string representing the bloom filter itself as defined in <a href="#cbor-bloom-filter-bit-string" class="xref">Section 7.15.1</a></p>
<div id="rfc.table.10"></div>
<div id="tabbfopmode"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Bloom filter mode of operations</caption>
<thead><tr>
<th class="right">Code</th>
<th class="left">Name</th>
<th class="left">Description</th>
</tr></thead>
<tbody>
<tr>
<td class="right">0</td>
<td class="left">standard</td>
<td class="left">Provided hash functions are used</td>
</tr>
<tr>
<td class="right">1</td>
<td class="left">Kirsch-Mitzenmacher-1</td>
<td class="left">Kirsch-Mitzenmacher optimization with 1 hash function</td>
</tr>
<tr>
<td class="right">2</td>
<td class="left">Kirsch-Mitzenmacher-2</td>
<td class="left">Kirsch-Mitzenmacher optimization with 2 hash function</td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.15.p.3">For code 0, the number of provided hash function identifiers must be equal to the number of hash functions used in the bloom filter. The results of the hash functions are taken modulo the size of the bloom filter to determine which position to set or check in the filter.</p>
<p id="rfc.section.7.15.p.4">For code 1 and 2, instead of using k different hash functions to calculate the bit string of the bloom filter, it is sufficient to use one or two and then apply the Kirsch-Mitzenmacher-Optimization <a href="#BETTER-BLOOM-FILTER" class="xref">[BETTER-BLOOM-FILTER]</a>. If only one hash function is used, then its calculated hash value is split in half. The first part corresponds to the first hash function in the optimization and the second part to the second one. The following formula is used to obtain the position which will be set to or checked for a 1 according to the ith hash function:</p>
<p id="rfc.section.7.15.p.5">pos = (hash1 + hash2*i) modulo bit-string-size</p>
<h1 id="rfc.section.7.15.1">
<a href="#rfc.section.7.15.1">7.15.1.</a> <a href="#cbor-bloom-filter-bit-string" id="cbor-bloom-filter-bit-string">Bloom Filter Bit String</a>
</h1>
<p id="rfc.section.7.15.1.p.1">The bit string of an empty bloom filter is all zeros. To add an assertion, first, the assertion&#8217;s fully-qualified name, context and code of its type are concatenated separated by a space. This value is then hashed a certain amount of times with the provided hash functions depending on the mode of operation and the corresponding position(s) in the filter are set to one, see <a href="#tabbfopmode" class="xref">Table 10</a>.</p>
<p id="rfc.section.7.15.1.p.2">To check wether an assertion is not part of the bloom filter, the same process is repeated for the assertion in question. If any of the obtained filter position(s) is zero, then this assertion is certainly not contained.</p>
<h1 id="rfc.section.7.16">
<a href="#rfc.section.7.16">7.16.</a> <a href="#cbor-tokens" id="cbor-tokens">Tokens in queries and messages</a>
</h1>
<p id="rfc.section.7.16.p.1">Messages and notifications contain an opaque token (2) key, whose content is a 16-byte array, and is used to link Messages to the Queries they respond to, and Notifications to the Messages they respond to. Tokens MUST be treated as opaque values by RAINS servers.</p>
<p id="rfc.section.7.16.p.2">A Message sent in response to a Query (normal and update) MUST contain the token of the Message containing the Query. Otherwise, the Message MUST contain a token selected by the server originating it, so that future Notifications can be linked to the Message causing it. Likewise, a Notification sent in response to a Message MUST contain the token from the Message causing it (where the new Message contains a fresh token selected by the server). This allows sending multiple Notifications within one Message and the receiving server to respond to a Message containing Notifications (e.g. when it is malformed).</p>
<p id="rfc.section.7.16.p.3">Since tokens are used to link queries to replies, and to link notifications to messages, regardless of the sender or recipient of a message, they MUST be chosen by servers to be hard to guess; e.g. generated by a cryptographic random number generator.</p>
<p id="rfc.section.7.16.p.4">When a server creates a new query to forward to another server in response to a query it received, it MUST NOT use the same token on the delegated query as on the received query, unless option 6 Enable Tracing is present in the received, in which case it MUST use the same token.</p>
<h1 id="rfc.section.7.17">
<a href="#rfc.section.7.17">7.17.</a> <a href="#cbor-signature" id="cbor-signature">Signatures, delegation keys, and RAINS infrastructure keys</a>
</h1>
<p id="rfc.section.7.17.p.1">RAINS supports multiple signature algorithms and hash functions for signing assertions for cryptographic algorithm agility <a href="#RFC7696" class="xref">[RFC7696]</a>. A RAINS signature algorithm identifier specifies the signature algorithm; a hash function for generating the HMAC and the format of the encodings of the signature values in Assertions, Shards, Zones, and Messages, as well as of public key values in delegation objects.</p>
<p id="rfc.section.7.17.p.2">RAINS signatures have five common elements: the algorithm identifier, a keyspace identifier, a key phase, a valid-since timestamp, and a valid-until timestamp. Signatures are represented as an array of these five values followed by additional elements containing the signature data itself, according to the algorithm identifier.</p>
<p id="rfc.section.7.17.p.3">The following algorithms are supported:</p>
<div id="rfc.table.11"></div>
<div id="tabsig"></div>
<table cellpadding="3" cellspacing="0" class="tt full center">
<caption>Defined signature algorithms</caption>
<thead><tr>
<th class="right">Alg ID</th>
<th class="left">Signatures</th>
<th class="left">Hash/HMAC</th>
<th class="left">Format</th>
</tr></thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">ed25519</td>
<td class="left">sha-512</td>
<td class="left">See <a href="#eddsa-format" class="xref">Section 7.17.1</a>
</td>
</tr>
<tr>
<td class="right">2</td>
<td class="left">ed448</td>
<td class="left">shake256</td>
<td class="left">See <a href="#eddsa-format" class="xref">Section 7.17.1</a>
</td>
</tr>
<tr>
<td class="right">3</td>
<td class="left">ecdsa-256</td>
<td class="left">sha-256</td>
<td class="left">See <a href="#ecdsa-format" class="xref">Section 7.17.2</a>
</td>
</tr>
<tr>
<td class="right">4</td>
<td class="left">ecdsa-384</td>
<td class="left">sha-384</td>
<td class="left">See <a href="#ecdsa-format" class="xref">Section 7.17.2</a>
</td>
</tr>
</tbody>
</table>
<p id="rfc.section.7.17.p.4">As noted in <a href="#eddsa-format" class="xref">Section 7.17.1</a>, support for Algorithm 1, ed25519, is REQUIRED; other algorithms are OPTIONAL.</p>
<p id="rfc.section.7.17.p.5">The keyspace identifier associates the signature with a method for verifying signatures. This facility is used to support signatures on assertions from external sources (the extrakey object type). At present, one keyspace identifier is defined, and support for it is REQUIRED.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="right">Keyspace ID</th>
<th class="left">Name</th>
<th class="left">Signature Verification Algorithm</th>
</tr></thead>
<tbody><tr>
<td class="right">0</td>
<td class="left">rains</td>
<td class="left">RAINS delegation chain; see <a href="#cbor-signature" class="xref">Section 7.17</a>
</td>
</tr></tbody>
</table>
<p id="rfc.section.7.17.p.6">Within the RAINS delegation chain keyspace, the key phase is an unbounded, unsigned integer matching a signature&#8217;s key phase to the delegation key phase.  Multiple keys may be valid for a delegation at a given point in time, in order to support seamless rollover of keys, but only one per key phase and algorithm may be valid at once. The third element of delegation objects and signatures is the key phase.</p>
<p id="rfc.section.7.17.p.7">Valid-since and valid-until timestamps are represented as CBOR integers counting seconds since the UNIX epoch UTC, identified with tag value 1 and encoded as in section 2.4.1 of <a href="#RFC7049" class="xref">[RFC7049]</a>. A signature MUST have a valid-until timestamp. If a signature has no specified valid-since time (i.e., is valid from the beginning of time until its valid-until timestamp), the valid-since time MAY be null (as in Table 2 in Section 2.3 of <a href="#RFC7049" class="xref">[RFC7049]</a>).</p>
<p id="rfc.section.7.17.p.8">A signature in RAINS is generated over a byte stream representing the message in a canonical signing format. The signing process is defined as follows:</p>
<p></p>

<ul>
<li>Parse the object to be signed into a byte stream according to the format specified in <a href="#signing-format" class="xref">Section 8</a>.</li>
<li>Generate a signature on the resulting byte stream according to the algorithm selected.</li>
<li>Add the full signature to the signatures array at the appropriate point in the object.</li>
</ul>
<p id="rfc.section.7.17.p.10">To verify a signature, generate the byte stream as for signing, then verify the signature according to the algorithm selected.</p>
<h1 id="rfc.section.7.17.1">
<a href="#rfc.section.7.17.1">7.17.1.</a> <a href="#eddsa-format" id="eddsa-format">EdDSA signature and public key format</a>
</h1>
<p id="rfc.section.7.17.1.p.1">EdDSA public keys consist of a single value, a 32-byte bit string generated as in Section 5.1.5 of <a href="#RFC8032" class="xref">[RFC8032]</a> for Ed25519, and a 57-byte bit string generated as in Section 5.2.5 of <a href="#RFC8032" class="xref">[RFC8032]</a> for Ed448. The fourth element in a RAINS delegation object is this bit string encoded as a CBOR byte array. RAINS delegation objects for Ed25519 keys with value k are therefore represented by the array [5, 1, phase, k]; and for Ed448 keys as [5, 2, phase, k].</p>
<p id="rfc.section.7.17.1.p.2">Ed25519 and Ed448 signatures are are a combination of two non-negative integers, called &#8220;R&#8221; and &#8220;S&#8221; in sections 5.1.6 and 5.2.6, respectively, of <a href="#RFC8032" class="xref">[RFC8032]</a>. An Ed25519 signature is represented as a 64-byte array containing the concatenation of R and S, and an Ed448 signature is represented as a 114-byte array containing the concatenation of R and S. RAINS signatures using Ed25519 are therefore the array [1, 0, phase, valid-since, valid-until, R|S]; using Ed448 the array [2, 0, phase, valid-since, valid-until, R|S].</p>
<p id="rfc.section.7.17.1.p.3">Ed25519 keys are generated as in Section 5.1.5 of <a href="#RFC8032" class="xref">[RFC8032]</a>, and Ed448 keys as in Section 5.2.5 of <a href="#RFC8032" class="xref">[RFC8032]</a>.  Ed25519 signatures are generated from a normalized serialized CBOR object as in Section 5.1.6 of <a href="#RFC8032" class="xref">[RFC8032]</a>, and Ed448 signatures as in section 5.2.6 of <a href="#RFC8032" class="xref">[RFC8032]</a>.</p>
<p id="rfc.section.7.17.1.p.4">RAINS Server and Client implementations MUST support Ed25519 signatures for delegation.</p>
<h1 id="rfc.section.7.17.2">
<a href="#rfc.section.7.17.2">7.17.2.</a> <a href="#ecdsa-format" id="ecdsa-format">ECDSA signature and public key format</a>
</h1>
<p id="rfc.section.7.17.2.p.1">ECDSA public keys consist of a single value, called &#8220;Q&#8221; in <a href="#FIPS-186-3" class="xref">[FIPS-186-3]</a>. Q is a simple bit string that represents the uncompressed form of a curve point, concatenated together as &#8220;x | y&#8221;. The fourth element in a RAINS delegation object is the Q bit string encoded as a CBOR byte array. RAINS delegation objects for ECDSA-256 public keys are therefore represented as the array [5, 3, phase, Q]; and for ECDSA-384 public keys as [5, 4, phase, Q].</p>
<p id="rfc.section.7.17.2.p.2">ECDSA signatures are a combination of two non-negative integers, called &#8220;r&#8221; and &#8220;s&#8221; in <a href="#FIPS-186-3" class="xref">[FIPS-186-3]</a>. A Signature using ECDSA is represented using a four-element CBOR array, with the fourth element being &#8220;r | s&#8221; such that r is represented as a byte array as described in Section C.2 of <a href="#FIPS-186-3" class="xref">[FIPS-186-3]</a>, and s represented as a byte array as described in Section C.2 of <a href="#FIPS-186-3" class="xref">[FIPS-186-3]</a>. For ECDSA-256 signatures, each integer MUST be represented as a 32-byte array. For ECDSA-384 signatures, each integer MUST be represented as a 48-byte array. RAINS signatures using ECDSA-256 are therefore the array [3, 0, phase, valid-since, valid-until, r|s]; and for ECDSA-384 the array [4, 0, phase, valid-since, valid-until, r|s].</p>
<p id="rfc.section.7.17.2.p.3">ECDSA-256 signatures and public keys use the P-256 curve as defined in <a href="#FIPS-186-3" class="xref">[FIPS-186-3]</a>.  ECDSA-384 signatures and public keys use the P-384 curve as defined in <a href="#FIPS-186-3" class="xref">[FIPS-186-3]</a>.</p>
<p id="rfc.section.7.17.2.p.4">ECDSA-256 and ECDSA-384 support are primarily meant for compatibility with and migration from existing DNSSEC deployments; see <a href="#dns-transition" class="xref">Section 12.6</a>.</p>
<h1 id="rfc.section.7.18">
<a href="#rfc.section.7.18">7.18.</a> <a href="#cbor-capabilities" id="cbor-capabilities">Capabilities</a>
</h1>
<p id="rfc.section.7.18.p.1">When a RAINS server or client sends the first message in a stream to a peer, it MUST expose its configured capabilities to its peer using the capabilities (1) key. This key contains either:</p>
<p></p>

<ul>
<li>an array of uniform resource names specifying capabilities supported by the sending server, taken from the table below, with each name encoded as a UTF-8 string.</li>
<li>a SHA-256 hash of the CBOR byte stream derived from normalizing such an array by sorting it in lexicographically increasing order, then serializing it.</li>
</ul>
<p id="rfc.section.7.18.p.3">This mechanism is inspired by <a href="#XEP0115" class="xref">[XEP0115]</a>, and is intended to be used to reduce the overhead in exposing common sets of capabilities. Each RAINS server can cache a set of recently-seen or common hashes, and only request the full URN set (using notification code 399) on a cache miss.</p>
<p id="rfc.section.7.18.p.4">The following URNs are presently defined; other URNs will specify future optional features, support for alternate transport protocols and new signature algorithms, etc.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
<thead><tr>
<th class="left">URN</th>
<th class="left">Meaning</th>
</tr></thead>
<tbody><tr>
<td class="left">urn:x-rains:tlssrv</td>
<td class="left">Listens for connections on TLS over TCP from other RAINS servers.</td>
</tr></tbody>
</table>
<p id="rfc.section.7.18.p.5">Since there are only two defined capabilities at this time, RAINS servers can be implemented with two hard-coded hashes to determine whether a peer is listening or not. The hash presented by a server supporting urn:x-rains:tlssrv is e5365a09be554ae55b855f15264dbc837b04f5831daeb321359e18cdabab5745; the hash presented by a client or a server supporting no capabilities (not listening) is 76be8b528d0075f7aae98d6fa57a6d3c83ae480a8469e668d7b0af968995ac71.</p>
<p id="rfc.section.7.18.p.6">Servers MAY piggyback capability negotiation on other messages, or use dedicated messages for capability negotiation.</p>
<p id="rfc.section.7.18.p.7">A RAINS server MUST NOT assume that a peer server supports a given capability unless it has received a message containing that capability from that server.  An exception are the capabilities indicating that a server listens for connections using a given transport protocol; servers and clients can also learn this information from RAINS itself (given a redirection assertion for a named zone) or from external configuration values.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#signing-format" id="signing-format">Canonical signing format</a>
</h1>
<p id="rfc.section.8.p.1">[EDITOR&#8217;S NOTE: to define, based on CBOR canonicalization, once this is implemented.]</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#protocol-def" id="protocol-def">RAINS Protocol Definition</a>
</h1>
<p id="rfc.section.9.p.1">As noted in <a href="#cbor" class="xref">Section 7</a>, RAINS is a message-exchange protocol that uses CBOR <a href="#RFC7049" class="xref">[RFC7049]</a> as its framing. Since CBOR is self-framing &#8211; a CBOR parser can determine when a CBOR object is complete at the point at which it has read its final byte &#8211; RAINS requires no external framing. It can therefore run over any streaming, multistreaming, or message-oriented transport protocol. In order to protect query confidentiality, and support rapid deployment over a ubiquitously implemented transport, RAINS is defined in this document to run over persistent TLS 1.3 connections <a href="#RFC8446" class="xref">[RFC8446]</a> over TCP <a href="#RFC0793" class="xref">[RFC0793]</a> with mutual authentication between servers, and authentication of servers by clients. The TLS certificates of RAINS server peers can be verified as specified in the cert-info assertions for those servers.</p>
<p id="rfc.section.9.p.2">RAINS servers MUST support this transport; future transports can be negotiated using the capabilities mechanism after bootstrapping using TLS 1.3. As RAINS is an experimental protocol, RAINS servers listen on port 1022 <a href="#RFC4727" class="xref">[RFC4727]</a> for connections from other RAINS servers and clients. RAINS servers should strive to keep connections open to peer servers, unless it is clear that no future messages will be exchanged with those peers, or in the face of resource limitations at either peer. If a RAINS server needs to send a message to another RAINS server to which it does not have an open connection, it attempts to open a connection with that server.</p>
<p id="rfc.section.9.p.3">This section describes the operation of the protocol as used among RAINS servers. A simplified version of the protocol for client access is described in <a href="#protocol-client" class="xref">Section 10</a>, and a simplified version of the protocol for publication by authorities is described in <a href="#protocol-publish" class="xref">Section 11</a>.</p>
<h1 id="rfc.section.9.1">
<a href="#rfc.section.9.1">9.1.</a> <a href="#bootstrapping" id="bootstrapping">Bootstrapping</a>
</h1>
<p id="rfc.section.9.1.p.1">At startup, a server performing recursive lookup MUST have access to at least one of each of these three assertion types: a self-signed delegation assertion of the root zone, a redirection assertion containing the name of an authoritative root name server, and an ip4 or ip6 assertion of the root name server mentioned in the redirection assertion. These assertions must be obtained through a secure out of band mechanism. For a caching server, it is sufficient to have a connection to a recursive resolver which does the lookup on its behalf.</p>
<p id="rfc.section.9.1.p.2">When a zone authority delegates a part of its namespace to a subordinate, it MUST sign and serve the assertions of the three above mentioned types. This information is necessary for a recursive resolver to determine in a recursive lookup where to ask for a more specific answer and to validate the response.</p>
<h1 id="rfc.section.9.2">
<a href="#rfc.section.9.2">9.2.</a> <a href="#allowed-inconsistencies" id="allowed-inconsistencies">Allowed Inconsistencies</a>
</h1>
<p id="rfc.section.9.2.p.1">For RAINS to work in a highly dynamic environment, some time-bounded inconsistencies are allowed to occur. On the one hand, an authority wants to prove nonexistence of a name for a duration of time to make caching possible to reduce query latency and reduce load on its naming servers. On the other hand, an authority wants to add the name of a new delegation as quickly as possible and also allow its customers to make changes available quickly. Assuming an authority resigns sections every x seconds, then any inconcistency can occur at most x seconds. At the point in time a section is signed, its content MUST represent the state of the zone at that point in time. The following actions result in allowed inconsistencies:</p>
<p></p>

<ul>
<li>Creation of a new assertion: Shards and P-Shards in range, and zones signed before this assertion was created and which are still valid, prove that this assertion is nonexistent, although it does now.</li>
<li>Changed object value of an assertion: Shards in range and zones signed before this assertion was created and which are still valid, prove that this assertion is nonexistent, althoug it does now.</li>
<li>Expiration of an assertion: Shards and P-Shards in range, and zones signed before this assertion has expired and which are still valid, prove that this assertion exists, although it does not anymore.</li>
<li>Revocation of an assertion: Same inconsistencies as for expiration of an assertion with the addition, that the assertion itself might still be cached and served although it has been revoked.</li>
</ul>
<p id="rfc.section.9.2.p.3">Two sections for proving nonexistence (shard, P-Shard or zone) which have an overlapping range and validity time where in between the signing of the two sections any of the above mentioned actions leading to inconsistencies happend, become inconsistent as well. One of them has the old view, while the newer one has the updated view about the assertion. Note that there is no inconsistency between a P-Shard and any other section proving nonexistence if only the object value of the assertion has changed (a P-Shard does not store this information).</p>
<p id="rfc.section.9.2.p.4">Note that most assertions are consistent between each other as the union of them is considered to be the valid state. However, there are few exceptions mentioned in <a href="#runtime-consistency-checking" class="xref">Section 9.6</a>.</p>
<h1 id="rfc.section.9.3">
<a href="#rfc.section.9.3">9.3.</a> <a href="#protocol-processing" id="protocol-processing">Message processing</a>
</h1>
<p id="rfc.section.9.3.p.1">Once a transport is established, any server may validly send a message with any content to any other server. A client may send messages containing queries to servers, and a server may sent messages containing anything other than queries to clients.</p>
<p id="rfc.section.9.3.p.2">Upon receipt of a message, a server or client attempts to parse it.</p>
<p id="rfc.section.9.3.p.3">If the server or client cannot parse the message at all, it returns a 400 Bad Message notification to the peer. This notification may have a null token if the token cannot be retrieved from the message.</p>
<p id="rfc.section.9.3.p.4">If the server or client can parse the message, it:</p>
<p></p>

<ul>
<li>notes the token on the message. This token MUST be present on any messages sent in reply to this message.</li>
<li>processes any capabilities present, replacing the set of capabilities known for the peer with the set present in the message. If the present capabilities are represented by a hash that the server does not have in its cache, it prepares a notification of type 399 &#8220;Capability hash not understood&#8221; to send to its peer.</li>
<li>splits the contents into its constituent message sections, and verifies that each is acceptable. Specifically, queries are not accepted by clients (see <a href="#protocol-client" class="xref">Section 10</a>), and 404 No Assertion Exists notifications are not accepted by servers. If a message contains an unacceptable section, the server or client returns a 400 Bad Message notification to its peer, and ceases processing of the message.</li>
</ul>
<p id="rfc.section.9.3.p.6">On receipt of an assertion, shard, P-Shard, or zone message section, a server:</p>
<p></p>

<ul>
<li>verifies its consistency (see <a href="#runtime-consistency-checking" class="xref">Section 9.6</a>). If the section is not consistent, it prepares to send a notification of type 403 Inconsistent Message to the peer, and discards the section. Otherwise, it:</li>
<li>determines whether it answers an outstanding query; if so, it prepares to forward the section to the server that issued the query.</li>
<li>determines whether it is likely to answer a future query, according to its configuration, policy, and query history; if so, it caches the section.</li>
</ul>
<p id="rfc.section.9.3.p.8">On receipt of an assertion, shard, P-Shard or zone message section, a client:</p>
<p></p>

<ul>
<li>determines whether it answers an outstanding query; if so, it considers the query answered. It then:</li>
<li>determines whether it is likely to answer a future query, according to its configuration, policy, and query history; if so, it caches the section.</li>
</ul>
<p id="rfc.section.9.3.p.10">On receipt of a query, a server:</p>
<p></p>

<ol>
<li>determines whether it has expired by checking the query-expires value. If so, it drops the query silently. If not, it:</li>
<li>determines whether it has at least one stored assertion answering the query.  If so, it returns the assertion(s) with the longest validUntil value that is already valid. If not, it:</li>
<li>checks whether the query specifies option 1 and/or 9. If so, it: <ul><li>determines whether the chosen option is in compliance with the server&#8217;s configuration and policy. If so, and: <ul>
<li>option 9 is set and option 1 is not, it continues with step 4.</li>
<li>option 1 is set, it checks whether it has a cached section to proof nonexistence. If so: <ul>
<li>and option 9 is not set, it returns the section with the shortest size or the signature of the longest remaining validity to the peer that issued the query depending on the server&#8217;s policy. [EDITOR&#8217;S NOTE: Add a query option for this decision?]</li>
<li>and option 9 is set, it might send a 211 notification back to the client, depending on the server&#8217;s configuration. Independent of the previous decision it then continues with step 4.  If not, the server overwrites the query&#8217;s option according to its configuration and policy and processes it as above with the adapted option.  If not, it:</li>
</ul>
</li>
</ul>
</li></ul>
</li>
<li>checks to see whether the query specifies option 4 (cached answers only). If so, and if option 5 (expired assertions acceptable) is also specified, it then checks to see if it has any cached sections that answer the query on which signatures are expired; otherwise, processing stops, and the server returns a 504 No Assertion Available notification, as if the query had instantly expired. If the query does not specify option 4, delegation proceeds, and the server:</li>
<li>determines whether it has other non-authoritative servers it can forward the query to, according to its configuration and policy, and in compliance with any query options (see <a href="#cbor-query" class="xref">Section 7.8</a>). If so, it prepares to forward the query to those servers, noting the reply for the received query depends on the replies for the forwarded query. If not, it:</li>
<li>determines the responsible authority servers for the zone containing the query name in the query for the context requested, and forwards the query to those authority servers, noting the reply for the received query depends on the reply for the forwarded query.</li>
</ol>
<p id="rfc.section.9.3.p.12">If query delegation fails to return an answer within the maximum of the valid-until time in the received query and a configured maximum timeout for a delegated query, the server prepares to send a 504 No assertion available response to the peer from which it received the query.</p>
<p id="rfc.section.9.3.p.13">When a server creates a new query to forward to another server in response to a query it received, it SHOULD NOT use the same token on the delegated query as on the received query, unless option 6 Enable Tracing is present in the received, in which case it MUST use the same token. The Enable Tracing option is designed to allow debugging of query processing across multiple servers, It SHOULD only be enabled by clients designed explicitly for debugging RAINS itself, and MUST NOT be enabled by default by client resolvers.</p>
<p id="rfc.section.9.3.p.14">When a server creates a new query to forward to another server in response to a query it received, and the received query contains a query-expires time, the delegated query MUST NOT have a query-expires time after that in the received query. If the received query contains no query-expires time, the delegated query MAY contain a query- expires time of the server&#8217;s choosing, according to its configuration.</p>
<p id="rfc.section.9.3.p.15">On receipt of an assertion update query, a server:</p>
<p></p>

<ul>
<li>determines whether it has expired by checking the query-expires value. If so, it drops the query silently. If not, it:</li>
<li>determines whether it is the authoritative server of the queried name. If so, <ul>
<li>it checks if the hashed assertion is still the assertion currently valid with the highest validUntil time for the given name, context, type and object value. In that case it returns a 200 notification message which contains the hash value of the assertion. If not, it:</li>
<li>determines whether there is at least one assertion for the same name, type and object value which is already valid and its validUntil time is higher.  If so, the assertion with the highest validUntil value is returned. If not:</li>
<li>the assertion must have been revoked in the meantime and either a 210 notification message containing the hash value of the assertion or a section proofing nonexistence is returned. If such a section exists it MUST be returned.  If not, it:</li>
</ul>
</li>
<li>determines whether it has other non-authoritative servers it can forward the query to, according to its configuration and policy. If so, it prepares to forward the query to those servers, noting the reply for the received query depends on the replies for the forwarded query. If not, it:</li>
<li>determines the responsible authority servers for the zone containing the query name and forwards the query to those authority servers, noting the reply for the received query depends on the reply for the forwarded query.</li>
</ul>
<p id="rfc.section.9.3.p.17">If the server does not obtain an answer within the maximum of the valid-until time in the received query and a configured maximum timeout for an assertion update query, the server sends a 504 No assertion available response to the peer from which it received the query.</p>
<p id="rfc.section.9.3.p.18">When a server creates a new assertion update query to forward to another server in response to an assertion update query it received, it SHOULD NOT use the same token on the new query as on the received query, unless query option 6 Enable Tracing is present in the received query, in which case it MUST use the same token. The Enable Tracing option is designed to allow debugging of query processing across multiple servers, It SHOULD only be enabled by clients designed explicitly for debugging RAINS itself, and MUST NOT be enabled by default by client resolvers.</p>
<p id="rfc.section.9.3.p.19">When a server creates a new assertion update query to forward to another server in response to an assertion update query it received, and the received query contains a query-expires time, the new query MUST NOT have a query-expires time after that in the received query. If the received query contains no query-expires time, the new query MAY contain a query- expires time of the server&#8217;s choosing, according to its configuration.</p>
<p id="rfc.section.9.3.p.20">On receipt of an nonexistence update query, a server:</p>
<p></p>

<ul>
<li>determines whether it has expired by checking the query-expires value. If so, it drops the query silently. If not, it:</li>
<li>determines whether it is the authoritative server of the queried name. If so, <ul>
<li>it checks if it has a valid assertion for the queried context, subject-name and type. In this case it returns the assertion. If not, it:</li>
<li>determines whether it has an already valid zone, P-Shard, or shard in the range of the queried fully-qualified name, in a matching context, and with a higher validUntil value. If so, the section with the highest validUntil value is returned. If not, it:</li>
<li>knows that the received shard, P-Shard, or zone is still the most recent one and a 200 notification message containing the hash value of the section is returned.  If not, it:</li>
</ul>
</li>
<li>determines whether it has other non-authoritative servers it can forward the query to, according to its configuration and policy. If so, it prepares to forward the query to those servers, noting the reply for the received query depends on the replies for the forwarded query. If not, it:</li>
<li>determines the responsible authority servers for the zone containing the query name and forwards the query to those authority servers, noting the reply for the received query depends on the reply for the forwarded query.</li>
</ul>
<p id="rfc.section.9.3.p.22">If the server does not obtain an answer within the maximum of the valid-until time in the received query and a configured maximum timeout for an assertion update query, the server sends a 504 No assertion available response to the peer from which it received the query.</p>
<p id="rfc.section.9.3.p.23">When a server creates a new nonexistence update query to forward to another server in response to an nonexistence update query it received, it SHOULD NOT use the same token on the new query as on the received query, unless query option 6 Enable Tracing is present in the received query, in which case it MUST use the same token. The Enable Tracing option is designed to allow debugging of query processing across multiple servers, It SHOULD only be enabled by clients designed explicitly for debugging RAINS itself, and MUST NOT be enabled by default by client resolvers.</p>
<p id="rfc.section.9.3.p.24">When a server creates a new nonexistence update query to forward to another server in response to an nonexistence update query it received, and the received query contains a query-expires time, the new query MUST NOT have a query-expires time after that in the received query. If the received query contains no query-expires time, the new query MAY contain a query- expires time of the server&#8217;s choosing, according to its configuration.</p>
<p id="rfc.section.9.3.p.25">On receipt of a notification, a server&#8217;s behavior depends on the notification type:</p>
<p></p>

<ul>
<li>For type 100 &#8220;Connection Heartbeat&#8221;, the server does nothing: these null messages are used to keep long-lived connections open in the presence of network behaviors that may drop state for idle connections.</li>
<li>For type 399 &#8220;Capability hash not understood&#8221;, the server prepares to send a full capabilities list on the next message it sends to the peer.</li>
<li>For type 504 &#8220;No assertion available&#8221;, the server checks the token on the message, and prepares to forward the assertion to the associated query.</li>
<li>For type 413 &#8220;Message too large&#8221; the server notes that large messages may not be sent to a peer and tries again (see <a href="#protocol-limits" class="xref">Section 9.5</a>), or logs the error along with the note-data content.</li>
<li>For type 400 &#8220;Bad message&#8221;, type 403 &#8220;Inconsistent message&#8221;, type 500 &#8220;Server error&#8221;, or type 501 &#8220;Server not capable&#8221;, the server logs the error along with the note-data content, as these notifications generally represent implementation or configuration error conditions which will require human intervention to mitigate.</li>
</ul>
<p id="rfc.section.9.3.p.27">On receipt of a notification, a client&#8217;s behavior depends on the notification type:</p>
<p></p>

<ul>
<li>For type 100 &#8220;Connection Heartbeat&#8221;, the client does nothing, as above.</li>
<li>For type 399 &#8220;Capability hash not understood&#8221;, the client prepares to send a full capabilities list on the next message it sends to the peer.</li>
<li>For type 404 &#8220;No assertion exists&#8221;, the client takes the query to be unanswerable. It may reissue the query with query option 7 to do the verification of nonexistence again, if the server from which it received the notification is untrusted.</li>
<li>For type 413 &#8220;Message too large&#8221; the client notes that large messages may not be sent to a peer and tries again (see <a href="#protocol-limits" class="xref">Section 9.5</a>), or logs the error along with the note-data content.</li>
<li>For type 400 &#8220;Bad message&#8221;, type 403 &#8220;Inconsistent message&#8221;, type 500 &#8220;Server error&#8221;, or type 501 &#8220;Server not capable&#8221;, the client logs the error along with the note-data content, as these notifications generally represent implementation or configuration error conditions which will require human intervention to mitigate.</li>
</ul>
<p id="rfc.section.9.3.p.29">The first message a server or client sends to a peer after a new connection is established SHOULD contain a capabilities section, if the server or client supports any optional capabilities. See <a href="#cbor-capabilities" class="xref">Section 7.18</a>.</p>
<p id="rfc.section.9.3.p.30">If the server is configured to keep long-running connections open, due to the presence of network behaviors that may drop state for idle connections, it SHOULD send a message containing a type 100 Connection Heartbeat notification after a configured idle time without any messages containing other content being sent.</p>
<p id="rfc.section.9.3.p.31">In general, servers should follow the principles laid out in <a href="#I-D.iab-protocol-maintenance" class="xref">[I-D.iab-protocol-maintenance]</a>. A malformed message section, or a message section with any invalid (but not expired) signature, should be dropped and log.  A malformed message section or invalid signature should not, however, result in other sections in the same message being dropped, except as explicitly noted above.</p>
<h1 id="rfc.section.9.4">
<a href="#rfc.section.9.4">9.4.</a> <a href="#message-transmission" id="message-transmission">Message Transmission</a>
</h1>
<p id="rfc.section.9.4.p.1">As noted in <a href="#protocol-processing" class="xref">Section 9.3</a> many messages are sent in reply to messages received from peers. Servers may also originate messages on their own, based on their configuration and policy:</p>
<p></p>

<ul>
<li>Proactive queries to retrieve assertions, shards, and zones for which all signatures have expired or will soon expire, for cache management purposes.</li>
<li>Proactive push of assertions, shards, and zones to other servers, based on query history or other information indicating those servers may query for the assertions they contain.</li>
</ul>
<h1 id="rfc.section.9.5">
<a href="#rfc.section.9.5">9.5.</a> <a href="#protocol-limits" id="protocol-limits">Message Limits</a>
</h1>
<p id="rfc.section.9.5.p.1">RAINS servers MUST accept messages up to 65536 bytes in length, but MAY accept messages of greater length, subject to resource limitations of the server. A server with resource limitations MUST respond to a message rejected due to length restrictions with a notification of type 413 (Message Too Large). A server that receives a type 413 notification must note that the peer sending the message only accepts messages smaller than the largest message it&#8217;s successfully sent that peer, or cap messages to that peer to 65536 bytes in length.</p>
<p id="rfc.section.9.5.p.2">Since a bare assertion with a single Ed25519 signature requires on the order of 180 bytes, it is clear that many full zones won&#8217;t fit into a single minimum maximum-size message. Authorities are therefore encouraged to publish zones grouped into shards that will fit into 65536-byte messages, to allow servers to reply using these shards when full-zone transfers are not possible due to message size limitations.</p>
<h1 id="rfc.section.9.6">
<a href="#rfc.section.9.6">9.6.</a> <a href="#runtime-consistency-checking" id="runtime-consistency-checking">Runtime Consistency Checking</a>
</h1>
<p id="rfc.section.9.6.p.1">The data model used by the RAINS protocol allows inconsistent information to be asserted, all resulting from misconfigured or misbehaving authority servers. The following types of inconsistency are possible:</p>
<p></p>

<ul>
<li>A shard omits an assertion within its range which is valid at the same time as the shard.</li>
<li>A zone omits an assertion within its zone which is valid at the same time as the zone.</li>
<li>An address assertion contains an object that is not allowed (see <a href="#cbor-revassert" class="xref">Section 7.11</a>)</li>
<li>An assertion prohibited by its zone&#8217;s nameset is valid at the same time as the zone&#8217;s nameset assertion.</li>
<li>A zone contains a valid reflexive assertion of a given object type at the same time that its superordinate zone contains a valid assertion of the same type.</li>
<li>Delegations to more than one key are simultaneously valid for a given context, zone, signature algorithm, and key phase.</li>
</ul>
<p id="rfc.section.9.6.p.3">RAINS relies on runtime consistency checking to mitigate inconsistency: each server receiving an assertion, shard, or zone SHOULD, subject to resource constraints, ensure that it is consistent with other information it has, and if not, discard all inconsistent assertions, shards, and zones in its cache, log the error, and send a 403 Inconsistent Message to the source of the message.</p>
<h1 id="rfc.section.9.7">
<a href="#rfc.section.9.7">9.7.</a> <a href="#integrity-and-confidentiality-protection" id="integrity-and-confidentiality-protection">Integrity and Confidentiality Protection</a>
</h1>
<p id="rfc.section.9.7.p.1">Assertions are not valid unless they contain at least one signature that can be verified from the chain of authorities specified by the name and context on the assertion; integrity protection is built into the information model. The infrastructure key object type allows keys to be associated with RAINS servers in addition to zone authorities, which allows a client to delegate integrity verification of assertions to a trusted query service (see <a href="#protocol-client" class="xref">Section 10</a>).</p>
<p id="rfc.section.9.7.p.2">Since the job of an Internet naming service is to provide publicly-available information mapping names to information needed to connect to the services they name, confidentiality protection for assertions is not a goal of the system. Specifically, the information model and the mechanism for proving nonexistence of an assertion is not designed to provide resistance against zone enumeration.</p>
<p id="rfc.section.9.7.p.3">On the other hand, confidentiality protection of query information is crucial.  Linking naming queries to a specific user can be nearly as useful to build a profile of that user for surveillance purposes as full access to the clear text of that client&#8217;s communications <a href="#RFC7624" class="xref">[RFC7624]</a>. In this revision, RAINS uses TLS to protect communications between servers and between servers and clients, with certificate information for RAINS infrastructure stored in RAINS itself.  Together with hop-by-hop confidentiality protection, query options, proactive caching, default use of non-persistent tokens, and redirection among servers can be used to mix queries and reduce the linkability of query information to specific clients.</p>
<h1 id="rfc.section.9.8">
<a href="#rfc.section.9.8">9.8.</a> <a href="#cooperative-delegation-distribution" id="cooperative-delegation-distribution">Cooperative Delegation Distribution</a>
</h1>
<p id="rfc.section.9.8.p.1">Regardless of any other configuration directive, a RAINS server MUST be prepared to provide a full chain of delegation assertions from the appropriate delegation root to the signature on any assertion it gives to a peer or a client, whether as additional assertions on a message answering a query, or in reply to a subsequent query. This property allows RAINS servers to maintain a full delegation tree.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#protocol-client" id="protocol-client">RAINS Client Protocol</a>
</h1>
<p id="rfc.section.10.p.1">The protocol used by clients to issue queries to and receive responses from a query service is a subset of the full RAINS protocol, with the following differences:</p>
<p></p>

<ul>
<li>Clients only process assertion, shard, zone, and notification sections; sending a query to a client results in a 400 Bad Message notification.</li>
<li>Clients never listen for connections; a client must initiate and maintain a transport session to the query server(s) it uses for name resolution.</li>
<li>Servers only process query and notification sections when connected to clients; a client sending assertions to a server results in a 400 Bad Message notification.</li>
</ul>
<p id="rfc.section.10.p.3">Since signature verification is resource-intensive, clients delegate signature verification to query servers by default. The query server signs the message containing results for a query using its own key (published as an infrakey object associated with the query server&#8217;s name), and a validity time corresponding to the signature it verified with the longest lifetime, stripping other signatures from the reply. This behavior can be disabled by a client by specifying query option 7, allowing the client to do its own verification.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#protocol-publish" id="protocol-publish">RAINS Publication Protocol</a>
</h1>
<p id="rfc.section.11.p.1">The protocol used by authorities to publish assertions to an authority service is a subset of the full RAINS protocol, with the following differences:</p>
<p></p>

<ul>
<li>Servers only process assertion, shard, zone, and notification sections when connected to publishers; sending a query to a server via the publication procotol results in a 400 Bad Message notification. Servers only process notifications for capability negotiation purposes (see <a href="#cbor-capabilities" class="xref">Section 7.18</a>).</li>
<li>Publishers only process notification sections; sending a query or assertion to a publisher results in a 400 Bad Message notification.</li>
</ul>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#deployment-considerations" id="deployment-considerations">Deployment Considerations</a>
</h1>
<p id="rfc.section.12.p.1">The following subsections discuss issues that must be considered in any deployment of RAINS at scale.</p>
<h1 id="rfc.section.12.1">
<a href="#rfc.section.12.1">12.1.</a> <a href="#assertion-lifetime-management" id="assertion-lifetime-management">Assertion Lifetime Management</a>
</h1>
<p id="rfc.section.12.1.p.1">An assertion can contain multiple signatures, each with a different lifetime.  Signature lifetimes are equivalent to a time to live in the present DNS: authorities should compute a new signature for each validity period, and make these new signatures available when old ones are expiring.</p>
<p id="rfc.section.12.1.p.2">Since assertion lifetime management is based on a real-time clock expressed in UTC, RAINS servers MUST use a clock synchronization protocol such as NTP <a href="#RFC5905" class="xref">[RFC5905]</a>.</p>
<p id="rfc.section.12.1.p.3">RAINS servers MAY coalesce assertion lifetimes, e.g. using only the most recent valid-until time in their cache management. This implies that an assertion with valid signatures in time intervals (T1, T2) and (T3, T4) such that T3 &gt; T2 may be cached during the interval (T2, T3) as well. Authorites MUST NOT rely on non-caching or non-availability of assertions during such intervals.</p>
<h1 id="rfc.section.12.2">
<a href="#rfc.section.12.2">12.2.</a> <a href="#secret-key-management" id="secret-key-management">Secret Key Management</a>
</h1>
<p id="rfc.section.12.2.p.1">The secret keys associated with public keys for each RAINS server (via infrakey objects) must be available on that server, whether through a hardware or software security device, so they can sign messages on demand; this is particularly important for query servers. In addition, the secret keys associated with TLS certificates for each server (published via certinfo objects) must be available as well in order to establish TLS sessions.</p>
<p id="rfc.section.12.2.p.2">However, storing zone secret keys (associated via delegation objects) on RAINS servers would represent a more serious operational risk. To keep this from being necessary, authority servers have an additional signer interface, from which they will accept and cache any assertion, shard, or zone for which they are authority servers until at least the end of validity of the last signature, provided the signature is verifiable.</p>
<h1 id="rfc.section.12.3">
<a href="#rfc.section.12.3">12.3.</a> <a href="#public-key-management" id="public-key-management">Public Key Management</a>
</h1>
<p id="rfc.section.12.3.p.1">As signature lifetime is used to manage assertion lifetime, and key rotation strategies may be used both for revocation as well as operational flexibility purposes, RAINS presents a much more dynamic key management environment than that presented by DNSSEC.</p>
<h1 id="rfc.section.12.3.1">
<a href="#rfc.section.12.3.1">12.3.1.</a> <a href="#key-phase-and-key-rotation" id="key-phase-and-key-rotation">Key Phase and Key Rotation</a>
</h1>
<p id="rfc.section.12.3.1.p.1">Each signature and public key in a RAINS message is associated with a key phase, allowing multiple keys to be valid for a given authority at any given time. For example, given two key phases and a key validity interval of one day, a phase 0 key would be valid from 00:00 on day 0 to 00:00 on day 1, and a phase 1 key valid from 12:00 on day 0 to 12:00 on day 1. When the phase 0 key expires, it would be replaced by a new phase 0 valid from 00:00 on day 1 to 00:00 on day 2, and so on.</p>
<p id="rfc.section.12.3.1.p.2">Since the end time of the validity of a signature on an assertion is the maximum of the validity of the signatures on each of the delegations in the delegation chain from the root, key rotation avoids mass expiration of assertions, at the cost of requiring one valid signatures per key phase on at least all delegation assertions. Key rotation schedules are a matter of authority operational policy, but key validity intervals should be longer the closer in the delegation chain an assertion is to the root.</p>
<h1 id="rfc.section.12.3.2">
<a href="#rfc.section.12.3.2">12.3.2.</a> <a href="#next-key-assertions" id="next-key-assertions">Next Key Assertions</a>
</h1>
<p id="rfc.section.12.3.2.p.1">Another problem this dyanmic envrionment raises is how a zone authority communicates to its superordinate that it would like to begin using a new public key to sign its assertions.</p>
<p id="rfc.section.12.3.2.p.2">This can be done out of band, using private APIs provided by the superordinate authority. Through the nextkey object type, RAINS provides a way for a future public key to be shared with the superordinate authority (and all other queriers) in-band. An authority that wishes to use a new key publishes a reflexive nextkey assertion (i.e., in its own zone, with subject @) with the new public key and a requested valid-since and valid-until time range. The superordinate issues periodic queries for nextkey assertions from its subordinate zone, or the subordinate pushes these assertions to an intermediate service designated to receive them. When the superordinate receives a nextkey, and it decides it wants to delegate to the new key, it creates and signs a delegation assertion.</p>
<p id="rfc.section.12.3.2.p.3">This process is not mandatory: the superordinate is free to ignore the request, or to use a different time range, depending on its policy and/or the status of its business relationship with the subordinate. The subordinate can discover this, in turn, using its own RAINS queries, or through the delegation assertions being similarly pushed to a designated intermediate service.</p>
<h1 id="rfc.section.12.4">
<a href="#rfc.section.12.4">12.4.</a> <a href="#unsigned-contained-assertions" id="unsigned-contained-assertions">Unsigned Contained Assertions</a>
</h1>
<p id="rfc.section.12.4.p.1">Although RAINS supports Shards and Zones containing unsigned assertions, protecting the integrity of those Assertions by the signature on the Shard or Zone, it is RECOMMENDED that authorities sign each Assertion, even those contained within a Shard or Zone, in order to minimize the size of positive answers to queries.</p>
<h1 id="rfc.section.12.5">
<a href="#rfc.section.12.5">12.5.</a> <a href="#query-service-discovery" id="query-service-discovery">Query Service Discovery</a>
</h1>
<p id="rfc.section.12.5.p.1">A client that will not do its own verification must be able to discover the query server(s) it should trust for resolution. Integration with DHCP is left to a future revision of this document.</p>
<p id="rfc.section.12.5.p.2">In any case, clients MUST provide a configuration interface to allow a user to specify (by address or name) and/or constrain (by certificate property) a preferred/trusted query server. This would allow client on an untrusted network to use an untrusted locally-available query server to discover a preferred query server (doing key verification on its own for bootstrapping), before connecting to that query server for normal name resolution.</p>
<h1 id="rfc.section.12.6">
<a href="#rfc.section.12.6">12.6.</a> <a href="#dns-transition" id="dns-transition">Transition using translation between RAINS and DNS information models</a>
</h1>
<p id="rfc.section.12.6.p.1">Full adoption of RAINS would require changes to every client device (replacing DNS stub resolvers with RAINS clients) and name server on the Internet. In addition, most client software would need to change, as well, to get the full benefits of explicit context in name resolution. This is an unrealistic goal.</p>
<p id="rfc.section.12.6.p.2">RAINS servers can, however, coexist with Domain Name System servers and clients during an indefinite transition period. RAINS assertions can be algorithmically translated into DNS answers, and RAINS queries can be algorithmically translated into DNS queries, by RAINS to DNS gateways, given the mostly compatible information models used by the two.</p>
<p id="rfc.section.12.6.p.3">While DNSSEC and RAINS keys for equivalent ciphersuites are compatible with each other, there is no equivalent to query option 7 for gateways, since the RAINS signatures are generated over the RAINS byte stream for an assertion, not the DNS byte stream. Therefore, RAINS to DNS gateways must provide verification services for DNS clients. DNS over TLS <a href="#RFC7858" class="xref">[RFC7858]</a> SHOULD be used between the DNS client and gateway to ensure confidentiality and integrity for queries and answers.</p>
<p id="rfc.section.12.6.p.4">Object type mappings are as follows:</p>
<p></p>

<ul>
<li>Objects of type name can (largely) be represented as CNAME RRs.</li>
<li>Objects of type ip6-addr can be represented as AAAA RRs.</li>
<li>Objects of type ip4-addr can be represented as A RRs.</li>
<li>Objects of type redirection can be represented as NS RRs.</li>
<li>Objects of type cert-info can be represented as TLSA RRs</li>
<li>Objects of type service-info can be represented as SRV RRs.</li>
</ul>
<p id="rfc.section.12.6.p.6">There are a few object types without mappings:</p>
<p></p>

<ul>
<li>Objects of type delegation can be represented as DS RRs, and signatures as RRSIG RRs, but since these keys are verified by the gateway, there is no need to represent this information to the client.</li>
<li>Objects of type infrakey cannot be represented in DNS, but are irrelevant for DNS translation of RAINS messages, since DNS does not support server signing of responses.</li>
<li>Objects of type registrar and registrant cannot be represented in DNS; clients can use WHOIS instead. In addition, RRTYPEs could be added for them in the future if RAINS sees significant deployment with DNS as a front-end protocol.</li>
<li>Objects of type nameset cannot be represented in DNS; the current equivalent are the IDNA parameters maintained by IANA (for the DNS root zone only) at https://www.iana.org/assignments/idna-tables-6.3.0/idna-tables-6.3.0.xhtml.</li>
</ul>
<p id="rfc.section.12.6.p.8">When translating a DNS query from a client to a RAINS query for that client, client options can be set on a per-server, per-client, or per-query basis using some out of band configuration options.</p>
<p id="rfc.section.12.6.p.9">When translating a RAINS assertion to a DNS answer, the gateway can use the time to expiry for the verified signature as the TTL.</p>
<p id="rfc.section.12.6.p.10">There is no method for exposing context information in a DNS query or answer.  Therefore, queries and answers at a RAINS gateway are only supported for the global context &#8220;.&#8221;.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#experimental-design-and-evaluation" id="experimental-design-and-evaluation">Experimental Design and Evaluation</a>
</h1>
<p id="rfc.section.13.p.1">The protocol described in this document is intended primarily as a prototype for discussion, though the goal of the document is to specify RAINS completely enough to allow independent, interoperable implementation of clients an servers. The massive inertia behind the deployment of the present domain name system makes full deployment as a replacement for DNS unlikely. Despite this, there are some criteria by which the success of the RAINS experiment may be judged:</p>
<p id="rfc.section.13.p.2">First, deployment in simulated or closed networks, or in alternate Internet architectures such as SCION, allows implementation experience with the features of RAINS which DNS lacks (signatures as a first-order delegation primitive, support for explicit contexts, explicit tradeoffs in queries, runtime availability of registrar/registrant data, and nameset support), which in turn may inform the specification and deployment of these features on the present DNS.</p>
<p id="rfc.section.13.p.3">Second, deployment of RAINS &#8220;islands&#8221; in the present Internet alongside DNS on a per-domain basis would allow for comparison between operational and implementation complexity and efficiency and benefits derived from RAINS&#8217; features, as information for future development of the DNS protocol.</p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.14.p.1">The present revision of this document has no actions for IANA.</p>
<p id="rfc.section.14.p.2">The authors have registered the CBOR tag 15309736 to identify RAINS messages in the CBOR tag registry at https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml.</p>
<p id="rfc.section.14.p.3">RAINS servers currently listen for connections from other servers on Port 1022. Future revisions of this document may specify a different port, registered with IANA via Expert Review <a href="#RFC5226" class="xref">[RFC5226]</a>.</p>
<p id="rfc.section.14.p.4">The symbol table in this document in <a href="#cbor-symtab" class="xref">Section 7.1</a>, the notification code table in <a href="#cbor-notification" class="xref">Section 7.13</a>, and the signature algorithm table in <a href="#cbor-signature" class="xref">Section 7.17</a> may be candidates for IANA registries in future revisions of this document.</p>
<p id="rfc.section.14.p.5">The urn:x-rains namespace used by the RAINS capability mechanism in <a href="#cbor-capabilities" class="xref">Section 7.18</a> may be a candidate for replacement with an IANA-registered namespace in a future revision of this document.</p>
<h1 id="rfc.section.15">
<a href="#rfc.section.15">15.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.15.p.1">This document specifies a new, experimental protocol for Internet name resolution, with mandatory integrity protection for assertions about names built into the information model, and confidentiality for query information protected on a hop-by-hop basis. See especially <a href="#signatures-in-assertions" class="xref">Section 5.1.2</a>, <a href="#integrity-and-confidentiality-protection" class="xref">Section 9.7</a>, <a href="#cbor-signature" class="xref">Section 7.17</a>, <a href="#cbor-certinfo" class="xref">Section 7.14.1</a>, and <a href="#secret-key-management" class="xref">Section 12.2</a> for security-relevant details.</p>
<p id="rfc.section.15.p.2">With respect to the resistance of the protocol itself to various attacks, we consider a few potential attacks against RAINS servers and RAINS clients in the subsections below:</p>
<h1 id="rfc.section.15.1">
<a href="#rfc.section.15.1">15.1.</a> <a href="#server-state-exhaustion" id="server-state-exhaustion">Server state exhaustion</a>
</h1>
<p id="rfc.section.15.1.p.1">[EDITOR&#8217;S NOTE: detail this attack: attacker can create domain, use long-validity queries to exhaust state at server. defense: server can consider shorter validity time than that requested, but not longer. attack: attacker can push garbage assertions proactively. defense: server doesn&#8217;t accept assertions it&#8217;s never seen a query for. how to handle an attacker that pushes assertions and queries? attack: attacker can push garbage delegations, exhausting delegation chain cache. defense: server doesn&#8217;t accept sigs for domains it doesn&#8217;t know about, but what about a domain with hundreds of valid delegations? in all cases, blacklisting both clients and domains seems like a good idea.]</p>
<h1 id="rfc.section.15.2">
<a href="#rfc.section.15.2">15.2.</a> <a href="#query-relay-attacks" id="query-relay-attacks">Query relay attacks</a>
</h1>
<p id="rfc.section.15.2.p.1">[EDITOR&#8217;S NOTE: detail this attack: attacker can cause traffic overload at a targeted intermediate or authority service by crafting queries and sending them via multiple query services. There is no amplification here, but a concentration, with indirection that makes tracing difficult.]</p>
<h1 id="rfc.section.16">
<a href="#rfc.section.16">16.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a>
</h1>
<p id="rfc.section.16.p.1">Thanks to Daniele Asoni, Laurent Chuat, Markus Deshon, Ted Hardie, Joe Hildebrand, Tobias Klausmann, Steve Matsumoto, Adrian Perrig, Raphael Reischuk, Wendy Seltzer, Andrew Sullivan, and Suzanne Woolf for the discussions leading to the design of this protocol, and the definition of an ideal naming service on which it is based. Thanks especially to Stephen Shirley for detailed feedback.</p>
<h1 id="rfc.references">
<a href="#rfc.references">17.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">17.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="FIPS-186-3">[FIPS-186-3]</b></td>
<td class="top">
<a>NIST, .</a>, "<a>Digital Signature Standard FIPS 186-3</a>", June 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC0793">[RFC0793]</b></td>
<td class="top">
<a>Postel, J.</a>, "<a href="https://tools.ietf.org/html/rfc793">Transmission Control Protocol</a>", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1918">[RFC1918]</b></td>
<td class="top">
<a>Rekhter, Y.</a>, <a>Moskowitz, B.</a>, <a>Karrenberg, D.</a>, <a>de Groot, G.</a> and <a>E. Lear</a>, "<a href="https://tools.ietf.org/html/rfc1918">Address Allocation for Private Internets</a>", BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2782">[RFC2782]</b></td>
<td class="top">
<a>Gulbrandsen, A.</a>, <a>Vixie, P.</a> and <a>L. Esibov</a>, "<a href="https://tools.ietf.org/html/rfc2782">A DNS RR for specifying the location of services (DNS SRV)</a>", RFC 2782, DOI 10.17487/RFC2782, February 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="https://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4193">[RFC4193]</b></td>
<td class="top">
<a>Hinden, R.</a> and <a>B. Haberman</a>, "<a href="https://tools.ietf.org/html/rfc4193">Unique Local IPv6 Unicast Addresses</a>", RFC 4193, DOI 10.17487/RFC4193, October 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4727">[RFC4727]</b></td>
<td class="top">
<a>Fenner, B.</a>, "<a href="https://tools.ietf.org/html/rfc4727">Experimental Values In IPv4, IPv6, ICMPv4, ICMPv6, UDP, and TCP Headers</a>", RFC 4727, DOI 10.17487/RFC4727, November 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="https://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7049">[RFC7049]</b></td>
<td class="top">
<a>Bormann, C.</a> and <a>P. Hoffman</a>, "<a href="https://tools.ietf.org/html/rfc7049">Concise Binary Object Representation (CBOR)</a>", RFC 7049, DOI 10.17487/RFC7049, October 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8032">[RFC8032]</b></td>
<td class="top">
<a>Josefsson, S.</a> and <a>I. Liusvaara</a>, "<a href="https://tools.ietf.org/html/rfc8032">Edwards-Curve Digital Signature Algorithm (EdDSA)</a>", RFC 8032, DOI 10.17487/RFC8032, January 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8446">[RFC8446]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/rfc8446">The Transport Layer Security (TLS) Protocol Version 1.3</a>", RFC 8446, DOI 10.17487/RFC8446, August 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">17.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="BETTER-BLOOM-FILTER">[BETTER-BLOOM-FILTER]</b></td>
<td class="top">
<a>Adam Kirsch, .</a> and <a>. Michael Mitzenmacher</a>, "<a>Building a Better Bloom Filter</a>", May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.iab-protocol-maintenance">[I-D.iab-protocol-maintenance]</b></td>
<td class="top">
<a>Thomson, M.</a>, "<a href="https://tools.ietf.org/html/draft-iab-protocol-maintenance-00">The Harmful Consequences of the Robustness Principle</a>", Internet-Draft draft-iab-protocol-maintenance-00, May 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-dprive-dns-over-tls">[I-D.ietf-dprive-dns-over-tls]</b></td>
<td class="top">
<a>Zi, Z.</a>, <a>Zhu, L.</a>, <a>Heidemann, J.</a>, <a>Mankin, A.</a>, <a>Wessels, D.</a> and <a>P. Hoffman</a>, "<a href="https://tools.ietf.org/html/draft-ietf-dprive-dns-over-tls-09">Specification for DNS over TLS</a>", Internet-Draft draft-ietf-dprive-dns-over-tls-09, March 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-dprive-dnsodtls">[I-D.ietf-dprive-dnsodtls]</b></td>
<td class="top">
<a>Reddy, T.</a>, <a>Wing, D.</a> and <a>P. Patil</a>, "<a href="https://tools.ietf.org/html/draft-ietf-dprive-dnsodtls-15">Specification for DNS over Datagram Transport Layer Security (DTLS)</a>", Internet-Draft draft-ietf-dprive-dnsodtls-15, December 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.trammell-optional-security-not">[I-D.trammell-optional-security-not]</b></td>
<td class="top">
<a>Trammell, B.</a>, "<a href="https://tools.ietf.org/html/draft-trammell-optional-security-not-00">Optional Security Is Not An Option</a>", Internet-Draft draft-trammell-optional-security-not-00, March 2018.</td>
</tr>
<tr>
<td class="reference"><b id="IAB-UNICODE7">[IAB-UNICODE7]</b></td>
<td class="top">
<a>IAB, .</a>, "<a href="https://www.iab.org/documents/correspondence-reports-documents/2015-2/iab-statement-on-identifiers-and-unicode-7-0-0/">IAB Statement on Identifiers and Unicode 7.0.0</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="LUCID">[LUCID]</b></td>
<td class="top">
<a>Freytag, A.</a> and <a>A. Sullivan</a>, "<a href="https://www.ietf.org/proceedings/92/slides/slides-92-lucid-0.pdf">LUCID problem (slides, IETF 92 LUCID BoF)</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="PARSER-BUGS">[PARSER-BUGS]</b></td>
<td class="top">
<a>Bratus, S.</a>, <a>Patterson, M.</a> and <a>A. Shubina</a>, "<a>The Bugs We Have To Kill (USENIX login)</a>", August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4033">[RFC4033]</b></td>
<td class="top">
<a>Arends, R.</a>, <a>Austein, R.</a>, <a>Larson, M.</a>, <a>Massey, D.</a> and <a>S. Rose</a>, "<a href="https://tools.ietf.org/html/rfc4033">DNS Security Introduction and Requirements</a>", RFC 4033, DOI 10.17487/RFC4033, March 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4291">[RFC4291]</b></td>
<td class="top">
<a>Hinden, R.</a> and <a>S. Deering</a>, "<a href="https://tools.ietf.org/html/rfc4291">IP Version 6 Addressing Architecture</a>", RFC 4291, DOI 10.17487/RFC4291, February 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4632">[RFC4632]</b></td>
<td class="top">
<a>Fuller, V.</a> and <a>T. Li</a>, "<a href="https://tools.ietf.org/html/rfc4632">Classless Inter-domain Routing (CIDR): The Internet Address Assignment and Aggregation Plan</a>", BCP 122, RFC 4632, DOI 10.17487/RFC4632, August 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5226">[RFC5226]</b></td>
<td class="top">
<a>Narten, T.</a> and <a>H. Alvestrand</a>, "<a href="https://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>", RFC 5226, DOI 10.17487/RFC5226, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5730">[RFC5730]</b></td>
<td class="top">
<a>Hollenbeck, S.</a>, "<a href="https://tools.ietf.org/html/rfc5730">Extensible Provisioning Protocol (EPP)</a>", STD 69, RFC 5730, DOI 10.17487/RFC5730, August 2009.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5905">[RFC5905]</b></td>
<td class="top">
<a>Mills, D.</a>, <a>Martin, J.</a>, <a>Burbank, J.</a> and <a>W. Kasch</a>, "<a href="https://tools.ietf.org/html/rfc5905">Network Time Protocol Version 4: Protocol and Algorithms Specification</a>", RFC 5905, DOI 10.17487/RFC5905, June 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6698">[RFC6698]</b></td>
<td class="top">
<a>Hoffman, P.</a> and <a>J. Schlyter</a>, "<a href="https://tools.ietf.org/html/rfc6698">The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA</a>", RFC 6698, DOI 10.17487/RFC6698, August 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7231">[RFC7231]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7624">[RFC7624]</b></td>
<td class="top">
<a>Barnes, R.</a>, <a>Schneier, B.</a>, <a>Jennings, C.</a>, <a>Hardie, T.</a>, <a>Trammell, B.</a>, <a>Huitema, C.</a> and <a>D. Borkmann</a>, "<a href="https://tools.ietf.org/html/rfc7624">Confidentiality in the Face of Pervasive Surveillance: A Threat Model and Problem Statement</a>", RFC 7624, DOI 10.17487/RFC7624, August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7696">[RFC7696]</b></td>
<td class="top">
<a>Housley, R.</a>, "<a href="https://tools.ietf.org/html/rfc7696">Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms</a>", BCP 201, RFC 7696, DOI 10.17487/RFC7696, November 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7858">[RFC7858]</b></td>
<td class="top">
<a>Hu, Z.</a>, <a>Zhu, L.</a>, <a>Heidemann, J.</a>, <a>Mankin, A.</a>, <a>Wessels, D.</a> and <a>P. Hoffman</a>, "<a href="https://tools.ietf.org/html/rfc7858">Specification for DNS over Transport Layer Security (TLS)</a>", RFC 7858, DOI 10.17487/RFC7858, May 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7871">[RFC7871]</b></td>
<td class="top">
<a>Contavalli, C.</a>, <a>van der Gaast, W.</a>, <a>Lawrence, D.</a> and <a>W. Kumari</a>, "<a href="https://tools.ietf.org/html/rfc7871">Client Subnet in DNS Queries</a>", RFC 7871, DOI 10.17487/RFC7871, May 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8094">[RFC8094]</b></td>
<td class="top">
<a>Reddy, T.</a>, <a>Wing, D.</a> and <a>P. Patil</a>, "<a href="https://tools.ietf.org/html/rfc8094">DNS over Datagram Transport Layer Security (DTLS)</a>", RFC 8094, DOI 10.17487/RFC8094, February 2017.</td>
</tr>
<tr>
<td class="reference"><b id="SCION">[SCION]</b></td>
<td class="top">
<a>Barrera, D.</a>, <a>Reischuk, R.</a>, <a>Szalachowski, P.</a> and <a>A. Perrig</a>, "<a>SCION Five Years Later - Revisiting Scalability, Control, and Isolation Next-Generation Networks (arXiv:1508.01651v1)</a>", August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="XEP0115">[XEP0115]</b></td>
<td class="top">
<a>Hildebrand, J.</a>, <a>Saint-Andre, P.</a>, <a>Troncon, R.</a> and <a>J. Konieczny</a>, "<a>XEP-0115 Entity Capababilities</a>", February 2008.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Brian Trammell</span> 
	  <span class="n hidden">
		<span class="family-name">Trammell</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  <span class="vcardline">Universitaetstrasse 6</span>

	  <span class="vcardline">
		<span class="locality">Zurich</span>,  
		<span class="region"></span>
		<span class="code">8092</span>
	  </span>
	  <span class="country-name vcardline">Switzerland</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ietf@trammell.ch">ietf@trammell.ch</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christian Fehlmann</span> 
	  <span class="n hidden">
		<span class="family-name">Fehlmann</span>
	  </span>
	</span>
	<span class="org vcardline">ETH Zurich</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:fehlmannch@gmail.com">fehlmannch@gmail.com</a></span>

  </address>
</div>

</body>
</html>
